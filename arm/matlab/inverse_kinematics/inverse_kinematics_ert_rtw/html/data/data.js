var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"inverse_kinematics","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Main file","code":"#include <stdio.h>\n#include <stdlib.h>\n#include \"inverse_kinematics.h\"\n#include \"inverse_kinematics_private.h\"\n#include \"rtwtypes.h\"\n#include \"limits.h\"\n#include \"rt_nonfinite.h\"\n#include \"linuxinitialize.h\"\n#define UNUSED(x)                      x = x\n#define NAMELEN                        16\n\n/* Function prototype declaration*/\nvoid exitFcn(int sig);\nvoid *terminateTask(void *arg);\nvoid *baseRateTask(void *arg);\nvoid *subrateTask(void *arg);\nvolatile boolean_T stopRequested = false;\nvolatile boolean_T runModel = true;\nsem_t stopSem;\nsem_t baserateTaskSem;\npthread_t schedulerThread;\npthread_t baseRateThread;\nvoid *threadJoinStatus;\nint terminatingmodel = 0;\nvoid *baseRateTask(void *arg)\n{\n  runModel = (rtmGetErrorStatus(inverse_kinematics_M) == (NULL));\n  while (runModel) {\n    sem_wait(&baserateTaskSem);\n    inverse_kinematics_step();\n\n    /* Get model outputs here */\n    stopRequested = !((rtmGetErrorStatus(inverse_kinematics_M) == (NULL)));\n    runModel = !stopRequested;\n  }\n\n  runModel = 0;\n  terminateTask(arg);\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid exitFcn(int sig)\n{\n  UNUSED(sig);\n  rtmSetErrorStatus(inverse_kinematics_M, \"stopping the model\");\n}\n\nvoid *terminateTask(void *arg)\n{\n  UNUSED(arg);\n  terminatingmodel = 1;\n\n  {\n    runModel = 0;\n  }\n\n  /* Terminate model */\n  inverse_kinematics_terminate();\n  sem_post(&stopSem);\n  return NULL;\n}\n\nint main(int argc, char **argv)\n{\n  UNUSED(argc);\n  UNUSED(argv);\n  void slros_node_init(int argc, char** argv);\n  slros_node_init(argc, argv);\n  rtmSetErrorStatus(inverse_kinematics_M, 0);\n\n  /* Initialize model */\n  inverse_kinematics_initialize();\n\n  /* Call RTOS Initialization function */\n  myRTOSInit(0.01, 0);\n\n  /* Wait for stop semaphore */\n  sem_wait(&stopSem);\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\n\n  {\n    int i;\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\n      CHECK_STATUS(sem_destroy(&timerTaskSem[i]), 0, \"sem_destroy\");\n    }\n  }\n\n#endif\n\n  return 0;\n}\n"},{"name":"inverse_kinematics.cpp","type":"source","group":"model","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * inverse_kinematics.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"inverse_kinematics.h\"\n#include \"inverse_kinematics_types.h\"\n#include \"rtwtypes.h\"\n#include <string.h>\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n#include <math.h>\n#include \"coder_posix_time.h\"\n#include \"inverse_kinematics_private.h\"\n#include \"rt_defines.h\"\n#include <stdlib.h>\n#include <stddef.h>\n\n/* Block signals (default storage) */\nB_inverse_kinematics_T inverse_kinematics_B;\n\n/* Block states (default storage) */\nDW_inverse_kinematics_T inverse_kinematics_DW;\n\n/* Real-time model */\nRT_MODEL_inverse_kinematics_T inverse_kinematics_M_ =\n  RT_MODEL_inverse_kinematics_T();\nRT_MODEL_inverse_kinematics_T *const inverse_kinematics_M =\n  &inverse_kinematics_M_;\n\n/* Forward declaration for local functions */\nstatic void inverse_kinemati_emxInit_char_T(emxArray_char_T_inverse_kinem_T\n  **pEmxArray, int32_T numDimensions);\nstatic void emxInitStruct_t_robotics_manip_(t_robotics_manip_internal_Rig_T\n  *pStruct);\nstatic void inverse__emxInit_unnamed_struct(emxArray_unnamed_struct_inver_T\n  **pEmxArray, int32_T numDimensions);\nstatic void emxInitStruct_l_robotics_manip_(l_robotics_manip_internal_Col_T\n  *pStruct);\nstatic void emxInitMatrix_l_robotics_manip_(l_robotics_manip_internal_Col_T\n  pMatrix[13]);\nstatic void inverse_kinemati_emxInit_real_T(emxArray_real_T_inverse_kinem_T\n  **pEmxArray, int32_T numDimensions);\nstatic void emxInitStruct_c_rigidBodyJoint(c_rigidBodyJoint_inverse_kine_T\n  *pStruct);\nstatic void emxInitMatrix_c_rigidBodyJoint(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[13]);\nstatic void emxInitMatrix_t_robotics_manip_(t_robotics_manip_internal_Rig_T\n  pMatrix[12]);\nstatic void emxInitStruct_u_robotics_manip_(u_robotics_manip_internal_Rig_T\n  *pStruct);\nstatic void emxInitStruct_f_robotics_manip_(f_robotics_manip_internal_IKE_T\n  *pStruct);\nstatic void emxInitMatrix_c_rigidBodyJoint1(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[12]);\nstatic void emxInitMatrix_t_robotics_mani_g(t_robotics_manip_internal_Rig_T\n  pMatrix[6]);\nstatic void emxInitMatrix_l_robotics_mani_g(l_robotics_manip_internal_Col_T\n  pMatrix[7]);\nstatic void emxInitMatrix_c_rigidBodyJoint2(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[7]);\nstatic void emxInitStruct_v_robotics_manip_(v_robotics_manip_internal_Rig_T\n  *pStruct);\nstatic void emxInitStruct_b_inverseKinemati(b_inverseKinematics_inverse_k_T\n  *pStruct);\nstatic void emxInitStruct_robotics_slmanip_(robotics_slmanip_internal_blo_T\n  *pStruct);\nstatic void invers_emxEnsureCapacity_char_T(emxArray_char_T_inverse_kinem_T\n  *emxArray, int32_T oldNumel);\nstatic void inverse_kinemati_emxFree_char_T(emxArray_char_T_inverse_kinem_T\n  **pEmxArray);\nstatic void invers_emxEnsureCapacity_real_T(emxArray_real_T_inverse_kinem_T\n  *emxArray, int32_T oldNumel);\nstatic void emxEnsureCapacity_unnamed_struc(emxArray_unnamed_struct_inver_T\n  *emxArray, int32_T oldNumel);\nstatic void inverse__emxFree_unnamed_struct(emxArray_unnamed_struct_inver_T\n  **pEmxArray);\nstatic l_robotics_manip_internal_Col_T *inver_CollisionSet_CollisionSet\n  (l_robotics_manip_internal_Col_T *obj, real_T maxElements);\nstatic t_robotics_manip_internal_Rig_T *inverse_kin_RigidBody_RigidBody\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *inverse_k_RigidBody_RigidBody_g\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *inverse__RigidBody_RigidBody_ga\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *inverse_RigidBody_RigidBody_gaq\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *invers_RigidBody_RigidBody_gaqy\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *inver_RigidBody_RigidBody_gaqyy\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *inve_RigidBody_RigidBody_gaqyy1\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *inv_RigidBody_RigidBody_gaqyy1n\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *in_RigidBody_RigidBody_gaqyy1no\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic t_robotics_manip_internal_Rig_T *i_RigidBody_RigidBody_gaqyy1no5\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1);\nstatic c_rigidBodyJoint_inverse_kine_T *i_rigidBodyJoint_rigidBodyJoint\n  (c_rigidBodyJoint_inverse_kine_T *obj, const emxArray_char_T_inverse_kinem_T\n   *jname);\nstatic u_robotics_manip_internal_Rig_T *inv_RigidBodyTree_RigidBodyTree\n  (u_robotics_manip_internal_Rig_T *obj);\nstatic void inverse_genrand_uint32_vector_g(uint32_T mt[625], uint32_T u[2]);\nstatic boolean_T inverse_kinemati_is_valid_state(const uint32_T mt[625]);\nstatic void inverse_kinematics_rand(real_T r[5]);\nstatic boolean_T inverse_kinematics_strcmp(const emxArray_char_T_inverse_kinem_T\n  *a, const emxArray_char_T_inverse_kinem_T *b);\nstatic real_T RigidBodyTree_findBodyIndexByNa(v_robotics_manip_internal_Rig_T\n  *obj, const emxArray_char_T_inverse_kinem_T *bodyname);\nstatic void inverse_kinemati_emxFree_real_T(emxArray_real_T_inverse_kinem_T\n  **pEmxArray);\nstatic t_robotics_manip_internal_Rig_T *inverse_kinemati_RigidBody_copy\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1, t_robotics_manip_internal_Rig_T\n   *iobj_2);\nstatic void inverse_k_RigidBodyTree_addBody(v_robotics_manip_internal_Rig_T *obj,\n  t_robotics_manip_internal_Rig_T *bodyin, const emxArray_char_T_inverse_kinem_T\n  *parentName, c_rigidBodyJoint_inverse_kine_T *iobj_0,\n  t_robotics_manip_internal_Rig_T *iobj_1, l_robotics_manip_internal_Col_T\n  *iobj_2);\nstatic void inverseKinematics_set_RigidBody(b_inverseKinematics_inverse_k_T *obj,\n  u_robotics_manip_internal_Rig_T *rigidbodytree,\n  c_rigidBodyJoint_inverse_kine_T *iobj_0, t_robotics_manip_internal_Rig_T\n  *iobj_1, l_robotics_manip_internal_Col_T *iobj_2,\n  v_robotics_manip_internal_Rig_T *iobj_3);\nstatic void inverse_kinema_SystemCore_setup(robotics_slmanip_internal_blo_T *obj);\nstatic void RigidBodyTree_get_JointPosition(v_robotics_manip_internal_Rig_T *obj,\n  emxArray_real_T_inverse_kinem_T *limits);\nstatic void inverse_kinemati_emxInit_int8_T(emxArray_int8_T_inverse_kinem_T\n  **pEmxArray, int32_T numDimensions);\nstatic void invers_emxEnsureCapacity_int8_T(emxArray_int8_T_inverse_kinem_T\n  *emxArray, int32_T oldNumel);\nstatic void inverse_kinemati_emxFree_int8_T(emxArray_int8_T_inverse_kinem_T\n  **pEmxArray);\nstatic void inverse_ki_binary_expand_op_gaq(boolean_T in1[4], const real_T in2[4],\n  const emxArray_real_T_inverse_kinem_T *in3);\nstatic void inverse_kin_binary_expand_op_ga(boolean_T in1[4], const real_T in2[4],\n  const emxArray_real_T_inverse_kinem_T *in3);\nstatic void inverse_kinematics_eml_find(const boolean_T x[4], int32_T i_data[],\n  int32_T *i_size);\nstatic void inverse_kinematics_tic(real_T *tstart_tv_sec, real_T *tstart_tv_nsec);\nstatic void i_RigidBodyTree_ancestorIndices(v_robotics_manip_internal_Rig_T *obj,\n  t_robotics_manip_internal_Rig_T *body, emxArray_real_T_inverse_kinem_T\n  *indices);\nstatic void RigidBodyTree_kinematicPathInte(v_robotics_manip_internal_Rig_T *obj,\n  t_robotics_manip_internal_Rig_T *body1, t_robotics_manip_internal_Rig_T *body2,\n  emxArray_real_T_inverse_kinem_T *indices);\nstatic void in_rigidBodyJoint_get_JointAxis(const\n  c_rigidBodyJoint_inverse_kine_T *obj, real_T ax[3]);\nstatic void inverse_kinematics_cat(real_T varargin_1, real_T varargin_2, real_T\n  varargin_3, real_T varargin_4, real_T varargin_5, real_T varargin_6, real_T\n  varargin_7, real_T varargin_8, real_T varargin_9, real_T y[9]);\nstatic void inverse_kinematics_mtimes(const real_T A[36], const\n  emxArray_real_T_inverse_kinem_T *B, emxArray_real_T_inverse_kinem_T *C);\nstatic void RigidBodyTree_efficientFKAndJac(v_robotics_manip_internal_Rig_T *obj,\n  const real_T qv[4], const emxArray_char_T_inverse_kinem_T *body1Name, real_T\n  T_data[], int32_T T_size[2], emxArray_real_T_inverse_kinem_T *Jac);\nstatic creal_T inverse_kinematics_sqrt(const creal_T x);\nstatic real_T inverse_kinematics_xnrm2(int32_T n, const real_T x[9], int32_T ix0);\nstatic real_T inverse_kinematics_xdotc(int32_T n, const real_T x[9], int32_T ix0,\n  const real_T y[9], int32_T iy0);\nstatic void inverse_kinematics_xaxpy(int32_T n, real_T a, int32_T ix0, const\n  real_T y[9], int32_T iy0, real_T b_y[9]);\nstatic real_T inverse_kinematics_xnrm2_g(const real_T x[3], int32_T ix0);\nstatic void inverse_kinematics_xaxpy_gaq(int32_T n, real_T a, const real_T x[9],\n  int32_T ix0, real_T y[3], int32_T iy0);\nstatic void inverse_kinematics_xaxpy_ga(int32_T n, real_T a, const real_T x[3],\n  int32_T ix0, const real_T y[9], int32_T iy0, real_T b_y[9]);\nstatic void inverse_kinematics_xswap(const real_T x[9], int32_T ix0, int32_T iy0,\n  real_T b_x[9]);\nstatic void inverse_kinematics_xrotg(real_T a, real_T b, real_T *b_a, real_T\n  *b_b, real_T *c, real_T *s);\nstatic void inverse_kinematics_xrot(const real_T x[9], int32_T ix0, int32_T iy0,\n  real_T c, real_T s, real_T b_x[9]);\nstatic void inverse_kinematics_svd(const real_T A[9], real_T U[9], real_T s[3],\n  real_T V[9]);\nstatic void inverse_kin_IKHelpers_poseError(const real_T Td[16], const real_T\n  T_data[], const int32_T T_size[2], real_T errorvec[6]);\nstatic void inverse_kinematics_mtimes_g(const real_T A[6], const\n  emxArray_real_T_inverse_kinem_T *B, emxArray_real_T_inverse_kinem_T *C);\nstatic void inverse_kinem_emxInit_boolean_T(emxArray_boolean_T_inverse_ki_T\n  **pEmxArray, int32_T numDimensions);\nstatic real_T inverse_kinematics_norm_g(const real_T x[6]);\nstatic void inverse_kinematics_minus_g(emxArray_real_T_inverse_kinem_T *in1,\n  const emxArray_real_T_inverse_kinem_T *in2);\nstatic void inv_emxEnsureCapacity_boolean_T(emxArray_boolean_T_inverse_ki_T\n  *emxArray, int32_T oldNumel);\nstatic real_T inverse_kinematics_toc(real_T tstart_tv_sec, real_T tstart_tv_nsec);\nstatic void inverse_kinematics_mldivide(const real_T A[16], const\n  emxArray_real_T_inverse_kinem_T *B, real_T Y_data[], int32_T *Y_size);\nstatic void inverse_kine_binary_expand_op_g(real_T in1_data[], int32_T *in1_size,\n  const emxArray_real_T_inverse_kinem_T *in2, real_T in3, const real_T in4[16],\n  const emxArray_real_T_inverse_kinem_T *in5);\nstatic void inverse_kinematics_expand_max(const emxArray_real_T_inverse_kinem_T *\n  a, const real_T b[4], real_T c[4]);\nstatic void inverse_kinematics_expand_min(const emxArray_real_T_inverse_kinem_T *\n  a, const real_T b[4], real_T c[4]);\nstatic void inverse_kinem_emxFree_boolean_T(emxArray_boolean_T_inverse_ki_T\n  **pEmxArray);\nstatic void ErrorDampedLevenbergMarquardt_s(h_robotics_core_internal_Erro_T *obj,\n  real_T xSol[4], c_robotics_core_internal_NLPS_T *exitFlag, real_T *en, real_T *\n  iter);\nstatic boolean_T inverse_kinematics_any(const emxArray_boolean_T_inverse_ki_T *x);\nstatic void inverse_kinematics_randn(const real_T varargin_1[2],\n  emxArray_real_T_inverse_kinem_T *r);\nstatic void inverse_kinematics_minus(emxArray_real_T_inverse_kinem_T *in1, const\n  emxArray_real_T_inverse_kinem_T *in2);\nstatic void inverse_kinematics_plus(emxArray_real_T_inverse_kinem_T *in1, const\n  emxArray_real_T_inverse_kinem_T *in2);\nstatic void inverse_kinematics_rand_g(real_T varargin_1,\n  emxArray_real_T_inverse_kinem_T *r);\nstatic void inverse_kinema_binary_expand_op(emxArray_real_T_inverse_kinem_T *in1,\n  const emxArray_real_T_inverse_kinem_T *in2, const\n  emxArray_real_T_inverse_kinem_T *in3);\nstatic void invers_NLPSolverInterface_solve(h_robotics_core_internal_Erro_T *obj,\n  const real_T seed[4], real_T xSol[4], real_T *solutionInfo_Iterations, real_T *\n  solutionInfo_RRAttempts, real_T *solutionInfo_Error, real_T\n  *solutionInfo_ExitFlag, char_T solutionInfo_Status_data[], int32_T\n  solutionInfo_Status_size[2]);\nstatic void inverse_kinemat_emxInit_int32_T(emxArray_int32_T_inverse_kine_T\n  **pEmxArray, int32_T numDimensions);\nstatic void inver_emxEnsureCapacity_int32_T(emxArray_int32_T_inverse_kine_T\n  *emxArray, int32_T oldNumel);\nstatic void inverse_kinemat_emxFree_int32_T(emxArray_int32_T_inverse_kine_T\n  **pEmxArray);\nstatic void inverse_kinema_emxInit_uint32_T(emxArray_uint32_T_inverse_kin_T\n  **pEmxArray, int32_T numDimensions);\nstatic void inve_emxEnsureCapacity_uint32_T(emxArray_uint32_T_inverse_kin_T\n  *emxArray, int32_T oldNumel);\nstatic void inverse_kinema_emxFree_uint32_T(emxArray_uint32_T_inverse_kin_T\n  **pEmxArray);\nstatic void inver_inverseKinematics_solve_g(b_inverseKinematics_inverse_k_T *obj,\n  real_T initialGuess[4], real_T *solutionInfo_Iterations, real_T\n  *solutionInfo_NumRandomRestarts, real_T *solutionInfo_PoseErrorNorm, real_T\n  *solutionInfo_ExitFlag, char_T solutionInfo_Status_data[], int32_T\n  solutionInfo_Status_size[2]);\nstatic void inve_inverseKinematics_stepImpl(b_inverseKinematics_inverse_k_T *obj,\n  const real_T tform[16], const real_T weights[6], const real_T initialGuess[4],\n  real_T QSol[4]);\nstatic void emxFreeStruct_t_robotics_manip_(t_robotics_manip_internal_Rig_T\n  *pStruct);\nstatic void emxFreeStruct_l_robotics_manip_(l_robotics_manip_internal_Col_T\n  *pStruct);\nstatic void emxFreeMatrix_l_robotics_manip_(l_robotics_manip_internal_Col_T\n  pMatrix[13]);\nstatic void emxFreeStruct_c_rigidBodyJoint(c_rigidBodyJoint_inverse_kine_T\n  *pStruct);\nstatic void emxFreeMatrix_c_rigidBodyJoint(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[13]);\nstatic void emxFreeMatrix_t_robotics_manip_(t_robotics_manip_internal_Rig_T\n  pMatrix[12]);\nstatic void emxFreeStruct_u_robotics_manip_(u_robotics_manip_internal_Rig_T\n  *pStruct);\nstatic void emxFreeStruct_f_robotics_manip_(f_robotics_manip_internal_IKE_T\n  *pStruct);\nstatic void emxFreeMatrix_c_rigidBodyJoint1(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[12]);\nstatic void emxFreeMatrix_t_robotics_mani_g(t_robotics_manip_internal_Rig_T\n  pMatrix[6]);\nstatic void emxFreeMatrix_l_robotics_mani_g(l_robotics_manip_internal_Col_T\n  pMatrix[7]);\nstatic void emxFreeMatrix_c_rigidBodyJoint2(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[7]);\nstatic void emxFreeStruct_v_robotics_manip_(v_robotics_manip_internal_Rig_T\n  *pStruct);\nstatic void emxFreeStruct_b_inverseKinemati(b_inverseKinematics_inverse_k_T\n  *pStruct);\nstatic void emxFreeStruct_robotics_slmanip_(robotics_slmanip_internal_blo_T\n  *pStruct);\nint32_T div_s32(int32_T numerator, int32_T denominator)\n{\n  int32_T quotient;\n  if (denominator == 0) {\n    quotient = numerator >= 0 ? MAX_int32_T : MIN_int32_T;\n\n    /* Divide by zero handler */\n  } else {\n    uint32_T tempAbsQuotient;\n    tempAbsQuotient = (numerator < 0 ? ~static_cast<uint32_T>(numerator) + 1U :\n                       static_cast<uint32_T>(numerator)) / (denominator < 0 ? ~\n      static_cast<uint32_T>(denominator) + 1U : static_cast<uint32_T>\n      (denominator));\n    quotient = (numerator < 0) != (denominator < 0) ? -static_cast<int32_T>\n      (tempAbsQuotient) : static_cast<int32_T>(tempAbsQuotient);\n  }\n\n  return quotient;\n}\n\nstatic void inverse_kinemati_emxInit_char_T(emxArray_char_T_inverse_kinem_T\n  **pEmxArray, int32_T numDimensions)\n{\n  emxArray_char_T_inverse_kinem_T *emxArray;\n  *pEmxArray = static_cast<emxArray_char_T_inverse_kinem_T *>(malloc(sizeof\n    (emxArray_char_T_inverse_kinem_T)));\n  emxArray = *pEmxArray;\n  emxArray->data = static_cast<char_T *>(NULL);\n  emxArray->numDimensions = numDimensions;\n  emxArray->size = static_cast<int32_T *>(malloc(sizeof(int32_T) * numDimensions));\n  emxArray->allocatedSize = 0;\n  emxArray->canFreeData = true;\n  for (inverse_kinematics_B.i_lu = 0; inverse_kinematics_B.i_lu < numDimensions;\n       inverse_kinematics_B.i_lu++) {\n    emxArray->size[inverse_kinematics_B.i_lu] = 0;\n  }\n}\n\nstatic void emxInitStruct_t_robotics_manip_(t_robotics_manip_internal_Rig_T\n  *pStruct)\n{\n  inverse_kinemati_emxInit_char_T(&pStruct->NameInternal, 2);\n}\n\nstatic void inverse__emxInit_unnamed_struct(emxArray_unnamed_struct_inver_T\n  **pEmxArray, int32_T numDimensions)\n{\n  emxArray_unnamed_struct_inver_T *emxArray;\n  *pEmxArray = static_cast<emxArray_unnamed_struct_inver_T *>(malloc(sizeof\n    (emxArray_unnamed_struct_inver_T)));\n  emxArray = *pEmxArray;\n  emxArray->data = (k_robotics_manip_internal_Col_T **)NULL;\n  emxArray->numDimensions = numDimensions;\n  emxArray->size = static_cast<int32_T *>(malloc(sizeof(int32_T) * numDimensions));\n  emxArray->allocatedSize = 0;\n  emxArray->canFreeData = true;\n  for (int32_T i = 0; i < numDimensions; i++) {\n    emxArray->size[i] = 0;\n  }\n}\n\nstatic void emxInitStruct_l_robotics_manip_(l_robotics_manip_internal_Col_T\n  *pStruct)\n{\n  inverse__emxInit_unnamed_struct(&pStruct->CollisionGeometries, 2);\n}\n\nstatic void emxInitMatrix_l_robotics_manip_(l_robotics_manip_internal_Col_T\n  pMatrix[13])\n{\n  for (int32_T i = 0; i < 13; i++) {\n    emxInitStruct_l_robotics_manip_(&pMatrix[i]);\n  }\n}\n\nstatic void inverse_kinemati_emxInit_real_T(emxArray_real_T_inverse_kinem_T\n  **pEmxArray, int32_T numDimensions)\n{\n  emxArray_real_T_inverse_kinem_T *emxArray;\n  *pEmxArray = static_cast<emxArray_real_T_inverse_kinem_T *>(malloc(sizeof\n    (emxArray_real_T_inverse_kinem_T)));\n  emxArray = *pEmxArray;\n  emxArray->data = static_cast<real_T *>(NULL);\n  emxArray->numDimensions = numDimensions;\n  emxArray->size = static_cast<int32_T *>(malloc(sizeof(int32_T) * numDimensions));\n  emxArray->allocatedSize = 0;\n  emxArray->canFreeData = true;\n  for (inverse_kinematics_B.i_i = 0; inverse_kinematics_B.i_i < numDimensions;\n       inverse_kinematics_B.i_i++) {\n    emxArray->size[inverse_kinematics_B.i_i] = 0;\n  }\n}\n\nstatic void emxInitStruct_c_rigidBodyJoint(c_rigidBodyJoint_inverse_kine_T\n  *pStruct)\n{\n  inverse_kinemati_emxInit_char_T(&pStruct->Type, 2);\n  inverse_kinemati_emxInit_real_T(&pStruct->MotionSubspace, 2);\n  inverse_kinemati_emxInit_char_T(&pStruct->NameInternal, 2);\n  inverse_kinemati_emxInit_real_T(&pStruct->PositionLimitsInternal, 2);\n  inverse_kinemati_emxInit_real_T(&pStruct->HomePositionInternal, 1);\n}\n\nstatic void emxInitMatrix_c_rigidBodyJoint(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[13])\n{\n  for (int32_T i = 0; i < 13; i++) {\n    emxInitStruct_c_rigidBodyJoint(&pMatrix[i]);\n  }\n}\n\nstatic void emxInitMatrix_t_robotics_manip_(t_robotics_manip_internal_Rig_T\n  pMatrix[12])\n{\n  for (int32_T i = 0; i < 12; i++) {\n    emxInitStruct_t_robotics_manip_(&pMatrix[i]);\n  }\n}\n\nstatic void emxInitStruct_u_robotics_manip_(u_robotics_manip_internal_Rig_T\n  *pStruct)\n{\n  emxInitStruct_t_robotics_manip_(&pStruct->Base);\n  emxInitMatrix_l_robotics_manip_(pStruct->_pobj0);\n  emxInitMatrix_c_rigidBodyJoint(pStruct->_pobj1);\n  emxInitMatrix_t_robotics_manip_(pStruct->_pobj2);\n}\n\nstatic void emxInitStruct_f_robotics_manip_(f_robotics_manip_internal_IKE_T\n  *pStruct)\n{\n  inverse_kinemati_emxInit_real_T(&pStruct->Limits, 2);\n  inverse_kinemati_emxInit_char_T(&pStruct->BodyName, 2);\n  inverse_kinemati_emxInit_real_T(&pStruct->ErrTemp, 1);\n  inverse_kinemati_emxInit_real_T(&pStruct->GradTemp, 1);\n}\n\nstatic void emxInitMatrix_c_rigidBodyJoint1(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[12])\n{\n  for (int32_T i = 0; i < 12; i++) {\n    emxInitStruct_c_rigidBodyJoint(&pMatrix[i]);\n  }\n}\n\nstatic void emxInitMatrix_t_robotics_mani_g(t_robotics_manip_internal_Rig_T\n  pMatrix[6])\n{\n  for (int32_T i = 0; i < 6; i++) {\n    emxInitStruct_t_robotics_manip_(&pMatrix[i]);\n  }\n}\n\nstatic void emxInitMatrix_l_robotics_mani_g(l_robotics_manip_internal_Col_T\n  pMatrix[7])\n{\n  for (int32_T i = 0; i < 7; i++) {\n    emxInitStruct_l_robotics_manip_(&pMatrix[i]);\n  }\n}\n\nstatic void emxInitMatrix_c_rigidBodyJoint2(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[7])\n{\n  for (int32_T i = 0; i < 7; i++) {\n    emxInitStruct_c_rigidBodyJoint(&pMatrix[i]);\n  }\n}\n\nstatic void emxInitStruct_v_robotics_manip_(v_robotics_manip_internal_Rig_T\n  *pStruct)\n{\n  emxInitStruct_t_robotics_manip_(&pStruct->Base);\n  emxInitMatrix_t_robotics_mani_g(pStruct->_pobj0);\n  emxInitMatrix_l_robotics_mani_g(pStruct->_pobj1);\n  emxInitMatrix_c_rigidBodyJoint2(pStruct->_pobj2);\n}\n\nstatic void emxInitStruct_b_inverseKinemati(b_inverseKinematics_inverse_k_T\n  *pStruct)\n{\n  inverse_kinemati_emxInit_real_T(&pStruct->Limits, 2);\n  emxInitStruct_f_robotics_manip_(&pStruct->_pobj0);\n  emxInitMatrix_c_rigidBodyJoint1(pStruct->_pobj1);\n  emxInitMatrix_t_robotics_mani_g(pStruct->_pobj2);\n  emxInitMatrix_l_robotics_manip_(pStruct->_pobj3);\n  emxInitStruct_v_robotics_manip_(&pStruct->_pobj4);\n}\n\nstatic void emxInitStruct_robotics_slmanip_(robotics_slmanip_internal_blo_T\n  *pStruct)\n{\n  emxInitStruct_u_robotics_manip_(&pStruct->TreeInternal);\n  emxInitStruct_b_inverseKinemati(&pStruct->IKInternal);\n}\n\nstatic void invers_emxEnsureCapacity_char_T(emxArray_char_T_inverse_kinem_T\n  *emxArray, int32_T oldNumel)\n{\n  void *newData;\n  if (oldNumel < 0) {\n    oldNumel = 0;\n  }\n\n  inverse_kinematics_B.newNumel_p = 1;\n  for (inverse_kinematics_B.i_px = 0; inverse_kinematics_B.i_px <\n       emxArray->numDimensions; inverse_kinematics_B.i_px++) {\n    inverse_kinematics_B.newNumel_p *= emxArray->size[inverse_kinematics_B.i_px];\n  }\n\n  if (inverse_kinematics_B.newNumel_p > emxArray->allocatedSize) {\n    inverse_kinematics_B.i_px = emxArray->allocatedSize;\n    if (inverse_kinematics_B.i_px < 16) {\n      inverse_kinematics_B.i_px = 16;\n    }\n\n    while (inverse_kinematics_B.i_px < inverse_kinematics_B.newNumel_p) {\n      if (inverse_kinematics_B.i_px > 1073741823) {\n        inverse_kinematics_B.i_px = MAX_int32_T;\n      } else {\n        inverse_kinematics_B.i_px <<= 1;\n      }\n    }\n\n    newData = calloc(static_cast<uint32_T>(inverse_kinematics_B.i_px), sizeof\n                     (char_T));\n    if (emxArray->data != NULL) {\n      memcpy(newData, emxArray->data, sizeof(char_T) * oldNumel);\n      if (emxArray->canFreeData) {\n        free(emxArray->data);\n      }\n    }\n\n    emxArray->data = static_cast<char_T *>(newData);\n    emxArray->allocatedSize = inverse_kinematics_B.i_px;\n    emxArray->canFreeData = true;\n  }\n}\n\nstatic void inverse_kinemati_emxFree_char_T(emxArray_char_T_inverse_kinem_T\n  **pEmxArray)\n{\n  if (*pEmxArray != static_cast<emxArray_char_T_inverse_kinem_T *>(NULL)) {\n    if (((*pEmxArray)->data != static_cast<char_T *>(NULL)) && (*pEmxArray)\n        ->canFreeData) {\n      free((*pEmxArray)->data);\n    }\n\n    free((*pEmxArray)->size);\n    free(*pEmxArray);\n    *pEmxArray = static_cast<emxArray_char_T_inverse_kinem_T *>(NULL);\n  }\n}\n\nstatic void invers_emxEnsureCapacity_real_T(emxArray_real_T_inverse_kinem_T\n  *emxArray, int32_T oldNumel)\n{\n  void *newData;\n  if (oldNumel < 0) {\n    oldNumel = 0;\n  }\n\n  inverse_kinematics_B.newNumel = 1;\n  for (inverse_kinematics_B.i_p = 0; inverse_kinematics_B.i_p <\n       emxArray->numDimensions; inverse_kinematics_B.i_p++) {\n    inverse_kinematics_B.newNumel *= emxArray->size[inverse_kinematics_B.i_p];\n  }\n\n  if (inverse_kinematics_B.newNumel > emxArray->allocatedSize) {\n    inverse_kinematics_B.i_p = emxArray->allocatedSize;\n    if (inverse_kinematics_B.i_p < 16) {\n      inverse_kinematics_B.i_p = 16;\n    }\n\n    while (inverse_kinematics_B.i_p < inverse_kinematics_B.newNumel) {\n      if (inverse_kinematics_B.i_p > 1073741823) {\n        inverse_kinematics_B.i_p = MAX_int32_T;\n      } else {\n        inverse_kinematics_B.i_p <<= 1;\n      }\n    }\n\n    newData = calloc(static_cast<uint32_T>(inverse_kinematics_B.i_p), sizeof\n                     (real_T));\n    if (emxArray->data != NULL) {\n      memcpy(newData, emxArray->data, sizeof(real_T) * oldNumel);\n      if (emxArray->canFreeData) {\n        free(emxArray->data);\n      }\n    }\n\n    emxArray->data = static_cast<real_T *>(newData);\n    emxArray->allocatedSize = inverse_kinematics_B.i_p;\n    emxArray->canFreeData = true;\n  }\n}\n\nstatic void emxEnsureCapacity_unnamed_struc(emxArray_unnamed_struct_inver_T\n  *emxArray, int32_T oldNumel)\n{\n  void *newData;\n  if (oldNumel < 0) {\n    oldNumel = 0;\n  }\n\n  inverse_kinematics_B.newNumel_pb = 1;\n  for (inverse_kinematics_B.i_m = 0; inverse_kinematics_B.i_m <\n       emxArray->numDimensions; inverse_kinematics_B.i_m++) {\n    inverse_kinematics_B.newNumel_pb *= emxArray->size[inverse_kinematics_B.i_m];\n  }\n\n  if (inverse_kinematics_B.newNumel_pb > emxArray->allocatedSize) {\n    inverse_kinematics_B.i_m = emxArray->allocatedSize;\n    if (inverse_kinematics_B.i_m < 16) {\n      inverse_kinematics_B.i_m = 16;\n    }\n\n    while (inverse_kinematics_B.i_m < inverse_kinematics_B.newNumel_pb) {\n      if (inverse_kinematics_B.i_m > 1073741823) {\n        inverse_kinematics_B.i_m = MAX_int32_T;\n      } else {\n        inverse_kinematics_B.i_m <<= 1;\n      }\n    }\n\n    newData = calloc(static_cast<uint32_T>(inverse_kinematics_B.i_m), sizeof\n                     (k_robotics_manip_internal_Col_T *));\n    if (emxArray->data != NULL) {\n      memcpy(newData, (void *)emxArray->data, sizeof\n             (k_robotics_manip_internal_Col_T *) * oldNumel);\n      if (emxArray->canFreeData) {\n        free((void *)emxArray->data);\n      }\n    }\n\n    emxArray->data = (k_robotics_manip_internal_Col_T **)newData;\n    emxArray->allocatedSize = inverse_kinematics_B.i_m;\n    emxArray->canFreeData = true;\n  }\n}\n\nstatic void inverse__emxFree_unnamed_struct(emxArray_unnamed_struct_inver_T\n  **pEmxArray)\n{\n  if (*pEmxArray != static_cast<emxArray_unnamed_struct_inver_T *>(NULL)) {\n    if (((*pEmxArray)->data != (k_robotics_manip_internal_Col_T **)NULL) &&\n        (*pEmxArray)->canFreeData) {\n      free((void *)(*pEmxArray)->data);\n    }\n\n    free((*pEmxArray)->size);\n    free(*pEmxArray);\n    *pEmxArray = static_cast<emxArray_unnamed_struct_inver_T *>(NULL);\n  }\n}\n\nstatic l_robotics_manip_internal_Col_T *inver_CollisionSet_CollisionSet\n  (l_robotics_manip_internal_Col_T *obj, real_T maxElements)\n{\n  emxArray_unnamed_struct_inver_T *e;\n  k_robotics_manip_internal_Col_T *obj_0;\n  l_robotics_manip_internal_Col_T *b_obj;\n  inverse__emxInit_unnamed_struct(&e, 2);\n  obj->Size = 0.0;\n  b_obj = obj;\n  obj->MaxElements = maxElements;\n  inverse_kinematics_B.b_i_a = e->size[0] * e->size[1];\n  e->size[1] = static_cast<int32_T>(obj->MaxElements);\n  emxEnsureCapacity_unnamed_struc(e, inverse_kinematics_B.b_i_a);\n  inverse_kinematics_B.b_i_a = obj->CollisionGeometries->size[0] *\n    obj->CollisionGeometries->size[1];\n  obj->CollisionGeometries->size[0] = 1;\n  obj->CollisionGeometries->size[1] = e->size[1];\n  emxEnsureCapacity_unnamed_struc(obj->CollisionGeometries,\n    inverse_kinematics_B.b_i_a);\n  inverse_kinematics_B.defaultCollisionObj_GeometryInt = 0;\n  obj_0 = &obj->_pobj0;\n  obj->_pobj0.CollisionPrimitive =\n    inverse_kinematics_B.defaultCollisionObj_GeometryInt;\n  obj->_pobj0.matlabCodegenIsDeleted = false;\n  inverse_kinematics_B.c = obj->MaxElements;\n  inverse_kinematics_B.d_d = static_cast<int32_T>(inverse_kinematics_B.c) - 1;\n  inverse__emxFree_unnamed_struct(&e);\n  for (inverse_kinematics_B.b_i_a = 0; inverse_kinematics_B.b_i_a <=\n       inverse_kinematics_B.d_d; inverse_kinematics_B.b_i_a++) {\n    obj->CollisionGeometries->data[inverse_kinematics_B.b_i_a] = obj_0;\n  }\n\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *inverse_kin_RigidBody_RigidBody\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T b_I[9];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[10] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '1' };\n\n  static const int8_T tmp_1[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_2[14] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '1', '_', 'j', 'n', 't' };\n\n  static const char_T tmp_3[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_4[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_5[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 10;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 10; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 14;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 14; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_2[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_3[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_4[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_5[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  obj->Index = -1.0;\n  obj->ParentIndex = -1.0;\n  obj->MassInternal = 1.0;\n  obj->CenterOfMassInternal[0] = 0.0;\n  obj->CenterOfMassInternal[1] = 0.0;\n  obj->CenterOfMassInternal[2] = 0.0;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    b_I[b_kstr] = 0;\n  }\n\n  b_I[0] = 1;\n  b_I[4] = 1;\n  b_I[8] = 1;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = b_I[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    msubspace_data[b_kstr] = 0;\n  }\n\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    msubspace_data[b_kstr + 6 * b_kstr] = 1;\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *inverse_k_RigidBody_RigidBody_g\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T b_I[9];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[10] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '2' };\n\n  static const int8_T tmp_1[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_2[14] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '2', '_', 'j', 'n', 't' };\n\n  static const char_T tmp_3[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_4[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_5[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 10;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 10; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 14;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 14; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_2[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_3[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_4[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_5[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  obj->Index = -1.0;\n  obj->ParentIndex = -1.0;\n  obj->MassInternal = 1.0;\n  obj->CenterOfMassInternal[0] = 0.0;\n  obj->CenterOfMassInternal[1] = 0.0;\n  obj->CenterOfMassInternal[2] = 0.0;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    b_I[b_kstr] = 0;\n  }\n\n  b_I[0] = 1;\n  b_I[4] = 1;\n  b_I[8] = 1;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = b_I[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    msubspace_data[b_kstr] = 0;\n  }\n\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    msubspace_data[b_kstr + 6 * b_kstr] = 1;\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *inverse__RigidBody_RigidBody_ga\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T b_I[9];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[10] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '3' };\n\n  static const int8_T tmp_1[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_2[14] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '3', '_', 'j', 'n', 't' };\n\n  static const char_T tmp_3[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_4[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_5[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 10;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 10; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 14;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 14; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_2[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_3[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_4[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_5[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  obj->Index = -1.0;\n  obj->ParentIndex = -1.0;\n  obj->MassInternal = 1.0;\n  obj->CenterOfMassInternal[0] = 0.0;\n  obj->CenterOfMassInternal[1] = 0.0;\n  obj->CenterOfMassInternal[2] = 0.0;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    b_I[b_kstr] = 0;\n  }\n\n  b_I[0] = 1;\n  b_I[4] = 1;\n  b_I[8] = 1;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = b_I[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    msubspace_data[b_kstr] = 0;\n  }\n\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    msubspace_data[b_kstr + 6 * b_kstr] = 1;\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *inverse_RigidBody_RigidBody_gaq\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T b_I[9];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[10] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '4' };\n\n  static const int8_T tmp_1[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_2[14] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '4', '_', 'j', 'n', 't' };\n\n  static const char_T tmp_3[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_4[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_5[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 10;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 10; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 14;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 14; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_2[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_3[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_4[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_5[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  obj->Index = -1.0;\n  obj->ParentIndex = -1.0;\n  obj->MassInternal = 1.0;\n  obj->CenterOfMassInternal[0] = 0.0;\n  obj->CenterOfMassInternal[1] = 0.0;\n  obj->CenterOfMassInternal[2] = 0.0;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    b_I[b_kstr] = 0;\n  }\n\n  b_I[0] = 1;\n  b_I[4] = 1;\n  b_I[8] = 1;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = b_I[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    msubspace_data[b_kstr] = 0;\n  }\n\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    msubspace_data[b_kstr + 6 * b_kstr] = 1;\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *invers_RigidBody_RigidBody_gaqy\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T b_I[9];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[10] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '5' };\n\n  static const int8_T tmp_1[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_2[14] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '5', '_', 'j', 'n', 't' };\n\n  static const char_T tmp_3[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_4[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_5[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 10;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 10; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_1[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 14;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 14; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_2[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_3[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_4[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_5[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  obj->Index = -1.0;\n  obj->ParentIndex = -1.0;\n  obj->MassInternal = 1.0;\n  obj->CenterOfMassInternal[0] = 0.0;\n  obj->CenterOfMassInternal[1] = 0.0;\n  obj->CenterOfMassInternal[2] = 0.0;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    b_I[b_kstr] = 0;\n  }\n\n  b_I[0] = 1;\n  b_I[4] = 1;\n  b_I[8] = 1;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = b_I[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    msubspace_data[b_kstr] = 0;\n  }\n\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    msubspace_data[b_kstr + 6 * b_kstr] = 1;\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *inver_RigidBody_RigidBody_gaqyy\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  static const char_T tmp[10] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '6' };\n\n  static const int8_T tmp_0[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_1[14] = { 'd', 'u', 'm', 'm', 'y', 'b', 'o', 'd', 'y',\n    '6', '_', 'j', 'n', 't' };\n\n  static const char_T tmp_2[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_3[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_4[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  b_obj = obj;\n  inverse_kinematics_B.i6 = obj->NameInternal->size[0] * obj->NameInternal->\n    size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 10;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, inverse_kinematics_B.i6);\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 10;\n       inverse_kinematics_B.b_kstr_ch++) {\n    obj->NameInternal->data[inverse_kinematics_B.b_kstr_ch] =\n      tmp[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  iobj_1->InTree = false;\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 16;\n       inverse_kinematics_B.b_kstr_ch++) {\n    iobj_1->JointToParentTransform[inverse_kinematics_B.b_kstr_ch] =\n      tmp_0[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 16;\n       inverse_kinematics_B.b_kstr_ch++) {\n    iobj_1->ChildToJointTransform[inverse_kinematics_B.b_kstr_ch] =\n      tmp_0[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  inverse_kinematics_B.i6 = iobj_1->NameInternal->size[0] * iobj_1->\n    NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 14;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, inverse_kinematics_B.i6);\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 14;\n       inverse_kinematics_B.b_kstr_ch++) {\n    iobj_1->NameInternal->data[inverse_kinematics_B.b_kstr_ch] =\n      tmp_1[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  inverse_kinematics_B.i6 = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, inverse_kinematics_B.i6);\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 5;\n       inverse_kinematics_B.b_kstr_ch++) {\n    iobj_1->Type->data[inverse_kinematics_B.b_kstr_ch] =\n      tmp_2[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  inverse_kinematics_B.i6 = switch_expression->size[0] * switch_expression->\n    size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, inverse_kinematics_B.i6);\n  inverse_kinematics_B.loop_ub_a = iobj_1->Type->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch <=\n       inverse_kinematics_B.loop_ub_a; inverse_kinematics_B.b_kstr_ch++) {\n    inverse_kinematics_B.i6 = inverse_kinematics_B.b_kstr_ch;\n    switch_expression->data[inverse_kinematics_B.i6] = iobj_1->Type->\n      data[inverse_kinematics_B.i6];\n  }\n\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 8;\n       inverse_kinematics_B.b_kstr_ch++) {\n    inverse_kinematics_B.b_o[inverse_kinematics_B.b_kstr_ch] =\n      tmp_3[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  inverse_kinematics_B.b_bool_c = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    inverse_kinematics_B.b_kstr_ch = 1;\n    do {\n      exitg1 = 0;\n      if (inverse_kinematics_B.b_kstr_ch - 1 < 8) {\n        if (switch_expression->data[inverse_kinematics_B.b_kstr_ch - 1] !=\n            inverse_kinematics_B.b_o[inverse_kinematics_B.b_kstr_ch - 1]) {\n          exitg1 = 1;\n        } else {\n          inverse_kinematics_B.b_kstr_ch++;\n        }\n      } else {\n        inverse_kinematics_B.b_bool_c = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (inverse_kinematics_B.b_bool_c) {\n    inverse_kinematics_B.b_kstr_ch = 0;\n  } else {\n    for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 9;\n         inverse_kinematics_B.b_kstr_ch++) {\n      inverse_kinematics_B.b_bj[inverse_kinematics_B.b_kstr_ch] =\n        tmp_4[inverse_kinematics_B.b_kstr_ch];\n    }\n\n    inverse_kinematics_B.b_bool_c = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      inverse_kinematics_B.b_kstr_ch = 1;\n      do {\n        exitg1 = 0;\n        if (inverse_kinematics_B.b_kstr_ch - 1 < 9) {\n          if (switch_expression->data[inverse_kinematics_B.b_kstr_ch - 1] !=\n              inverse_kinematics_B.b_bj[inverse_kinematics_B.b_kstr_ch - 1]) {\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.b_kstr_ch++;\n          }\n        } else {\n          inverse_kinematics_B.b_bool_c = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (inverse_kinematics_B.b_bool_c) {\n      inverse_kinematics_B.b_kstr_ch = 1;\n    } else {\n      inverse_kinematics_B.b_kstr_ch = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (inverse_kinematics_B.b_kstr_ch) {\n   case 0:\n    inverse_kinematics_B.iv4[0] = 0;\n    inverse_kinematics_B.iv4[1] = 0;\n    inverse_kinematics_B.iv4[2] = 1;\n    inverse_kinematics_B.iv4[3] = 0;\n    inverse_kinematics_B.iv4[4] = 0;\n    inverse_kinematics_B.iv4[5] = 0;\n    for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 6;\n         inverse_kinematics_B.b_kstr_ch++) {\n      inverse_kinematics_B.msubspace_data_j[inverse_kinematics_B.b_kstr_ch] =\n        inverse_kinematics_B.iv4[inverse_kinematics_B.b_kstr_ch];\n    }\n\n    inverse_kinematics_B.poslim_data_f[0] = -3.1415926535897931;\n    inverse_kinematics_B.poslim_data_f[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    inverse_kinematics_B.iv4[0] = 0;\n    inverse_kinematics_B.iv4[1] = 0;\n    inverse_kinematics_B.iv4[2] = 0;\n    inverse_kinematics_B.iv4[3] = 0;\n    inverse_kinematics_B.iv4[4] = 0;\n    inverse_kinematics_B.iv4[5] = 1;\n    for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 6;\n         inverse_kinematics_B.b_kstr_ch++) {\n      inverse_kinematics_B.msubspace_data_j[inverse_kinematics_B.b_kstr_ch] =\n        inverse_kinematics_B.iv4[inverse_kinematics_B.b_kstr_ch];\n    }\n\n    inverse_kinematics_B.poslim_data_f[0] = -0.5;\n    inverse_kinematics_B.poslim_data_f[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 6;\n         inverse_kinematics_B.b_kstr_ch++) {\n      inverse_kinematics_B.msubspace_data_j[inverse_kinematics_B.b_kstr_ch] = 0;\n    }\n\n    inverse_kinematics_B.poslim_data_f[0] = 0.0;\n    inverse_kinematics_B.poslim_data_f[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  inverse_kinematics_B.i6 = iobj_1->MotionSubspace->size[0] *\n    iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace,\n    inverse_kinematics_B.i6);\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 6;\n       inverse_kinematics_B.b_kstr_ch++) {\n    iobj_1->MotionSubspace->data[inverse_kinematics_B.b_kstr_ch] =\n      inverse_kinematics_B.msubspace_data_j[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  inverse_kinematics_B.i6 = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal,\n    inverse_kinematics_B.i6);\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 2;\n       inverse_kinematics_B.b_kstr_ch++) {\n    iobj_1->PositionLimitsInternal->data[inverse_kinematics_B.b_kstr_ch] =\n      inverse_kinematics_B.poslim_data_f[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  inverse_kinematics_B.i6 = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal,\n    inverse_kinematics_B.i6);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  obj->Index = -1.0;\n  obj->ParentIndex = -1.0;\n  obj->MassInternal = 1.0;\n  obj->CenterOfMassInternal[0] = 0.0;\n  obj->CenterOfMassInternal[1] = 0.0;\n  obj->CenterOfMassInternal[2] = 0.0;\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 9;\n       inverse_kinematics_B.b_kstr_ch++) {\n    inverse_kinematics_B.b_I_e[inverse_kinematics_B.b_kstr_ch] = 0;\n  }\n\n  inverse_kinematics_B.b_I_e[0] = 1;\n  inverse_kinematics_B.b_I_e[4] = 1;\n  inverse_kinematics_B.b_I_e[8] = 1;\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 9;\n       inverse_kinematics_B.b_kstr_ch++) {\n    obj->InertiaInternal[inverse_kinematics_B.b_kstr_ch] =\n      inverse_kinematics_B.b_I_e[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 36;\n       inverse_kinematics_B.b_kstr_ch++) {\n    inverse_kinematics_B.msubspace_data_j[inverse_kinematics_B.b_kstr_ch] = 0;\n  }\n\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 6;\n       inverse_kinematics_B.b_kstr_ch++) {\n    inverse_kinematics_B.msubspace_data_j[inverse_kinematics_B.b_kstr_ch + 6 *\n      inverse_kinematics_B.b_kstr_ch] = 1;\n  }\n\n  for (inverse_kinematics_B.b_kstr_ch = 0; inverse_kinematics_B.b_kstr_ch < 36;\n       inverse_kinematics_B.b_kstr_ch++) {\n    obj->SpatialInertia[inverse_kinematics_B.b_kstr_ch] =\n      inverse_kinematics_B.msubspace_data_j[inverse_kinematics_B.b_kstr_ch];\n  }\n\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *inve_RigidBody_RigidBody_gaqyy1\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[5] = { 'B', 'o', 'd', 'y', '3' };\n\n  static const real_T tmp_1[9] = { 0.004214759646674851, -3.0676517226065562E-8,\n    2.1821908339314224E-8, -3.0676517226065562E-8, 0.00037231560073204209,\n    -0.00079485808764448288, 2.1821908339314224E-8, -0.00079485808764448288,\n    0.00396761410886888 };\n\n  static const real_T tmp_2[36] = { 0.004214759646674851, -3.0676517226065562E-8,\n    2.1821908339314224E-8, 0.0, 0.0065367341731804784, -0.029400227748421107,\n    -3.0676517226065562E-8, 0.00037231560073204209, -0.00079485808764448288,\n    -0.0065367341731804784, 0.0, 1.0391384923362643E-6, 2.1821908339314224E-8,\n    -0.00079485808764448288, 0.00396761410886888, 0.029400227748421107,\n    -1.0391384923362643E-6, 0.0, 0.0, -0.0065367341731804784,\n    0.029400227748421107, 0.30177243138, 0.0, 0.0, 0.0065367341731804784, 0.0,\n    -1.0391384923362643E-6, 0.0, 0.30177243138, 0.0, -0.029400227748421107,\n    1.0391384923362643E-6, 0.0, 0.0, 0.0, 0.30177243138 };\n\n  static const int8_T tmp_3[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_4[6] = { 'J', 'o', 'i', 'n', 't', '3' };\n\n  static const char_T tmp_5[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_6[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  static const real_T tmp_7[16] = { 6.123233995736766E-17, -1.0, -0.0, 0.0, -1.0,\n    -6.123233995736766E-17, 1.2246467991473532E-16, 0.0, -1.2246467991473532E-16,\n    -7.498798913309288E-33, -1.0, 0.0, -3.5971225173156E-17, 0.16,\n    -0.042000000000000058, 1.0 };\n\n  static const real_T tmp_8[16] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 };\n\n  static const real_T tmp_9[36] = { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  obj->ParentIndex = 2.0;\n  obj->MassInternal = 0.30177243138;\n  obj->CenterOfMassInternal[0] = -3.4434507074894226E-6;\n  obj->CenterOfMassInternal[1] = -0.097425161118841724;\n  obj->CenterOfMassInternal[2] = -0.021661137643647927;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = tmp_1[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = tmp_2[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_3[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_3[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 6;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_4[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 8;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_5[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_5[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_6[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    obj->JointInternal->JointToParentTransform[b_kstr] = tmp_7[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    obj->JointInternal->ChildToJointTransform[b_kstr] = tmp_8[b_kstr];\n  }\n\n  b_kstr = obj->JointInternal->MotionSubspace->size[0] * obj->\n    JointInternal->MotionSubspace->size[1];\n  obj->JointInternal->MotionSubspace->size[0] = 6;\n  obj->JointInternal->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    obj->JointInternal->MotionSubspace->data[b_kstr] = tmp_9[b_kstr];\n  }\n\n  obj->JointInternal->InTree = true;\n  b_kstr = obj->JointInternal->PositionLimitsInternal->size[0] *\n    obj->JointInternal->PositionLimitsInternal->size[1];\n  obj->JointInternal->PositionLimitsInternal->size[0] = 1;\n  obj->JointInternal->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->PositionLimitsInternal,\n    b_kstr);\n  obj->JointInternal->PositionLimitsInternal->data[0] = -1.5707963267948966;\n  obj->JointInternal->PositionLimitsInternal->data[obj->\n    JointInternal->PositionLimitsInternal->size[0]] = 0.3490658503988659;\n  obj->JointInternal->JointAxisInternal[0] = 0.0;\n  obj->JointInternal->JointAxisInternal[1] = 0.0;\n  obj->JointInternal->JointAxisInternal[2] = 1.0;\n  b_kstr = obj->JointInternal->HomePositionInternal->size[0];\n  obj->JointInternal->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->HomePositionInternal,\n    b_kstr);\n  obj->JointInternal->HomePositionInternal->data[0] = -2.2999999516049027E-8;\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *inv_RigidBody_RigidBody_gaqyy1n\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[5] = { 'B', 'o', 'd', 'y', '4' };\n\n  static const real_T tmp_1[9] = { 0.0025850396977390622, 8.0307310648899469E-5,\n    1.1770697894580795E-5, 8.0307310648899469E-5, 0.00015209383720762718,\n    -0.00023074969363202281, 1.1770697894580795E-5, -0.00023074969363202281,\n    0.0025807399030087002 };\n\n  static const real_T tmp_2[36] = { 0.0025850396977390622, 8.0307310648899469E-5,\n    1.1770697894580795E-5, 0.0, -0.0029407217431669705, 0.021997815546504242,\n    8.0307310648899469E-5, 0.00015209383720762718, -0.00023074969363202281,\n    0.0029407217431669705, 0.0, 0.0011226397295655513, 1.1770697894580795E-5,\n    -0.00023074969363202281, 0.0025807399030087002, -0.021997815546504242,\n    -0.0011226397295655513, 0.0, 0.0, 0.0029407217431669705,\n    -0.021997815546504242, 0.24806822598, 0.0, 0.0, -0.0029407217431669705, 0.0,\n    -0.0011226397295655513, 0.0, 0.24806822598, 0.0, 0.021997815546504242,\n    0.0011226397295655513, 0.0, 0.0, 0.0, 0.24806822598 };\n\n  static const int8_T tmp_3[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_4[6] = { 'J', 'o', 'i', 'n', 't', '4' };\n\n  static const char_T tmp_5[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_6[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  static const real_T tmp_7[16] = { 1.0, 0.0, -0.0, 0.0, 0.0, -1.0,\n    1.2246467991473532E-16, 0.0, 0.0, -1.2246467991473532E-16, -1.0, 0.0,\n    1.7725858487190743E-17, -0.15500000000000003, -0.014125000000000037, 1.0 };\n\n  static const real_T tmp_8[16] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 };\n\n  static const real_T tmp_9[36] = { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  obj->ParentIndex = 3.0;\n  obj->MassInternal = 0.24806822598;\n  obj->CenterOfMassInternal[0] = -0.0045255281087714224;\n  obj->CenterOfMassInternal[1] = 0.088676473819253948;\n  obj->CenterOfMassInternal[2] = 0.011854487738401694;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = tmp_1[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = tmp_2[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_3[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_3[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 6;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_4[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 8;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_5[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_5[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_6[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    obj->JointInternal->JointToParentTransform[b_kstr] = tmp_7[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    obj->JointInternal->ChildToJointTransform[b_kstr] = tmp_8[b_kstr];\n  }\n\n  b_kstr = obj->JointInternal->MotionSubspace->size[0] * obj->\n    JointInternal->MotionSubspace->size[1];\n  obj->JointInternal->MotionSubspace->size[0] = 6;\n  obj->JointInternal->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    obj->JointInternal->MotionSubspace->data[b_kstr] = tmp_9[b_kstr];\n  }\n\n  obj->JointInternal->InTree = true;\n  b_kstr = obj->JointInternal->PositionLimitsInternal->size[0] *\n    obj->JointInternal->PositionLimitsInternal->size[1];\n  obj->JointInternal->PositionLimitsInternal->size[0] = 1;\n  obj->JointInternal->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->PositionLimitsInternal,\n    b_kstr);\n  obj->JointInternal->PositionLimitsInternal->data[0] = -1.0471975511965976;\n  obj->JointInternal->PositionLimitsInternal->data[obj->\n    JointInternal->PositionLimitsInternal->size[0]] = 0.0;\n  obj->JointInternal->JointAxisInternal[0] = 0.0;\n  obj->JointInternal->JointAxisInternal[1] = 0.0;\n  obj->JointInternal->JointAxisInternal[2] = 1.0;\n  b_kstr = obj->JointInternal->HomePositionInternal->size[0];\n  obj->JointInternal->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->HomePositionInternal,\n    b_kstr);\n  obj->JointInternal->HomePositionInternal->data[0] = -0.52359877559829882;\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *in_RigidBody_RigidBody_gaqyy1no\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[5] = { 'B', 'o', 'd', 'y', '5' };\n\n  static const real_T tmp_1[36] = { 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, 0.0, 0.0,\n    -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, -0.0, 0.0, 0.0, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n\n  static const int8_T tmp_2[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_3[6] = { 'J', 'o', 'i', 'n', 't', '5' };\n\n  static const char_T tmp_4[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_5[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_6[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  static const real_T tmp_7[16] = { 6.123233995736766E-17, 1.0, -0.0, 0.0, 1.0,\n    -6.123233995736766E-17, 1.2246467991473532E-16, 0.0, 1.2246467991473532E-16,\n    -7.498798913309288E-33, -1.0, 0.0, -0.0011000000000000749,\n    0.23624000000000006, 0.010499999999999877, 1.0 };\n\n  static const real_T tmp_8[16] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  obj->ParentIndex = 4.0;\n  obj->MassInternal = 0.0;\n  obj->CenterOfMassInternal[0] = -0.0;\n  obj->CenterOfMassInternal[1] = -0.0;\n  obj->CenterOfMassInternal[2] = -0.0;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = 0.0;\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = tmp_1[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_2[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_2[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 6;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_3[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_4[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_5[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_6[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    obj->JointInternal->JointToParentTransform[b_kstr] = tmp_7[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    obj->JointInternal->ChildToJointTransform[b_kstr] = tmp_8[b_kstr];\n  }\n\n  b_kstr = obj->JointInternal->MotionSubspace->size[0] * obj->\n    JointInternal->MotionSubspace->size[1];\n  obj->JointInternal->MotionSubspace->size[0] = 6;\n  obj->JointInternal->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    obj->JointInternal->MotionSubspace->data[b_kstr] = 0.0;\n  }\n\n  obj->JointInternal->InTree = true;\n  b_kstr = obj->JointInternal->PositionLimitsInternal->size[0] *\n    obj->JointInternal->PositionLimitsInternal->size[1];\n  obj->JointInternal->PositionLimitsInternal->size[0] = 1;\n  obj->JointInternal->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->PositionLimitsInternal,\n    b_kstr);\n  obj->JointInternal->PositionLimitsInternal->data[0] = 0.0;\n  obj->JointInternal->PositionLimitsInternal->data[obj->\n    JointInternal->PositionLimitsInternal->size[0]] = 0.0;\n  obj->JointInternal->JointAxisInternal[0] = 0.0;\n  obj->JointInternal->JointAxisInternal[1] = 0.0;\n  obj->JointInternal->JointAxisInternal[2] = 0.0;\n  b_kstr = obj->JointInternal->HomePositionInternal->size[0];\n  obj->JointInternal->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->HomePositionInternal,\n    b_kstr);\n  obj->JointInternal->HomePositionInternal->data[0] = 0.0;\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic t_robotics_manip_internal_Rig_T *i_RigidBody_RigidBody_gaqyy1no5\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1)\n{\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  t_robotics_manip_internal_Rig_T *b_obj;\n  real_T poslim_data[12];\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b_0[9];\n  char_T b[8];\n  int8_T msubspace_data[36];\n  int8_T tmp[6];\n  boolean_T b_bool;\n  static const char_T tmp_0[5] = { 'B', 'o', 'd', 'y', '6' };\n\n  static const real_T tmp_1[36] = { 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, 0.0, 0.0,\n    -0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.0, 0.0, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, -0.0, 0.0, 0.0, 0.0, -0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n\n  static const int8_T tmp_2[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_3[6] = { 'J', 'o', 'i', 'n', 't', '6' };\n\n  static const char_T tmp_4[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_5[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_6[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  static const real_T tmp_7[16] = { 2.1073424178067666E-8, 0.0,\n    0.99999999999999978, 0.0, 0.99999999999999978, 2.83276944882399E-16,\n    -2.1073424178067666E-8, 0.0, -2.8327694488239893E-16, 1.0,\n    5.9696152193738883E-24, 0.0, -0.055500000000000022, 0.08049999999999996,\n    0.010499999999999971, 1.0 };\n\n  static const real_T tmp_8[16] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 };\n\n  int32_T exitg1;\n  b_obj = obj;\n  b_kstr = obj->NameInternal->size[0] * obj->NameInternal->size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    obj->NameInternal->data[b_kstr] = tmp_0[b_kstr];\n  }\n\n  obj->ParentIndex = 4.0;\n  obj->MassInternal = 0.0;\n  obj->CenterOfMassInternal[0] = -0.0;\n  obj->CenterOfMassInternal[1] = -0.0;\n  obj->CenterOfMassInternal[2] = -0.0;\n  for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n    obj->InertiaInternal[b_kstr] = 0.0;\n  }\n\n  for (b_kstr = 0; b_kstr < 36; b_kstr++) {\n    obj->SpatialInertia[b_kstr] = tmp_1[b_kstr];\n  }\n\n  iobj_1->InTree = false;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->JointToParentTransform[b_kstr] = tmp_2[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    iobj_1->ChildToJointTransform[b_kstr] = tmp_2[b_kstr];\n  }\n\n  b_kstr = iobj_1->NameInternal->size[0] * iobj_1->NameInternal->size[1];\n  iobj_1->NameInternal->size[0] = 1;\n  iobj_1->NameInternal->size[1] = 6;\n  invers_emxEnsureCapacity_char_T(iobj_1->NameInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->NameInternal->data[b_kstr] = tmp_3[b_kstr];\n  }\n\n  b_kstr = iobj_1->Type->size[0] * iobj_1->Type->size[1];\n  iobj_1->Type->size[0] = 1;\n  iobj_1->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_1->Type, b_kstr);\n  for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n    iobj_1->Type->data[b_kstr] = tmp_4[b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  b_kstr = switch_expression->size[0] * switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_1->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, b_kstr);\n  loop_ub = iobj_1->Type->size[1] - 1;\n  for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n    switch_expression->data[b_kstr] = iobj_1->Type->data[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp_5[b_kstr];\n  }\n\n  b_bool = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (switch_expression->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (b_bool) {\n    b_kstr = 0;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_6[b_kstr];\n    }\n\n    b_bool = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (switch_expression->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      b_kstr = 1;\n    } else {\n      b_kstr = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (b_kstr) {\n   case 0:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 1;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 0;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -3.1415926535897931;\n    poslim_data[1] = 3.1415926535897931;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    tmp[0] = 0;\n    tmp[1] = 0;\n    tmp[2] = 0;\n    tmp[3] = 0;\n    tmp[4] = 0;\n    tmp[5] = 1;\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = tmp[b_kstr];\n    }\n\n    poslim_data[0] = -0.5;\n    poslim_data[1] = 0.5;\n    iobj_1->VelocityNumber = 1.0;\n    iobj_1->PositionNumber = 1.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n      msubspace_data[b_kstr] = 0;\n    }\n\n    poslim_data[0] = 0.0;\n    poslim_data[1] = 0.0;\n    iobj_1->VelocityNumber = 0.0;\n    iobj_1->PositionNumber = 0.0;\n    iobj_1->JointAxisInternal[0] = 0.0;\n    iobj_1->JointAxisInternal[1] = 0.0;\n    iobj_1->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  b_kstr = iobj_1->MotionSubspace->size[0] * iobj_1->MotionSubspace->size[1];\n  iobj_1->MotionSubspace->size[0] = 6;\n  iobj_1->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    iobj_1->MotionSubspace->data[b_kstr] = msubspace_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->PositionLimitsInternal->size[0] *\n    iobj_1->PositionLimitsInternal->size[1];\n  iobj_1->PositionLimitsInternal->size[0] = 1;\n  iobj_1->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1->PositionLimitsInternal, b_kstr);\n  for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n    iobj_1->PositionLimitsInternal->data[b_kstr] = poslim_data[b_kstr];\n  }\n\n  b_kstr = iobj_1->HomePositionInternal->size[0];\n  iobj_1->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1->HomePositionInternal, b_kstr);\n  iobj_1->HomePositionInternal->data[0] = 0.0;\n  obj->JointInternal = iobj_1;\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    obj->JointInternal->JointToParentTransform[b_kstr] = tmp_7[b_kstr];\n  }\n\n  for (b_kstr = 0; b_kstr < 16; b_kstr++) {\n    obj->JointInternal->ChildToJointTransform[b_kstr] = tmp_8[b_kstr];\n  }\n\n  b_kstr = obj->JointInternal->MotionSubspace->size[0] * obj->\n    JointInternal->MotionSubspace->size[1];\n  obj->JointInternal->MotionSubspace->size[0] = 6;\n  obj->JointInternal->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->MotionSubspace, b_kstr);\n  for (b_kstr = 0; b_kstr < 6; b_kstr++) {\n    obj->JointInternal->MotionSubspace->data[b_kstr] = 0.0;\n  }\n\n  obj->JointInternal->InTree = true;\n  b_kstr = obj->JointInternal->PositionLimitsInternal->size[0] *\n    obj->JointInternal->PositionLimitsInternal->size[1];\n  obj->JointInternal->PositionLimitsInternal->size[0] = 1;\n  obj->JointInternal->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->PositionLimitsInternal,\n    b_kstr);\n  obj->JointInternal->PositionLimitsInternal->data[0] = 0.0;\n  obj->JointInternal->PositionLimitsInternal->data[obj->\n    JointInternal->PositionLimitsInternal->size[0]] = 0.0;\n  obj->JointInternal->JointAxisInternal[0] = 0.0;\n  obj->JointInternal->JointAxisInternal[1] = 0.0;\n  obj->JointInternal->JointAxisInternal[2] = 0.0;\n  b_kstr = obj->JointInternal->HomePositionInternal->size[0];\n  obj->JointInternal->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(obj->JointInternal->HomePositionInternal,\n    b_kstr);\n  obj->JointInternal->HomePositionInternal->data[0] = 0.0;\n  obj->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  return b_obj;\n}\n\nstatic c_rigidBodyJoint_inverse_kine_T *i_rigidBodyJoint_rigidBodyJoint\n  (c_rigidBodyJoint_inverse_kine_T *obj, const emxArray_char_T_inverse_kinem_T\n   *jname)\n{\n  c_rigidBodyJoint_inverse_kine_T *b_obj;\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  static const int8_T tmp[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1\n  };\n\n  static const char_T tmp_0[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_1[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_2[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  obj->InTree = false;\n  for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 16;\n       inverse_kinematics_B.b_kstr_c++) {\n    obj->JointToParentTransform[inverse_kinematics_B.b_kstr_c] =\n      tmp[inverse_kinematics_B.b_kstr_c];\n  }\n\n  for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 16;\n       inverse_kinematics_B.b_kstr_c++) {\n    obj->ChildToJointTransform[inverse_kinematics_B.b_kstr_c] =\n      tmp[inverse_kinematics_B.b_kstr_c];\n  }\n\n  b_obj = obj;\n  inverse_kinematics_B.i2 = obj->NameInternal->size[0] * obj->NameInternal->\n    size[1];\n  obj->NameInternal->size[0] = 1;\n  obj->NameInternal->size[1] = jname->size[1];\n  invers_emxEnsureCapacity_char_T(obj->NameInternal, inverse_kinematics_B.i2);\n  inverse_kinematics_B.loop_ub_k = jname->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c <=\n       inverse_kinematics_B.loop_ub_k; inverse_kinematics_B.b_kstr_c++) {\n    inverse_kinematics_B.i2 = inverse_kinematics_B.b_kstr_c;\n    obj->NameInternal->data[inverse_kinematics_B.i2] = jname->\n      data[inverse_kinematics_B.i2];\n  }\n\n  inverse_kinematics_B.i2 = obj->Type->size[0] * obj->Type->size[1];\n  obj->Type->size[0] = 1;\n  obj->Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(obj->Type, inverse_kinematics_B.i2);\n  for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 5;\n       inverse_kinematics_B.b_kstr_c++) {\n    obj->Type->data[inverse_kinematics_B.b_kstr_c] =\n      tmp_0[inverse_kinematics_B.b_kstr_c];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  inverse_kinematics_B.i2 = switch_expression->size[0] * switch_expression->\n    size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = obj->Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression, inverse_kinematics_B.i2);\n  inverse_kinematics_B.loop_ub_k = obj->Type->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c <=\n       inverse_kinematics_B.loop_ub_k; inverse_kinematics_B.b_kstr_c++) {\n    inverse_kinematics_B.i2 = inverse_kinematics_B.b_kstr_c;\n    switch_expression->data[inverse_kinematics_B.i2] = obj->Type->\n      data[inverse_kinematics_B.i2];\n  }\n\n  for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 8;\n       inverse_kinematics_B.b_kstr_c++) {\n    inverse_kinematics_B.b_ju[inverse_kinematics_B.b_kstr_c] =\n      tmp_1[inverse_kinematics_B.b_kstr_c];\n  }\n\n  inverse_kinematics_B.b_bool_a = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    inverse_kinematics_B.b_kstr_c = 1;\n    do {\n      exitg1 = 0;\n      if (inverse_kinematics_B.b_kstr_c - 1 < 8) {\n        if (switch_expression->data[inverse_kinematics_B.b_kstr_c - 1] !=\n            inverse_kinematics_B.b_ju[inverse_kinematics_B.b_kstr_c - 1]) {\n          exitg1 = 1;\n        } else {\n          inverse_kinematics_B.b_kstr_c++;\n        }\n      } else {\n        inverse_kinematics_B.b_bool_a = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (inverse_kinematics_B.b_bool_a) {\n    inverse_kinematics_B.b_kstr_c = 0;\n  } else {\n    for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 9;\n         inverse_kinematics_B.b_kstr_c++) {\n      inverse_kinematics_B.b_bn[inverse_kinematics_B.b_kstr_c] =\n        tmp_2[inverse_kinematics_B.b_kstr_c];\n    }\n\n    inverse_kinematics_B.b_bool_a = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      inverse_kinematics_B.b_kstr_c = 1;\n      do {\n        exitg1 = 0;\n        if (inverse_kinematics_B.b_kstr_c - 1 < 9) {\n          if (switch_expression->data[inverse_kinematics_B.b_kstr_c - 1] !=\n              inverse_kinematics_B.b_bn[inverse_kinematics_B.b_kstr_c - 1]) {\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.b_kstr_c++;\n          }\n        } else {\n          inverse_kinematics_B.b_bool_a = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (inverse_kinematics_B.b_bool_a) {\n      inverse_kinematics_B.b_kstr_c = 1;\n    } else {\n      inverse_kinematics_B.b_kstr_c = -1;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  switch (inverse_kinematics_B.b_kstr_c) {\n   case 0:\n    inverse_kinematics_B.iv2[0] = 0;\n    inverse_kinematics_B.iv2[1] = 0;\n    inverse_kinematics_B.iv2[2] = 1;\n    inverse_kinematics_B.iv2[3] = 0;\n    inverse_kinematics_B.iv2[4] = 0;\n    inverse_kinematics_B.iv2[5] = 0;\n    for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 6;\n         inverse_kinematics_B.b_kstr_c++) {\n      inverse_kinematics_B.msubspace_data_p[inverse_kinematics_B.b_kstr_c] =\n        inverse_kinematics_B.iv2[inverse_kinematics_B.b_kstr_c];\n    }\n\n    inverse_kinematics_B.poslim_data_p[0] = -3.1415926535897931;\n    inverse_kinematics_B.poslim_data_p[1] = 3.1415926535897931;\n    obj->VelocityNumber = 1.0;\n    obj->PositionNumber = 1.0;\n    obj->JointAxisInternal[0] = 0.0;\n    obj->JointAxisInternal[1] = 0.0;\n    obj->JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    inverse_kinematics_B.iv2[0] = 0;\n    inverse_kinematics_B.iv2[1] = 0;\n    inverse_kinematics_B.iv2[2] = 0;\n    inverse_kinematics_B.iv2[3] = 0;\n    inverse_kinematics_B.iv2[4] = 0;\n    inverse_kinematics_B.iv2[5] = 1;\n    for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 6;\n         inverse_kinematics_B.b_kstr_c++) {\n      inverse_kinematics_B.msubspace_data_p[inverse_kinematics_B.b_kstr_c] =\n        inverse_kinematics_B.iv2[inverse_kinematics_B.b_kstr_c];\n    }\n\n    inverse_kinematics_B.poslim_data_p[0] = -0.5;\n    inverse_kinematics_B.poslim_data_p[1] = 0.5;\n    obj->VelocityNumber = 1.0;\n    obj->PositionNumber = 1.0;\n    obj->JointAxisInternal[0] = 0.0;\n    obj->JointAxisInternal[1] = 0.0;\n    obj->JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 6;\n         inverse_kinematics_B.b_kstr_c++) {\n      inverse_kinematics_B.msubspace_data_p[inverse_kinematics_B.b_kstr_c] = 0;\n    }\n\n    inverse_kinematics_B.poslim_data_p[0] = 0.0;\n    inverse_kinematics_B.poslim_data_p[1] = 0.0;\n    obj->VelocityNumber = 0.0;\n    obj->PositionNumber = 0.0;\n    obj->JointAxisInternal[0] = 0.0;\n    obj->JointAxisInternal[1] = 0.0;\n    obj->JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  inverse_kinematics_B.i2 = obj->MotionSubspace->size[0] * obj->\n    MotionSubspace->size[1];\n  obj->MotionSubspace->size[0] = 6;\n  obj->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(obj->MotionSubspace, inverse_kinematics_B.i2);\n  for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 6;\n       inverse_kinematics_B.b_kstr_c++) {\n    obj->MotionSubspace->data[inverse_kinematics_B.b_kstr_c] =\n      inverse_kinematics_B.msubspace_data_p[inverse_kinematics_B.b_kstr_c];\n  }\n\n  inverse_kinematics_B.i2 = obj->PositionLimitsInternal->size[0] *\n    obj->PositionLimitsInternal->size[1];\n  obj->PositionLimitsInternal->size[0] = 1;\n  obj->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(obj->PositionLimitsInternal,\n    inverse_kinematics_B.i2);\n  for (inverse_kinematics_B.b_kstr_c = 0; inverse_kinematics_B.b_kstr_c < 2;\n       inverse_kinematics_B.b_kstr_c++) {\n    obj->PositionLimitsInternal->data[inverse_kinematics_B.b_kstr_c] =\n      inverse_kinematics_B.poslim_data_p[inverse_kinematics_B.b_kstr_c];\n  }\n\n  inverse_kinematics_B.i2 = obj->HomePositionInternal->size[0];\n  obj->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(obj->HomePositionInternal,\n    inverse_kinematics_B.i2);\n  obj->HomePositionInternal->data[0] = 0.0;\n  return b_obj;\n}\n\nstatic u_robotics_manip_internal_Rig_T *inv_RigidBodyTree_RigidBodyTree\n  (u_robotics_manip_internal_Rig_T *obj)\n{\n  c_rigidBodyJoint_inverse_kine_T *iobj_1;\n  emxArray_char_T_inverse_kinem_T *jname;\n  l_robotics_manip_internal_Col_T *iobj_0;\n  t_robotics_manip_internal_Rig_T *iobj_2;\n  u_robotics_manip_internal_Rig_T *b_obj;\n  static const char_T tmp[5] = { 'B', 'o', 'd', 'y', '1' };\n\n  static const real_T tmp_0[9] = { 0.0037363941296150649, -2.3660843211813849E-5,\n    0.00073505788570426926, -2.3660843211813849E-5, 0.0039968621121805256,\n    5.1910119838100993E-5, 0.00073505788570426926, 5.1910119838100993E-5,\n    0.00070548220277786677 };\n\n  static const real_T tmp_1[36] = { 0.0037363941296150649,\n    -2.3660843211813849E-5, 0.00073505788570426926, 0.0, 0.030307931352254961,\n    0.00043638286578455231, -2.3660843211813849E-5, 0.0039968621121805256,\n    5.1910119838100993E-5, -0.030307931352254961, 0.0, -0.006598642785242542,\n    0.00073505788570426926, 5.1910119838100993E-5, 0.00070548220277786677,\n    -0.00043638286578455231, 0.006598642785242542, 0.0, 0.0,\n    -0.030307931352254961, -0.00043638286578455231, 0.42596811552, 0.0, 0.0,\n    0.030307931352254961, 0.0, 0.006598642785242542, 0.0, 0.42596811552, 0.0,\n    0.00043638286578455231, -0.006598642785242542, 0.0, 0.0, 0.0, 0.42596811552\n  };\n\n  static const int8_T tmp_2[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    1 };\n\n  static const char_T tmp_3[6] = { 'J', 'o', 'i', 'n', 't', '1' };\n\n  static const char_T tmp_4[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_5[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  static const real_T tmp_6[16] = { 1.0, 0.0, -0.0, 0.0, 0.0, -1.0,\n    1.2246467991473532E-16, 0.0, 0.0, -1.2246467991473532E-16, -1.0, 0.0,\n    0.060164888, 0.059081195000000031, 0.069308911, 1.0 };\n\n  static const real_T tmp_7[16] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 };\n\n  static const real_T tmp_8[36] = { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };\n\n  static const char_T tmp_9[5] = { 'B', 'o', 'd', 'y', '2' };\n\n  static const real_T tmp_a[9] = { 0.0044702657880398922, 7.792531032363201E-12,\n    -1.5591817920808506E-12, 7.792531032363201E-12, 0.00048451650591669959,\n    0.00058763430807934293, -1.5591817920808506E-12, 0.00058763430807934293,\n    0.0041701532821232018 };\n\n  static const real_T tmp_b[36] = { 0.0044702657880398922, 7.792531032363201E-12,\n    -1.5591817920808506E-12, 0.0, 0.0060878808750251465, 0.030426215636229687,\n    7.792531032363201E-12, 0.00048451650591669959, 0.00058763430807934293,\n    -0.0060878808750251465, 0.0, 9.30825333481194E-11, -1.5591817920808506E-12,\n    0.00058763430807934293, 0.0041701532821232018, -0.030426215636229687,\n    -9.30825333481194E-11, 0.0, 0.0, -0.0060878808750251465,\n    -0.030426215636229687, 0.36344406661, 0.0, 0.0, 0.0060878808750251465, 0.0,\n    -9.30825333481194E-11, 0.0, 0.36344406661, 0.0, 0.030426215636229687,\n    9.30825333481194E-11, 0.0, 0.0, 0.0, 0.36344406661 };\n\n  static const char_T tmp_c[6] = { 'J', 'o', 'i', 'n', 't', '2' };\n\n  static const real_T tmp_d[16] = { -1.0, 1.2246467991473532E-16, -0.0, 0.0,\n    -7.498798913309288E-33, -6.123233995736766E-17, -1.0, 0.0,\n    -1.2246467991473532E-16, -1.0, 6.123233995736766E-17, 0.0,\n    -1.3877787807814457E-17, -0.018000000000000044, -0.11600000000000002, 1.0 };\n\n  int32_T exitg1;\n  b_obj = obj;\n  obj->NumBodies = 6.0;\n  iobj_0 = &obj->_pobj0[0];\n  iobj_1 = &obj->_pobj1[0];\n  iobj_2 = &obj->_pobj2[0];\n  obj->Bodies[0] = inverse_kin_RigidBody_RigidBody(&(&obj->_pobj2[0])[0],\n    &iobj_0[0], &iobj_1[0]);\n  obj->Bodies[1] = inverse_k_RigidBody_RigidBody_g(&iobj_2[1], &iobj_0[1],\n    &iobj_1[1]);\n  obj->Bodies[2] = inverse__RigidBody_RigidBody_ga(&iobj_2[2], &iobj_0[2],\n    &iobj_1[2]);\n  obj->Bodies[3] = inverse_RigidBody_RigidBody_gaq(&iobj_2[3], &iobj_0[3],\n    &iobj_1[3]);\n  obj->Bodies[4] = invers_RigidBody_RigidBody_gaqy(&iobj_2[4], &iobj_0[4],\n    &iobj_1[4]);\n  obj->Bodies[5] = inver_RigidBody_RigidBody_gaqyy(&iobj_2[5], &iobj_0[5],\n    &iobj_1[5]);\n  iobj_2 = &obj->_pobj2[6];\n  iobj_0 = &obj->_pobj0[6];\n  inverse_kinematics_B.i5 = iobj_2->NameInternal->size[0] * iobj_2->\n    NameInternal->size[1];\n  iobj_2->NameInternal->size[0] = 1;\n  iobj_2->NameInternal->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_2->NameInternal, inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 5;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->NameInternal->data[inverse_kinematics_B.b_kstr_h] =\n      tmp[inverse_kinematics_B.b_kstr_h];\n  }\n\n  iobj_2->ParentIndex = 0.0;\n  iobj_2->MassInternal = 0.42596811552;\n  iobj_2->CenterOfMassInternal[0] = 0.015490931233637657;\n  iobj_2->CenterOfMassInternal[1] = 0.0010244496005336889;\n  iobj_2->CenterOfMassInternal[2] = -0.071150704120792219;\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 9;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->InertiaInternal[inverse_kinematics_B.b_kstr_h] =\n      tmp_0[inverse_kinematics_B.b_kstr_h];\n  }\n\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 36;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->SpatialInertia[inverse_kinematics_B.b_kstr_h] =\n      tmp_1[inverse_kinematics_B.b_kstr_h];\n  }\n\n  obj->_pobj1[6].InTree = false;\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 16;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[6].JointToParentTransform[inverse_kinematics_B.b_kstr_h] =\n      tmp_2[inverse_kinematics_B.b_kstr_h];\n  }\n\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 16;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[6].ChildToJointTransform[inverse_kinematics_B.b_kstr_h] =\n      tmp_2[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[6].NameInternal->size[0] * obj->_pobj1[6]\n    .NameInternal->size[1];\n  obj->_pobj1[6].NameInternal->size[0] = 1;\n  obj->_pobj1[6].NameInternal->size[1] = 6;\n  invers_emxEnsureCapacity_char_T(obj->_pobj1[6].NameInternal,\n    inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[6].NameInternal->data[inverse_kinematics_B.b_kstr_h] =\n      tmp_3[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[6].Type->size[0] * obj->_pobj1[6]\n    .Type->size[1];\n  obj->_pobj1[6].Type->size[0] = 1;\n  obj->_pobj1[6].Type->size[1] = 8;\n  invers_emxEnsureCapacity_char_T(obj->_pobj1[6].Type, inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 8;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[6].Type->data[inverse_kinematics_B.b_kstr_h] =\n      tmp_4[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinemati_emxInit_char_T(&jname, 2);\n  inverse_kinematics_B.i5 = jname->size[0] * jname->size[1];\n  jname->size[0] = 1;\n  jname->size[1] = obj->_pobj1[6].Type->size[1];\n  invers_emxEnsureCapacity_char_T(jname, inverse_kinematics_B.i5);\n  inverse_kinematics_B.loop_ub_e = obj->_pobj1[6].Type->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h <=\n       inverse_kinematics_B.loop_ub_e; inverse_kinematics_B.b_kstr_h++) {\n    inverse_kinematics_B.i5 = inverse_kinematics_B.b_kstr_h;\n    jname->data[inverse_kinematics_B.i5] = obj->_pobj1[6].Type->\n      data[inverse_kinematics_B.i5];\n  }\n\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 8;\n       inverse_kinematics_B.b_kstr_h++) {\n    inverse_kinematics_B.b_jz[inverse_kinematics_B.b_kstr_h] =\n      tmp_4[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.b_bool_b = false;\n  if (jname->size[1] != 8) {\n  } else {\n    inverse_kinematics_B.b_kstr_h = 1;\n    do {\n      exitg1 = 0;\n      if (inverse_kinematics_B.b_kstr_h - 1 < 8) {\n        if (jname->data[inverse_kinematics_B.b_kstr_h - 1] !=\n            inverse_kinematics_B.b_jz[inverse_kinematics_B.b_kstr_h - 1]) {\n          exitg1 = 1;\n        } else {\n          inverse_kinematics_B.b_kstr_h++;\n        }\n      } else {\n        inverse_kinematics_B.b_bool_b = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (inverse_kinematics_B.b_bool_b) {\n    inverse_kinematics_B.b_kstr_h = 0;\n  } else {\n    for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 9;\n         inverse_kinematics_B.b_kstr_h++) {\n      inverse_kinematics_B.b_da[inverse_kinematics_B.b_kstr_h] =\n        tmp_5[inverse_kinematics_B.b_kstr_h];\n    }\n\n    inverse_kinematics_B.b_bool_b = false;\n    if (jname->size[1] != 9) {\n    } else {\n      inverse_kinematics_B.b_kstr_h = 1;\n      do {\n        exitg1 = 0;\n        if (inverse_kinematics_B.b_kstr_h - 1 < 9) {\n          if (jname->data[inverse_kinematics_B.b_kstr_h - 1] !=\n              inverse_kinematics_B.b_da[inverse_kinematics_B.b_kstr_h - 1]) {\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.b_kstr_h++;\n          }\n        } else {\n          inverse_kinematics_B.b_bool_b = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (inverse_kinematics_B.b_bool_b) {\n      inverse_kinematics_B.b_kstr_h = 1;\n    } else {\n      inverse_kinematics_B.b_kstr_h = -1;\n    }\n  }\n\n  switch (inverse_kinematics_B.b_kstr_h) {\n   case 0:\n    inverse_kinematics_B.iv3[0] = 0;\n    inverse_kinematics_B.iv3[1] = 0;\n    inverse_kinematics_B.iv3[2] = 1;\n    inverse_kinematics_B.iv3[3] = 0;\n    inverse_kinematics_B.iv3[4] = 0;\n    inverse_kinematics_B.iv3[5] = 0;\n    for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n         inverse_kinematics_B.b_kstr_h++) {\n      inverse_kinematics_B.msubspace_data_l[inverse_kinematics_B.b_kstr_h] =\n        inverse_kinematics_B.iv3[inverse_kinematics_B.b_kstr_h];\n    }\n\n    inverse_kinematics_B.poslim_data_c[0] = -3.1415926535897931;\n    inverse_kinematics_B.poslim_data_c[1] = 3.1415926535897931;\n    obj->_pobj1[6].VelocityNumber = 1.0;\n    obj->_pobj1[6].PositionNumber = 1.0;\n    obj->_pobj1[6].JointAxisInternal[0] = 0.0;\n    obj->_pobj1[6].JointAxisInternal[1] = 0.0;\n    obj->_pobj1[6].JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    inverse_kinematics_B.iv3[0] = 0;\n    inverse_kinematics_B.iv3[1] = 0;\n    inverse_kinematics_B.iv3[2] = 0;\n    inverse_kinematics_B.iv3[3] = 0;\n    inverse_kinematics_B.iv3[4] = 0;\n    inverse_kinematics_B.iv3[5] = 1;\n    for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n         inverse_kinematics_B.b_kstr_h++) {\n      inverse_kinematics_B.msubspace_data_l[inverse_kinematics_B.b_kstr_h] =\n        inverse_kinematics_B.iv3[inverse_kinematics_B.b_kstr_h];\n    }\n\n    inverse_kinematics_B.poslim_data_c[0] = -0.5;\n    inverse_kinematics_B.poslim_data_c[1] = 0.5;\n    obj->_pobj1[6].VelocityNumber = 1.0;\n    obj->_pobj1[6].PositionNumber = 1.0;\n    obj->_pobj1[6].JointAxisInternal[0] = 0.0;\n    obj->_pobj1[6].JointAxisInternal[1] = 0.0;\n    obj->_pobj1[6].JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n         inverse_kinematics_B.b_kstr_h++) {\n      inverse_kinematics_B.msubspace_data_l[inverse_kinematics_B.b_kstr_h] = 0;\n    }\n\n    inverse_kinematics_B.poslim_data_c[0] = 0.0;\n    inverse_kinematics_B.poslim_data_c[1] = 0.0;\n    obj->_pobj1[6].VelocityNumber = 0.0;\n    obj->_pobj1[6].PositionNumber = 0.0;\n    obj->_pobj1[6].JointAxisInternal[0] = 0.0;\n    obj->_pobj1[6].JointAxisInternal[1] = 0.0;\n    obj->_pobj1[6].JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[6].MotionSubspace->size[0] * obj->\n    _pobj1[6].MotionSubspace->size[1];\n  obj->_pobj1[6].MotionSubspace->size[0] = 6;\n  obj->_pobj1[6].MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(obj->_pobj1[6].MotionSubspace,\n    inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[6].MotionSubspace->data[inverse_kinematics_B.b_kstr_h] =\n      inverse_kinematics_B.msubspace_data_l[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[6].PositionLimitsInternal->size[0] *\n    obj->_pobj1[6].PositionLimitsInternal->size[1];\n  obj->_pobj1[6].PositionLimitsInternal->size[0] = 1;\n  obj->_pobj1[6].PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(obj->_pobj1[6].PositionLimitsInternal,\n    inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 2;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[6].PositionLimitsInternal->data[inverse_kinematics_B.b_kstr_h] =\n      inverse_kinematics_B.poslim_data_c[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[6].HomePositionInternal->size[0];\n  obj->_pobj1[6].HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(obj->_pobj1[6].HomePositionInternal,\n    inverse_kinematics_B.i5);\n  obj->_pobj1[6].HomePositionInternal->data[0] = 0.0;\n  iobj_2->JointInternal = &obj->_pobj1[6];\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 16;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->JointInternal->JointToParentTransform[inverse_kinematics_B.b_kstr_h]\n      = tmp_6[inverse_kinematics_B.b_kstr_h];\n  }\n\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 16;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->JointInternal->ChildToJointTransform[inverse_kinematics_B.b_kstr_h] =\n      tmp_7[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = iobj_2->JointInternal->MotionSubspace->size[0] *\n    iobj_2->JointInternal->MotionSubspace->size[1];\n  iobj_2->JointInternal->MotionSubspace->size[0] = 6;\n  iobj_2->JointInternal->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_2->JointInternal->MotionSubspace,\n    inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->JointInternal->MotionSubspace->data[inverse_kinematics_B.b_kstr_h] =\n      tmp_8[inverse_kinematics_B.b_kstr_h];\n  }\n\n  iobj_2->JointInternal->InTree = true;\n  inverse_kinematics_B.i5 = iobj_2->JointInternal->PositionLimitsInternal->size\n    [0] * iobj_2->JointInternal->PositionLimitsInternal->size[1];\n  iobj_2->JointInternal->PositionLimitsInternal->size[0] = 1;\n  iobj_2->JointInternal->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_2->JointInternal->PositionLimitsInternal,\n    inverse_kinematics_B.i5);\n  iobj_2->JointInternal->PositionLimitsInternal->data[0] = -0.52359877559829882;\n  iobj_2->JointInternal->PositionLimitsInternal->data[iobj_2->\n    JointInternal->PositionLimitsInternal->size[0]] = 2.0071286397934789;\n  iobj_2->JointInternal->JointAxisInternal[0] = 0.0;\n  iobj_2->JointInternal->JointAxisInternal[1] = 0.0;\n  iobj_2->JointInternal->JointAxisInternal[2] = 1.0;\n  inverse_kinematics_B.i5 = iobj_2->JointInternal->HomePositionInternal->size[0];\n  iobj_2->JointInternal->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_2->JointInternal->HomePositionInternal,\n    inverse_kinematics_B.i5);\n  iobj_2->JointInternal->HomePositionInternal->data[0] = 0.0;\n  iobj_2->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  obj->Bodies[0] = iobj_2;\n  obj->Bodies[0]->Index = 1.0;\n  iobj_2 = &obj->_pobj2[7];\n  iobj_0 = &obj->_pobj0[7];\n  inverse_kinematics_B.i5 = iobj_2->NameInternal->size[0] * iobj_2->\n    NameInternal->size[1];\n  iobj_2->NameInternal->size[0] = 1;\n  iobj_2->NameInternal->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_2->NameInternal, inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 5;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->NameInternal->data[inverse_kinematics_B.b_kstr_h] =\n      tmp_9[inverse_kinematics_B.b_kstr_h];\n  }\n\n  iobj_2->ParentIndex = 1.0;\n  iobj_2->MassInternal = 0.36344406661;\n  iobj_2->CenterOfMassInternal[0] = -2.5611240325462029E-10;\n  iobj_2->CenterOfMassInternal[1] = 0.083716363621032963;\n  iobj_2->CenterOfMassInternal[2] = -0.016750530368563846;\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 9;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->InertiaInternal[inverse_kinematics_B.b_kstr_h] =\n      tmp_a[inverse_kinematics_B.b_kstr_h];\n  }\n\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 36;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->SpatialInertia[inverse_kinematics_B.b_kstr_h] =\n      tmp_b[inverse_kinematics_B.b_kstr_h];\n  }\n\n  obj->_pobj1[7].InTree = false;\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 16;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[7].JointToParentTransform[inverse_kinematics_B.b_kstr_h] =\n      tmp_2[inverse_kinematics_B.b_kstr_h];\n  }\n\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 16;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[7].ChildToJointTransform[inverse_kinematics_B.b_kstr_h] =\n      tmp_2[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[7].NameInternal->size[0] * obj->_pobj1[7]\n    .NameInternal->size[1];\n  obj->_pobj1[7].NameInternal->size[0] = 1;\n  obj->_pobj1[7].NameInternal->size[1] = 6;\n  invers_emxEnsureCapacity_char_T(obj->_pobj1[7].NameInternal,\n    inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[7].NameInternal->data[inverse_kinematics_B.b_kstr_h] =\n      tmp_c[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[7].Type->size[0] * obj->_pobj1[7]\n    .Type->size[1];\n  obj->_pobj1[7].Type->size[0] = 1;\n  obj->_pobj1[7].Type->size[1] = 8;\n  invers_emxEnsureCapacity_char_T(obj->_pobj1[7].Type, inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 8;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[7].Type->data[inverse_kinematics_B.b_kstr_h] =\n      tmp_4[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = jname->size[0] * jname->size[1];\n  jname->size[0] = 1;\n  jname->size[1] = obj->_pobj1[7].Type->size[1];\n  invers_emxEnsureCapacity_char_T(jname, inverse_kinematics_B.i5);\n  inverse_kinematics_B.loop_ub_e = obj->_pobj1[7].Type->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h <=\n       inverse_kinematics_B.loop_ub_e; inverse_kinematics_B.b_kstr_h++) {\n    inverse_kinematics_B.i5 = inverse_kinematics_B.b_kstr_h;\n    jname->data[inverse_kinematics_B.i5] = obj->_pobj1[7].Type->\n      data[inverse_kinematics_B.i5];\n  }\n\n  inverse_kinematics_B.b_bool_b = false;\n  if (jname->size[1] != 8) {\n  } else {\n    inverse_kinematics_B.b_kstr_h = 1;\n    do {\n      exitg1 = 0;\n      if (inverse_kinematics_B.b_kstr_h - 1 < 8) {\n        if (jname->data[inverse_kinematics_B.b_kstr_h - 1] !=\n            inverse_kinematics_B.b_jz[inverse_kinematics_B.b_kstr_h - 1]) {\n          exitg1 = 1;\n        } else {\n          inverse_kinematics_B.b_kstr_h++;\n        }\n      } else {\n        inverse_kinematics_B.b_bool_b = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (inverse_kinematics_B.b_bool_b) {\n    inverse_kinematics_B.b_kstr_h = 0;\n  } else {\n    for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 9;\n         inverse_kinematics_B.b_kstr_h++) {\n      inverse_kinematics_B.b_da[inverse_kinematics_B.b_kstr_h] =\n        tmp_5[inverse_kinematics_B.b_kstr_h];\n    }\n\n    inverse_kinematics_B.b_bool_b = false;\n    if (jname->size[1] != 9) {\n    } else {\n      inverse_kinematics_B.b_kstr_h = 1;\n      do {\n        exitg1 = 0;\n        if (inverse_kinematics_B.b_kstr_h - 1 < 9) {\n          if (jname->data[inverse_kinematics_B.b_kstr_h - 1] !=\n              inverse_kinematics_B.b_da[inverse_kinematics_B.b_kstr_h - 1]) {\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.b_kstr_h++;\n          }\n        } else {\n          inverse_kinematics_B.b_bool_b = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (inverse_kinematics_B.b_bool_b) {\n      inverse_kinematics_B.b_kstr_h = 1;\n    } else {\n      inverse_kinematics_B.b_kstr_h = -1;\n    }\n  }\n\n  switch (inverse_kinematics_B.b_kstr_h) {\n   case 0:\n    inverse_kinematics_B.iv3[0] = 0;\n    inverse_kinematics_B.iv3[1] = 0;\n    inverse_kinematics_B.iv3[2] = 1;\n    inverse_kinematics_B.iv3[3] = 0;\n    inverse_kinematics_B.iv3[4] = 0;\n    inverse_kinematics_B.iv3[5] = 0;\n    for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n         inverse_kinematics_B.b_kstr_h++) {\n      inverse_kinematics_B.msubspace_data_l[inverse_kinematics_B.b_kstr_h] =\n        inverse_kinematics_B.iv3[inverse_kinematics_B.b_kstr_h];\n    }\n\n    inverse_kinematics_B.poslim_data_c[0] = -3.1415926535897931;\n    inverse_kinematics_B.poslim_data_c[1] = 3.1415926535897931;\n    obj->_pobj1[7].VelocityNumber = 1.0;\n    obj->_pobj1[7].PositionNumber = 1.0;\n    obj->_pobj1[7].JointAxisInternal[0] = 0.0;\n    obj->_pobj1[7].JointAxisInternal[1] = 0.0;\n    obj->_pobj1[7].JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    inverse_kinematics_B.iv3[0] = 0;\n    inverse_kinematics_B.iv3[1] = 0;\n    inverse_kinematics_B.iv3[2] = 0;\n    inverse_kinematics_B.iv3[3] = 0;\n    inverse_kinematics_B.iv3[4] = 0;\n    inverse_kinematics_B.iv3[5] = 1;\n    for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n         inverse_kinematics_B.b_kstr_h++) {\n      inverse_kinematics_B.msubspace_data_l[inverse_kinematics_B.b_kstr_h] =\n        inverse_kinematics_B.iv3[inverse_kinematics_B.b_kstr_h];\n    }\n\n    inverse_kinematics_B.poslim_data_c[0] = -0.5;\n    inverse_kinematics_B.poslim_data_c[1] = 0.5;\n    obj->_pobj1[7].VelocityNumber = 1.0;\n    obj->_pobj1[7].PositionNumber = 1.0;\n    obj->_pobj1[7].JointAxisInternal[0] = 0.0;\n    obj->_pobj1[7].JointAxisInternal[1] = 0.0;\n    obj->_pobj1[7].JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n         inverse_kinematics_B.b_kstr_h++) {\n      inverse_kinematics_B.msubspace_data_l[inverse_kinematics_B.b_kstr_h] = 0;\n    }\n\n    inverse_kinematics_B.poslim_data_c[0] = 0.0;\n    inverse_kinematics_B.poslim_data_c[1] = 0.0;\n    obj->_pobj1[7].VelocityNumber = 0.0;\n    obj->_pobj1[7].PositionNumber = 0.0;\n    obj->_pobj1[7].JointAxisInternal[0] = 0.0;\n    obj->_pobj1[7].JointAxisInternal[1] = 0.0;\n    obj->_pobj1[7].JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[7].MotionSubspace->size[0] * obj->\n    _pobj1[7].MotionSubspace->size[1];\n  obj->_pobj1[7].MotionSubspace->size[0] = 6;\n  obj->_pobj1[7].MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(obj->_pobj1[7].MotionSubspace,\n    inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[7].MotionSubspace->data[inverse_kinematics_B.b_kstr_h] =\n      inverse_kinematics_B.msubspace_data_l[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[7].PositionLimitsInternal->size[0] *\n    obj->_pobj1[7].PositionLimitsInternal->size[1];\n  obj->_pobj1[7].PositionLimitsInternal->size[0] = 1;\n  obj->_pobj1[7].PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(obj->_pobj1[7].PositionLimitsInternal,\n    inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 2;\n       inverse_kinematics_B.b_kstr_h++) {\n    obj->_pobj1[7].PositionLimitsInternal->data[inverse_kinematics_B.b_kstr_h] =\n      inverse_kinematics_B.poslim_data_c[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = obj->_pobj1[7].HomePositionInternal->size[0];\n  obj->_pobj1[7].HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(obj->_pobj1[7].HomePositionInternal,\n    inverse_kinematics_B.i5);\n  obj->_pobj1[7].HomePositionInternal->data[0] = 0.0;\n  iobj_2->JointInternal = &obj->_pobj1[7];\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 16;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->JointInternal->JointToParentTransform[inverse_kinematics_B.b_kstr_h]\n      = tmp_d[inverse_kinematics_B.b_kstr_h];\n  }\n\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 16;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->JointInternal->ChildToJointTransform[inverse_kinematics_B.b_kstr_h] =\n      tmp_7[inverse_kinematics_B.b_kstr_h];\n  }\n\n  inverse_kinematics_B.i5 = iobj_2->JointInternal->MotionSubspace->size[0] *\n    iobj_2->JointInternal->MotionSubspace->size[1];\n  iobj_2->JointInternal->MotionSubspace->size[0] = 6;\n  iobj_2->JointInternal->MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_2->JointInternal->MotionSubspace,\n    inverse_kinematics_B.i5);\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 6;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->JointInternal->MotionSubspace->data[inverse_kinematics_B.b_kstr_h] =\n      tmp_8[inverse_kinematics_B.b_kstr_h];\n  }\n\n  iobj_2->JointInternal->InTree = true;\n  inverse_kinematics_B.i5 = iobj_2->JointInternal->PositionLimitsInternal->size\n    [0] * iobj_2->JointInternal->PositionLimitsInternal->size[1];\n  iobj_2->JointInternal->PositionLimitsInternal->size[0] = 1;\n  iobj_2->JointInternal->PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_2->JointInternal->PositionLimitsInternal,\n    inverse_kinematics_B.i5);\n  iobj_2->JointInternal->PositionLimitsInternal->data[0] = -1.5707963267948966;\n  iobj_2->JointInternal->PositionLimitsInternal->data[iobj_2->\n    JointInternal->PositionLimitsInternal->size[0]] = 0.78539816339744828;\n  iobj_2->JointInternal->JointAxisInternal[0] = 0.0;\n  iobj_2->JointInternal->JointAxisInternal[1] = 0.0;\n  iobj_2->JointInternal->JointAxisInternal[2] = 1.0;\n  inverse_kinematics_B.i5 = iobj_2->JointInternal->HomePositionInternal->size[0];\n  iobj_2->JointInternal->HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_2->JointInternal->HomePositionInternal,\n    inverse_kinematics_B.i5);\n  iobj_2->JointInternal->HomePositionInternal->data[0] = 0.0;\n  iobj_2->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  obj->Bodies[1] = iobj_2;\n  obj->Bodies[1]->Index = 2.0;\n  obj->Bodies[2] = inve_RigidBody_RigidBody_gaqyy1(&obj->_pobj2[8], &obj->\n    _pobj0[8], &obj->_pobj1[8]);\n  obj->Bodies[2]->Index = 3.0;\n  obj->Bodies[3] = inv_RigidBody_RigidBody_gaqyy1n(&obj->_pobj2[9], &obj->\n    _pobj0[9], &obj->_pobj1[9]);\n  obj->Bodies[3]->Index = 4.0;\n  obj->Bodies[4] = in_RigidBody_RigidBody_gaqyy1no(&obj->_pobj2[10],\n    &obj->_pobj0[10], &obj->_pobj1[10]);\n  obj->Bodies[4]->Index = 5.0;\n  obj->Bodies[5] = i_RigidBody_RigidBody_gaqyy1no5(&obj->_pobj2[11],\n    &obj->_pobj0[11], &obj->_pobj1[11]);\n  obj->Bodies[5]->Index = 6.0;\n  obj->Gravity[0] = 0.0;\n  obj->Gravity[1] = 0.0;\n  obj->Gravity[2] = -9.80665;\n  iobj_2 = &obj->Base;\n  iobj_0 = &obj->_pobj0[12];\n  inverse_kinematics_B.i5 = iobj_2->NameInternal->size[0] * iobj_2->\n    NameInternal->size[1];\n  iobj_2->NameInternal->size[0] = 1;\n  iobj_2->NameInternal->size[1] = 4;\n  invers_emxEnsureCapacity_char_T(iobj_2->NameInternal, inverse_kinematics_B.i5);\n  iobj_2->NameInternal->data[0] = 'B';\n  iobj_2->NameInternal->data[1] = 'a';\n  iobj_2->NameInternal->data[2] = 's';\n  iobj_2->NameInternal->data[3] = 'e';\n  iobj_2->ParentIndex = -1.0;\n  iobj_2->MassInternal = 0.0;\n  iobj_2->CenterOfMassInternal[0] = 0.0;\n  iobj_2->CenterOfMassInternal[1] = 0.0;\n  iobj_2->CenterOfMassInternal[2] = 0.0;\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 9;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->InertiaInternal[inverse_kinematics_B.b_kstr_h] = 0.0;\n  }\n\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h < 36;\n       inverse_kinematics_B.b_kstr_h++) {\n    iobj_2->SpatialInertia[inverse_kinematics_B.b_kstr_h] = 0.0;\n  }\n\n  inverse_kinematics_B.i5 = jname->size[0] * jname->size[1];\n  jname->size[0] = 1;\n  jname->size[1] = iobj_2->NameInternal->size[1] + 4;\n  invers_emxEnsureCapacity_char_T(jname, inverse_kinematics_B.i5);\n  inverse_kinematics_B.loop_ub_e = iobj_2->NameInternal->size[1];\n  for (inverse_kinematics_B.b_kstr_h = 0; inverse_kinematics_B.b_kstr_h <\n       inverse_kinematics_B.loop_ub_e; inverse_kinematics_B.b_kstr_h++) {\n    inverse_kinematics_B.i5 = inverse_kinematics_B.b_kstr_h;\n    jname->data[inverse_kinematics_B.i5] = iobj_2->NameInternal->\n      data[inverse_kinematics_B.i5];\n  }\n\n  jname->data[inverse_kinematics_B.loop_ub_e] = '_';\n  jname->data[inverse_kinematics_B.loop_ub_e + 1] = 'j';\n  jname->data[inverse_kinematics_B.loop_ub_e + 2] = 'n';\n  jname->data[inverse_kinematics_B.loop_ub_e + 3] = 't';\n  iobj_2->JointInternal = i_rigidBodyJoint_rigidBodyJoint(&obj->_pobj1[12],\n    jname);\n  iobj_2->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0, 0.0);\n  obj->Base.Index = 0.0;\n  inverse_kinemati_emxFree_char_T(&jname);\n  return b_obj;\n}\n\nstatic void inverse_genrand_uint32_vector_g(uint32_T mt[625], uint32_T u[2])\n{\n  for (inverse_kinematics_B.b_j_h = 0; inverse_kinematics_B.b_j_h < 2;\n       inverse_kinematics_B.b_j_h++) {\n    inverse_kinematics_B.mti = mt[624] + 1U;\n    if (mt[624] + 1U >= 625U) {\n      for (inverse_kinematics_B.b_kk = 0; inverse_kinematics_B.b_kk < 227;\n           inverse_kinematics_B.b_kk++) {\n        inverse_kinematics_B.y_k = (mt[inverse_kinematics_B.b_kk + 1] &\n          2147483647U) | (mt[inverse_kinematics_B.b_kk] & 2147483648U);\n        if ((inverse_kinematics_B.y_k & 1U) == 0U) {\n          inverse_kinematics_B.y_k >>= 1U;\n        } else {\n          inverse_kinematics_B.y_k = inverse_kinematics_B.y_k >> 1U ^\n            2567483615U;\n        }\n\n        mt[inverse_kinematics_B.b_kk] = mt[inverse_kinematics_B.b_kk + 397] ^\n          inverse_kinematics_B.y_k;\n      }\n\n      for (inverse_kinematics_B.b_kk = 0; inverse_kinematics_B.b_kk < 396;\n           inverse_kinematics_B.b_kk++) {\n        inverse_kinematics_B.y_k = (mt[inverse_kinematics_B.b_kk + 227] &\n          2147483648U) | (mt[inverse_kinematics_B.b_kk + 228] & 2147483647U);\n        if ((inverse_kinematics_B.y_k & 1U) == 0U) {\n          inverse_kinematics_B.y_k >>= 1U;\n        } else {\n          inverse_kinematics_B.y_k = inverse_kinematics_B.y_k >> 1U ^\n            2567483615U;\n        }\n\n        mt[inverse_kinematics_B.b_kk + 227] = mt[inverse_kinematics_B.b_kk] ^\n          inverse_kinematics_B.y_k;\n      }\n\n      inverse_kinematics_B.y_k = (mt[623] & 2147483648U) | (mt[0] & 2147483647U);\n      if ((inverse_kinematics_B.y_k & 1U) == 0U) {\n        inverse_kinematics_B.y_k >>= 1U;\n      } else {\n        inverse_kinematics_B.y_k = inverse_kinematics_B.y_k >> 1U ^ 2567483615U;\n      }\n\n      mt[623] = mt[396] ^ inverse_kinematics_B.y_k;\n      inverse_kinematics_B.mti = 1U;\n    }\n\n    inverse_kinematics_B.y_k = mt[static_cast<int32_T>(inverse_kinematics_B.mti)\n      - 1];\n    mt[624] = inverse_kinematics_B.mti;\n    inverse_kinematics_B.y_k ^= inverse_kinematics_B.y_k >> 11U;\n    inverse_kinematics_B.y_k ^= inverse_kinematics_B.y_k << 7U & 2636928640U;\n    inverse_kinematics_B.y_k ^= inverse_kinematics_B.y_k << 15U & 4022730752U;\n    u[inverse_kinematics_B.b_j_h] = inverse_kinematics_B.y_k >> 18U ^\n      inverse_kinematics_B.y_k;\n  }\n}\n\nstatic boolean_T inverse_kinemati_is_valid_state(const uint32_T mt[625])\n{\n  boolean_T isvalid;\n  if ((mt[624] >= 1U) && (mt[624] < 625U)) {\n    isvalid = true;\n  } else {\n    isvalid = false;\n  }\n\n  if (isvalid) {\n    int32_T k;\n    boolean_T exitg1;\n    isvalid = false;\n    k = 0;\n    exitg1 = false;\n    while ((!exitg1) && (k + 1 < 625)) {\n      if (mt[k] == 0U) {\n        k++;\n      } else {\n        isvalid = true;\n        exitg1 = true;\n      }\n    }\n  }\n\n  return isvalid;\n}\n\nstatic void inverse_kinematics_rand(real_T r[5])\n{\n  uint32_T b_u[2];\n  for (int32_T b_k = 0; b_k < 5; b_k++) {\n    real_T b_r;\n\n    /* ========================= COPYRIGHT NOTICE ============================ */\n    /*  This is a uniform (0,1) pseudorandom number generator based on:        */\n    /*                                                                         */\n    /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\n    /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\n    /*                                                                         */\n    /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\n    /*  All rights reserved.                                                   */\n    /*                                                                         */\n    /*  Redistribution and use in source and binary forms, with or without     */\n    /*  modification, are permitted provided that the following conditions     */\n    /*  are met:                                                               */\n    /*                                                                         */\n    /*    1. Redistributions of source code must retain the above copyright    */\n    /*       notice, this list of conditions and the following disclaimer.     */\n    /*                                                                         */\n    /*    2. Redistributions in binary form must reproduce the above copyright */\n    /*       notice, this list of conditions and the following disclaimer      */\n    /*       in the documentation and/or other materials provided with the     */\n    /*       distribution.                                                     */\n    /*                                                                         */\n    /*    3. The names of its contributors may not be used to endorse or       */\n    /*       promote products derived from this software without specific      */\n    /*       prior written permission.                                         */\n    /*                                                                         */\n    /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\n    /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\n    /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\n    /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\n    /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\n    /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\n    /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\n    /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\n    /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\n    /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\n    /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n    /*                                                                         */\n    /* =============================   END   ================================= */\n    int32_T exitg1;\n    do {\n      exitg1 = 0;\n      inverse_genrand_uint32_vector_g(inverse_kinematics_DW.state_c, b_u);\n      b_r = (static_cast<real_T>(b_u[0] >> 5U) * 6.7108864E+7 +\n             static_cast<real_T>(b_u[1] >> 6U)) * 1.1102230246251565E-16;\n      if (b_r == 0.0) {\n        if (!inverse_kinemati_is_valid_state(inverse_kinematics_DW.state_c)) {\n          inverse_kinematics_DW.state_c[0] = 5489U;\n          inverse_kinematics_DW.state_c[624] = 624U;\n        }\n      } else {\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n\n    r[b_k] = b_r;\n  }\n}\n\nstatic boolean_T inverse_kinematics_strcmp(const emxArray_char_T_inverse_kinem_T\n  *a, const emxArray_char_T_inverse_kinem_T *b)\n{\n  boolean_T b_bool;\n  b_bool = false;\n  inverse_kinematics_B.d_n = (a->size[1] == 0);\n  if (inverse_kinematics_B.d_n && (b->size[1] == 0)) {\n    b_bool = true;\n  } else if (a->size[1] != b->size[1]) {\n  } else {\n    inverse_kinematics_B.b_kstr_o = 1;\n    int32_T exitg1;\n    do {\n      exitg1 = 0;\n      if (inverse_kinematics_B.b_kstr_o - 1 <= b->size[1] - 1) {\n        inverse_kinematics_B.i9 = inverse_kinematics_B.b_kstr_o - 1;\n        if (a->data[inverse_kinematics_B.i9] != b->data[inverse_kinematics_B.i9])\n        {\n          exitg1 = 1;\n        } else {\n          inverse_kinematics_B.b_kstr_o++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  return b_bool;\n}\n\nstatic real_T RigidBodyTree_findBodyIndexByNa(v_robotics_manip_internal_Rig_T\n  *obj, const emxArray_char_T_inverse_kinem_T *bodyname)\n{\n  emxArray_char_T_inverse_kinem_T *bname;\n  t_robotics_manip_internal_Rig_T *obj_0;\n  real_T bid;\n  inverse_kinemati_emxInit_char_T(&bname, 2);\n  bid = -1.0;\n  inverse_kinematics_B.i7 = bname->size[0] * bname->size[1];\n  bname->size[0] = 1;\n  bname->size[1] = obj->Base.NameInternal->size[1];\n  invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.i7);\n  inverse_kinematics_B.loop_ub_n = obj->Base.NameInternal->size[1] - 1;\n  for (inverse_kinematics_B.i7 = 0; inverse_kinematics_B.i7 <=\n       inverse_kinematics_B.loop_ub_n; inverse_kinematics_B.i7++) {\n    inverse_kinematics_B.i8 = inverse_kinematics_B.i7;\n    bname->data[inverse_kinematics_B.i8] = obj->Base.NameInternal->\n      data[inverse_kinematics_B.i8];\n  }\n\n  if (inverse_kinematics_strcmp(bname, bodyname)) {\n    bid = 0.0;\n  } else {\n    boolean_T exitg1;\n    inverse_kinematics_B.b_p = obj->NumBodies;\n    inverse_kinematics_B.b_i_o = 0;\n    exitg1 = false;\n    while ((!exitg1) && (inverse_kinematics_B.b_i_o <= static_cast<int32_T>\n                         (inverse_kinematics_B.b_p) - 1)) {\n      obj_0 = obj->Bodies[inverse_kinematics_B.b_i_o];\n      inverse_kinematics_B.i7 = bname->size[0] * bname->size[1];\n      bname->size[0] = 1;\n      bname->size[1] = obj_0->NameInternal->size[1];\n      invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.i7);\n      inverse_kinematics_B.loop_ub_n = obj_0->NameInternal->size[1] - 1;\n      for (inverse_kinematics_B.i7 = 0; inverse_kinematics_B.i7 <=\n           inverse_kinematics_B.loop_ub_n; inverse_kinematics_B.i7++) {\n        inverse_kinematics_B.i8 = inverse_kinematics_B.i7;\n        bname->data[inverse_kinematics_B.i8] = obj_0->NameInternal->\n          data[inverse_kinematics_B.i8];\n      }\n\n      if (inverse_kinematics_strcmp(bname, bodyname)) {\n        bid = static_cast<real_T>(inverse_kinematics_B.b_i_o) + 1.0;\n        exitg1 = true;\n      } else {\n        inverse_kinematics_B.b_i_o++;\n      }\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&bname);\n  return bid;\n}\n\nstatic void inverse_kinemati_emxFree_real_T(emxArray_real_T_inverse_kinem_T\n  **pEmxArray)\n{\n  if (*pEmxArray != static_cast<emxArray_real_T_inverse_kinem_T *>(NULL)) {\n    if (((*pEmxArray)->data != static_cast<real_T *>(NULL)) && (*pEmxArray)\n        ->canFreeData) {\n      free((*pEmxArray)->data);\n    }\n\n    free((*pEmxArray)->size);\n    free(*pEmxArray);\n    *pEmxArray = static_cast<emxArray_real_T_inverse_kinem_T *>(NULL);\n  }\n}\n\nstatic t_robotics_manip_internal_Rig_T *inverse_kinemati_RigidBody_copy\n  (t_robotics_manip_internal_Rig_T *obj, l_robotics_manip_internal_Col_T *iobj_0,\n   c_rigidBodyJoint_inverse_kine_T *iobj_1, t_robotics_manip_internal_Rig_T\n   *iobj_2)\n{\n  c_rigidBodyJoint_inverse_kine_T *obj_0;\n  emxArray_char_T_inverse_kinem_T *jname;\n  emxArray_char_T_inverse_kinem_T *jtype;\n  emxArray_real_T_inverse_kinem_T *obj_3;\n  k_robotics_manip_internal_Col_T *obj_2;\n  l_robotics_manip_internal_Col_T *newObj;\n  l_robotics_manip_internal_Col_T *obj_1;\n  t_robotics_manip_internal_Rig_T *newbody;\n  static const int8_T tmp[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1\n  };\n\n  static const char_T tmp_0[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_1[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  static const char_T tmp_2[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_3[128] = { '\\x00', '\\x01', '\\x02', '\\x03', '\\x04',\n    '\\x05', '\\x06', '\\x07', '\\x08', '\\x09', '\\x0a', '\\x0b', '\\x0c', '\\x0d',\n    '\\x0e', '\\x0f', '\\x10', '\\x11', '\\x12', '\\x13', '\\x14', '\\x15', '\\x16',\n    '\\x17', '\\x18', '\\x19', '\\x1a', '\\x1b', '\\x1c', '\\x1d', '\\x1e', '\\x1f', ' ',\n    '!', '\\\"', '#', '$', '%', '&', '\\'', '(', ')', '*', '+', ',', '-', '.', '/',\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>',\n    '?', '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '[', '\\\\',\n    ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k',\n    'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    '{', '|', '}', '~', '\\x7f' };\n\n  int32_T exitg1;\n  boolean_T guard1 = false;\n  boolean_T guard11 = false;\n  boolean_T guard2 = false;\n  boolean_T guard3 = false;\n  inverse_kinemati_emxInit_char_T(&jtype, 2);\n  inverse_kinematics_B.nmatched = jtype->size[0] * jtype->size[1];\n  jtype->size[0] = 1;\n  jtype->size[1] = obj->NameInternal->size[1];\n  invers_emxEnsureCapacity_char_T(jtype, inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = obj->NameInternal->size[1] - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n    jtype->data[inverse_kinematics_B.nmatched] = obj->NameInternal->\n      data[inverse_kinematics_B.nmatched];\n  }\n\n  newbody = iobj_2;\n  inverse_kinematics_B.nmatched = iobj_2->NameInternal->size[0] *\n    iobj_2->NameInternal->size[1];\n  iobj_2->NameInternal->size[0] = 1;\n  iobj_2->NameInternal->size[1] = jtype->size[1];\n  invers_emxEnsureCapacity_char_T(iobj_2->NameInternal,\n    inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = jtype->size[1] - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n    iobj_2->NameInternal->data[inverse_kinematics_B.nmatched] = jtype->\n      data[inverse_kinematics_B.nmatched];\n  }\n\n  inverse_kinemati_emxInit_char_T(&jname, 2);\n  inverse_kinematics_B.nmatched = jname->size[0] * jname->size[1];\n  jname->size[0] = 1;\n  jname->size[1] = jtype->size[1] + 4;\n  invers_emxEnsureCapacity_char_T(jname, inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = jtype->size[1];\n  if (inverse_kinematics_B.loop_ub_h3 - 1 >= 0) {\n    memcpy(&jname->data[0], &jtype->data[0], inverse_kinematics_B.loop_ub_h3 *\n           sizeof(char_T));\n  }\n\n  jname->data[jtype->size[1]] = '_';\n  jname->data[jtype->size[1] + 1] = 'j';\n  jname->data[jtype->size[1] + 2] = 'n';\n  jname->data[jtype->size[1] + 3] = 't';\n  iobj_2->JointInternal = i_rigidBodyJoint_rigidBodyJoint(&iobj_1[0], jname);\n  iobj_2->Index = -1.0;\n  iobj_2->ParentIndex = -1.0;\n  iobj_2->MassInternal = 1.0;\n  iobj_2->CenterOfMassInternal[0] = 0.0;\n  iobj_2->CenterOfMassInternal[1] = 0.0;\n  iobj_2->CenterOfMassInternal[2] = 0.0;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 9;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.b_I_l[inverse_kinematics_B.minnanb] = 0;\n  }\n\n  inverse_kinematics_B.b_I_l[0] = 1;\n  inverse_kinematics_B.b_I_l[4] = 1;\n  inverse_kinematics_B.b_I_l[8] = 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 9;\n       inverse_kinematics_B.minnanb++) {\n    iobj_2->InertiaInternal[inverse_kinematics_B.minnanb] =\n      inverse_kinematics_B.b_I_l[inverse_kinematics_B.minnanb];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 36;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.msubspace_data_n[inverse_kinematics_B.minnanb] = 0;\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 6;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.msubspace_data_n[inverse_kinematics_B.minnanb + 6 *\n      inverse_kinematics_B.minnanb] = 1;\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 36;\n       inverse_kinematics_B.minnanb++) {\n    iobj_2->SpatialInertia[inverse_kinematics_B.minnanb] =\n      inverse_kinematics_B.msubspace_data_n[inverse_kinematics_B.minnanb];\n  }\n\n  iobj_2->CollisionsInternal = inver_CollisionSet_CollisionSet(&iobj_0[0], 0.0);\n  obj_0 = obj->JointInternal;\n  inverse_kinematics_B.nmatched = jtype->size[0] * jtype->size[1];\n  jtype->size[0] = 1;\n  jtype->size[1] = obj_0->Type->size[1];\n  invers_emxEnsureCapacity_char_T(jtype, inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = obj_0->Type->size[1] - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n    jtype->data[inverse_kinematics_B.nmatched] = obj_0->Type->\n      data[inverse_kinematics_B.nmatched];\n  }\n\n  inverse_kinematics_B.nmatched = jname->size[0] * jname->size[1];\n  jname->size[0] = 1;\n  jname->size[1] = obj_0->NameInternal->size[1];\n  invers_emxEnsureCapacity_char_T(jname, inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = obj_0->NameInternal->size[1] - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n    jname->data[inverse_kinematics_B.nmatched] = obj_0->NameInternal->\n      data[inverse_kinematics_B.nmatched];\n  }\n\n  iobj_1[1].InTree = false;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 16;\n       inverse_kinematics_B.minnanb++) {\n    iobj_1[1].JointToParentTransform[inverse_kinematics_B.minnanb] =\n      tmp[inverse_kinematics_B.minnanb];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 16;\n       inverse_kinematics_B.minnanb++) {\n    iobj_1[1].ChildToJointTransform[inverse_kinematics_B.minnanb] =\n      tmp[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.nmatched = iobj_1[1].NameInternal->size[0] * iobj_1[1].\n    NameInternal->size[1];\n  iobj_1[1].NameInternal->size[0] = 1;\n  iobj_1[1].NameInternal->size[1] = jname->size[1];\n  invers_emxEnsureCapacity_char_T(iobj_1[1].NameInternal,\n    inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = jname->size[1] - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n    iobj_1[1].NameInternal->data[inverse_kinematics_B.nmatched] = jname->\n      data[inverse_kinematics_B.nmatched];\n  }\n\n  inverse_kinemati_emxFree_char_T(&jname);\n  inverse_kinematics_B.partial_match_size_idx_1 = 8;\n  inverse_kinematics_B.nmatched = 0;\n  inverse_kinematics_B.matched = false;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 8;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.partial_match_data[inverse_kinematics_B.minnanb] = ' ';\n    inverse_kinematics_B.vstr[inverse_kinematics_B.minnanb] =\n      tmp_0[inverse_kinematics_B.minnanb];\n  }\n\n  guard1 = false;\n  guard2 = false;\n  guard3 = false;\n  if (jtype->size[1] <= 8) {\n    inverse_kinematics_B.loop_ub_h3 = jtype->size[1];\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 8;\n         inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.b_a[inverse_kinematics_B.minnanb] =\n        tmp_0[inverse_kinematics_B.minnanb];\n    }\n\n    inverse_kinematics_B.b_bool_m = false;\n    inverse_kinematics_B.minnanb = jtype->size[1];\n    guard11 = false;\n    if (inverse_kinematics_B.loop_ub_h3 <= inverse_kinematics_B.minnanb) {\n      if (inverse_kinematics_B.minnanb <= inverse_kinematics_B.loop_ub_h3) {\n        inverse_kinematics_B.loop_ub_h3 = inverse_kinematics_B.minnanb;\n      }\n\n      inverse_kinematics_B.minnanb = inverse_kinematics_B.loop_ub_h3 - 1;\n      guard11 = true;\n    } else if (jtype->size[1] == 8) {\n      inverse_kinematics_B.minnanb = 7;\n      guard11 = true;\n    }\n\n    if (guard11) {\n      inverse_kinematics_B.loop_ub_h3 = 1;\n      do {\n        exitg1 = 0;\n        if (inverse_kinematics_B.loop_ub_h3 - 1 <= inverse_kinematics_B.minnanb)\n        {\n          if (tmp_3[static_cast<uint8_T>(jtype->\n               data[inverse_kinematics_B.loop_ub_h3 - 1]) & 127] != tmp_3[\n              static_cast<int32_T>\n              (inverse_kinematics_B.b_a[inverse_kinematics_B.loop_ub_h3 - 1])])\n          {\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.loop_ub_h3++;\n          }\n        } else {\n          inverse_kinematics_B.b_bool_m = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (inverse_kinematics_B.b_bool_m) {\n      if (jtype->size[1] == 8) {\n        inverse_kinematics_B.nmatched = 1;\n        inverse_kinematics_B.partial_match_size_idx_1 = 8;\n        for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 8;\n             inverse_kinematics_B.minnanb++) {\n          inverse_kinematics_B.b_h[inverse_kinematics_B.minnanb] =\n            inverse_kinematics_B.vstr[inverse_kinematics_B.minnanb];\n        }\n      } else {\n        inverse_kinematics_B.partial_match_size_idx_1 = 8;\n        for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 8;\n             inverse_kinematics_B.minnanb++) {\n          inverse_kinematics_B.partial_match_data[inverse_kinematics_B.minnanb] =\n            inverse_kinematics_B.vstr[inverse_kinematics_B.minnanb];\n        }\n\n        inverse_kinematics_B.matched = true;\n        inverse_kinematics_B.nmatched = 1;\n        guard3 = true;\n      }\n    } else {\n      guard3 = true;\n    }\n  } else {\n    guard3 = true;\n  }\n\n  if (guard3) {\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 9;\n         inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.b_vstr[inverse_kinematics_B.minnanb] =\n        tmp_1[inverse_kinematics_B.minnanb];\n    }\n\n    if (jtype->size[1] <= 9) {\n      inverse_kinematics_B.loop_ub_h3 = jtype->size[1];\n      for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 9;\n           inverse_kinematics_B.minnanb++) {\n        inverse_kinematics_B.b_h[inverse_kinematics_B.minnanb] =\n          tmp_1[inverse_kinematics_B.minnanb];\n      }\n\n      inverse_kinematics_B.b_bool_m = false;\n      inverse_kinematics_B.minnanb = jtype->size[1];\n      guard11 = false;\n      if (inverse_kinematics_B.loop_ub_h3 <= inverse_kinematics_B.minnanb) {\n        if (inverse_kinematics_B.minnanb <= inverse_kinematics_B.loop_ub_h3) {\n          inverse_kinematics_B.loop_ub_h3 = inverse_kinematics_B.minnanb;\n        }\n\n        inverse_kinematics_B.minnanb = inverse_kinematics_B.loop_ub_h3 - 1;\n        guard11 = true;\n      } else if (jtype->size[1] == 9) {\n        inverse_kinematics_B.minnanb = 8;\n        guard11 = true;\n      }\n\n      if (guard11) {\n        inverse_kinematics_B.loop_ub_h3 = 1;\n        do {\n          exitg1 = 0;\n          if (inverse_kinematics_B.loop_ub_h3 - 1 <=\n              inverse_kinematics_B.minnanb) {\n            if (tmp_3[static_cast<uint8_T>(jtype->\n                 data[inverse_kinematics_B.loop_ub_h3 - 1]) & 127] != tmp_3[\n                static_cast<int32_T>\n                (inverse_kinematics_B.b_h[inverse_kinematics_B.loop_ub_h3 - 1])])\n            {\n              exitg1 = 1;\n            } else {\n              inverse_kinematics_B.loop_ub_h3++;\n            }\n          } else {\n            inverse_kinematics_B.b_bool_m = true;\n            exitg1 = 1;\n          }\n        } while (exitg1 == 0);\n      }\n\n      if (inverse_kinematics_B.b_bool_m) {\n        if (jtype->size[1] == 9) {\n          inverse_kinematics_B.nmatched = 1;\n          inverse_kinematics_B.partial_match_size_idx_1 = 9;\n          for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n               9; inverse_kinematics_B.minnanb++) {\n            inverse_kinematics_B.b_h[inverse_kinematics_B.minnanb] =\n              inverse_kinematics_B.b_vstr[inverse_kinematics_B.minnanb];\n          }\n        } else {\n          if (!inverse_kinematics_B.matched) {\n            inverse_kinematics_B.partial_match_size_idx_1 = 9;\n            for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n                 9; inverse_kinematics_B.minnanb++) {\n              inverse_kinematics_B.partial_match_data[inverse_kinematics_B.minnanb]\n                = inverse_kinematics_B.b_vstr[inverse_kinematics_B.minnanb];\n            }\n          }\n\n          inverse_kinematics_B.matched = true;\n          inverse_kinematics_B.nmatched++;\n          guard2 = true;\n        }\n      } else {\n        guard2 = true;\n      }\n    } else {\n      guard2 = true;\n    }\n  }\n\n  if (guard2) {\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 5;\n         inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.c_vstr[inverse_kinematics_B.minnanb] =\n        tmp_2[inverse_kinematics_B.minnanb];\n    }\n\n    if (jtype->size[1] <= 5) {\n      inverse_kinematics_B.loop_ub_h3 = jtype->size[1];\n      for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 5;\n           inverse_kinematics_B.minnanb++) {\n        inverse_kinematics_B.b_ax[inverse_kinematics_B.minnanb] =\n          tmp_2[inverse_kinematics_B.minnanb];\n      }\n\n      inverse_kinematics_B.b_bool_m = false;\n      inverse_kinematics_B.minnanb = jtype->size[1];\n      guard11 = false;\n      if (inverse_kinematics_B.loop_ub_h3 <= inverse_kinematics_B.minnanb) {\n        if (inverse_kinematics_B.minnanb <= inverse_kinematics_B.loop_ub_h3) {\n          inverse_kinematics_B.loop_ub_h3 = inverse_kinematics_B.minnanb;\n        }\n\n        inverse_kinematics_B.minnanb = inverse_kinematics_B.loop_ub_h3 - 1;\n        guard11 = true;\n      } else if (jtype->size[1] == 5) {\n        inverse_kinematics_B.minnanb = 4;\n        guard11 = true;\n      }\n\n      if (guard11) {\n        inverse_kinematics_B.loop_ub_h3 = 1;\n        do {\n          exitg1 = 0;\n          if (inverse_kinematics_B.loop_ub_h3 - 1 <=\n              inverse_kinematics_B.minnanb) {\n            if (tmp_3[static_cast<uint8_T>(jtype->\n                 data[inverse_kinematics_B.loop_ub_h3 - 1]) & 127] != tmp_3[\n                static_cast<int32_T>\n                (inverse_kinematics_B.b_ax[inverse_kinematics_B.loop_ub_h3 - 1])])\n            {\n              exitg1 = 1;\n            } else {\n              inverse_kinematics_B.loop_ub_h3++;\n            }\n          } else {\n            inverse_kinematics_B.b_bool_m = true;\n            exitg1 = 1;\n          }\n        } while (exitg1 == 0);\n      }\n\n      if (inverse_kinematics_B.b_bool_m) {\n        if (jtype->size[1] == 5) {\n          inverse_kinematics_B.nmatched = 1;\n          inverse_kinematics_B.partial_match_size_idx_1 = 5;\n          for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n               5; inverse_kinematics_B.minnanb++) {\n            inverse_kinematics_B.b_h[inverse_kinematics_B.minnanb] =\n              inverse_kinematics_B.c_vstr[inverse_kinematics_B.minnanb];\n          }\n        } else {\n          if (!inverse_kinematics_B.matched) {\n            inverse_kinematics_B.partial_match_size_idx_1 = 5;\n            for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n                 5; inverse_kinematics_B.minnanb++) {\n              inverse_kinematics_B.partial_match_data[inverse_kinematics_B.minnanb]\n                = inverse_kinematics_B.c_vstr[inverse_kinematics_B.minnanb];\n            }\n          }\n\n          inverse_kinematics_B.nmatched++;\n          guard1 = true;\n        }\n      } else {\n        guard1 = true;\n      }\n    } else {\n      guard1 = true;\n    }\n  }\n\n  if (guard1) {\n    if (inverse_kinematics_B.nmatched == 0) {\n      inverse_kinematics_B.partial_match_size_idx_1 = 8;\n      for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 8;\n           inverse_kinematics_B.minnanb++) {\n        inverse_kinematics_B.b_h[inverse_kinematics_B.minnanb] = ' ';\n      }\n    } else {\n      inverse_kinematics_B.loop_ub_h3 =\n        inverse_kinematics_B.partial_match_size_idx_1 - 1;\n      memcpy(&inverse_kinematics_B.b_h[0],\n             &inverse_kinematics_B.partial_match_data[0],\n             (inverse_kinematics_B.loop_ub_h3 + 1) * sizeof(char_T));\n    }\n  }\n\n  if ((inverse_kinematics_B.nmatched == 0) || (jtype->size[1] == 0)) {\n    inverse_kinematics_B.partial_match_size_idx_1 = 8;\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 8;\n         inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.partial_match_data[inverse_kinematics_B.minnanb] =\n        ' ';\n    }\n  } else {\n    inverse_kinematics_B.loop_ub_h3 =\n      inverse_kinematics_B.partial_match_size_idx_1 - 1;\n    memcpy(&inverse_kinematics_B.partial_match_data[0],\n           &inverse_kinematics_B.b_h[0], (inverse_kinematics_B.loop_ub_h3 + 1) *\n           sizeof(char_T));\n  }\n\n  inverse_kinematics_B.nmatched = iobj_1[1].Type->size[0] * iobj_1[1].Type->\n    size[1];\n  iobj_1[1].Type->size[0] = 1;\n  iobj_1[1].Type->size[1] = inverse_kinematics_B.partial_match_size_idx_1;\n  invers_emxEnsureCapacity_char_T(iobj_1[1].Type, inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 =\n    inverse_kinematics_B.partial_match_size_idx_1 - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n    iobj_1[1].Type->data[inverse_kinematics_B.nmatched] =\n      inverse_kinematics_B.partial_match_data[inverse_kinematics_B.nmatched];\n  }\n\n  inverse_kinematics_B.nmatched = jtype->size[0] * jtype->size[1];\n  jtype->size[0] = 1;\n  jtype->size[1] = iobj_1[1].Type->size[1];\n  invers_emxEnsureCapacity_char_T(jtype, inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = iobj_1[1].Type->size[1] - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n    jtype->data[inverse_kinematics_B.nmatched] = iobj_1[1].Type->\n      data[inverse_kinematics_B.nmatched];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 8;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.b_a[inverse_kinematics_B.minnanb] =\n      tmp_0[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.b_bool_m = false;\n  if (jtype->size[1] != 8) {\n  } else {\n    inverse_kinematics_B.loop_ub_h3 = 1;\n    do {\n      exitg1 = 0;\n      if (inverse_kinematics_B.loop_ub_h3 - 1 < 8) {\n        if (jtype->data[inverse_kinematics_B.loop_ub_h3 - 1] !=\n            inverse_kinematics_B.b_a[inverse_kinematics_B.loop_ub_h3 - 1]) {\n          exitg1 = 1;\n        } else {\n          inverse_kinematics_B.loop_ub_h3++;\n        }\n      } else {\n        inverse_kinematics_B.b_bool_m = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (inverse_kinematics_B.b_bool_m) {\n    inverse_kinematics_B.minnanb = 0;\n  } else {\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 9;\n         inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.b_h[inverse_kinematics_B.minnanb] =\n        tmp_1[inverse_kinematics_B.minnanb];\n    }\n\n    inverse_kinematics_B.b_bool_m = false;\n    if (jtype->size[1] != 9) {\n    } else {\n      inverse_kinematics_B.loop_ub_h3 = 1;\n      do {\n        exitg1 = 0;\n        if (inverse_kinematics_B.loop_ub_h3 - 1 < 9) {\n          if (jtype->data[inverse_kinematics_B.loop_ub_h3 - 1] !=\n              inverse_kinematics_B.b_h[inverse_kinematics_B.loop_ub_h3 - 1]) {\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.loop_ub_h3++;\n          }\n        } else {\n          inverse_kinematics_B.b_bool_m = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (inverse_kinematics_B.b_bool_m) {\n      inverse_kinematics_B.minnanb = 1;\n    } else {\n      inverse_kinematics_B.minnanb = -1;\n    }\n  }\n\n  switch (inverse_kinematics_B.minnanb) {\n   case 0:\n    inverse_kinematics_B.iv1[0] = 0;\n    inverse_kinematics_B.iv1[1] = 0;\n    inverse_kinematics_B.iv1[2] = 1;\n    inverse_kinematics_B.iv1[3] = 0;\n    inverse_kinematics_B.iv1[4] = 0;\n    inverse_kinematics_B.iv1[5] = 0;\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 6;\n         inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.msubspace_data_n[inverse_kinematics_B.minnanb] =\n        inverse_kinematics_B.iv1[inverse_kinematics_B.minnanb];\n    }\n\n    inverse_kinematics_B.poslim_data_b[0] = -3.1415926535897931;\n    inverse_kinematics_B.poslim_data_b[1] = 3.1415926535897931;\n    iobj_1[1].VelocityNumber = 1.0;\n    iobj_1[1].PositionNumber = 1.0;\n    iobj_1[1].JointAxisInternal[0] = 0.0;\n    iobj_1[1].JointAxisInternal[1] = 0.0;\n    iobj_1[1].JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    inverse_kinematics_B.iv1[0] = 0;\n    inverse_kinematics_B.iv1[1] = 0;\n    inverse_kinematics_B.iv1[2] = 0;\n    inverse_kinematics_B.iv1[3] = 0;\n    inverse_kinematics_B.iv1[4] = 0;\n    inverse_kinematics_B.iv1[5] = 1;\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 6;\n         inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.msubspace_data_n[inverse_kinematics_B.minnanb] =\n        inverse_kinematics_B.iv1[inverse_kinematics_B.minnanb];\n    }\n\n    inverse_kinematics_B.poslim_data_b[0] = -0.5;\n    inverse_kinematics_B.poslim_data_b[1] = 0.5;\n    iobj_1[1].VelocityNumber = 1.0;\n    iobj_1[1].PositionNumber = 1.0;\n    iobj_1[1].JointAxisInternal[0] = 0.0;\n    iobj_1[1].JointAxisInternal[1] = 0.0;\n    iobj_1[1].JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 6;\n         inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.msubspace_data_n[inverse_kinematics_B.minnanb] = 0;\n    }\n\n    inverse_kinematics_B.poslim_data_b[0] = 0.0;\n    inverse_kinematics_B.poslim_data_b[1] = 0.0;\n    iobj_1[1].VelocityNumber = 0.0;\n    iobj_1[1].PositionNumber = 0.0;\n    iobj_1[1].JointAxisInternal[0] = 0.0;\n    iobj_1[1].JointAxisInternal[1] = 0.0;\n    iobj_1[1].JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  inverse_kinematics_B.nmatched = iobj_1[1].MotionSubspace->size[0] * iobj_1[1].\n    MotionSubspace->size[1];\n  iobj_1[1].MotionSubspace->size[0] = 6;\n  iobj_1[1].MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1[1].MotionSubspace,\n    inverse_kinematics_B.nmatched);\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 6;\n       inverse_kinematics_B.minnanb++) {\n    iobj_1[1].MotionSubspace->data[inverse_kinematics_B.minnanb] =\n      inverse_kinematics_B.msubspace_data_n[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.nmatched = iobj_1[1].PositionLimitsInternal->size[0] *\n    iobj_1[1].PositionLimitsInternal->size[1];\n  iobj_1[1].PositionLimitsInternal->size[0] = 1;\n  iobj_1[1].PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1[1].PositionLimitsInternal,\n    inverse_kinematics_B.nmatched);\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 2;\n       inverse_kinematics_B.minnanb++) {\n    iobj_1[1].PositionLimitsInternal->data[inverse_kinematics_B.minnanb] =\n      inverse_kinematics_B.poslim_data_b[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.nmatched = iobj_1[1].HomePositionInternal->size[0];\n  iobj_1[1].HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_1[1].HomePositionInternal,\n    inverse_kinematics_B.nmatched);\n  iobj_1[1].HomePositionInternal->data[0] = 0.0;\n  inverse_kinematics_B.nmatched = jtype->size[0] * jtype->size[1];\n  jtype->size[0] = 1;\n  jtype->size[1] = obj_0->NameInternal->size[1];\n  invers_emxEnsureCapacity_char_T(jtype, inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = obj_0->NameInternal->size[1] - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n    jtype->data[inverse_kinematics_B.nmatched] = obj_0->NameInternal->\n      data[inverse_kinematics_B.nmatched];\n  }\n\n  if (jtype->size[1] != 0) {\n    inverse_kinematics_B.nmatched = jtype->size[0] * jtype->size[1];\n    jtype->size[0] = 1;\n    jtype->size[1] = obj_0->NameInternal->size[1];\n    invers_emxEnsureCapacity_char_T(jtype, inverse_kinematics_B.nmatched);\n    inverse_kinematics_B.loop_ub_h3 = obj_0->NameInternal->size[1] - 1;\n    for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n         inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n      inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n      jtype->data[inverse_kinematics_B.nmatched] = obj_0->NameInternal->\n        data[inverse_kinematics_B.nmatched];\n    }\n\n    if (!iobj_1[1].InTree) {\n      inverse_kinematics_B.nmatched = iobj_1[1].NameInternal->size[0] * iobj_1[1]\n        .NameInternal->size[1];\n      iobj_1[1].NameInternal->size[0] = 1;\n      iobj_1[1].NameInternal->size[1] = jtype->size[1];\n      invers_emxEnsureCapacity_char_T(iobj_1[1].NameInternal,\n        inverse_kinematics_B.nmatched);\n      inverse_kinematics_B.loop_ub_h3 = jtype->size[1] - 1;\n      for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n           inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n        inverse_kinematics_B.nmatched = inverse_kinematics_B.minnanb;\n        iobj_1[1].NameInternal->data[inverse_kinematics_B.nmatched] =\n          jtype->data[inverse_kinematics_B.nmatched];\n      }\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&jtype);\n  inverse_kinemati_emxInit_real_T(&obj_3, 1);\n  inverse_kinematics_B.loop_ub_h3 = obj_0->PositionLimitsInternal->size[0] << 1;\n  inverse_kinematics_B.nmatched = iobj_1[1].PositionLimitsInternal->size[0] *\n    iobj_1[1].PositionLimitsInternal->size[1];\n  iobj_1[1].PositionLimitsInternal->size[0] = obj_0->\n    PositionLimitsInternal->size[0];\n  iobj_1[1].PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_1[1].PositionLimitsInternal,\n    inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.nmatched = obj_3->size[0];\n  obj_3->size[0] = inverse_kinematics_B.loop_ub_h3;\n  invers_emxEnsureCapacity_real_T(obj_3, inverse_kinematics_B.nmatched);\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    obj_3->data[inverse_kinematics_B.minnanb] = obj_0->\n      PositionLimitsInternal->data[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.loop_ub_h3 = obj_3->size[0];\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    iobj_1[1].PositionLimitsInternal->data[inverse_kinematics_B.minnanb] =\n      obj_3->data[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.nmatched = obj_3->size[0];\n  obj_3->size[0] = obj_0->HomePositionInternal->size[0];\n  invers_emxEnsureCapacity_real_T(obj_3, inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = obj_0->HomePositionInternal->size[0];\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    obj_3->data[inverse_kinematics_B.minnanb] = obj_0->\n      HomePositionInternal->data[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.nmatched = iobj_1[1].HomePositionInternal->size[0];\n  iobj_1[1].HomePositionInternal->size[0] = obj_3->size[0];\n  invers_emxEnsureCapacity_real_T(iobj_1[1].HomePositionInternal,\n    inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.loop_ub_h3 = obj_3->size[0];\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    iobj_1[1].HomePositionInternal->data[inverse_kinematics_B.minnanb] =\n      obj_3->data[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.obj_idx_0 = obj_0->JointAxisInternal[0];\n  inverse_kinematics_B.obj_idx_1 = obj_0->JointAxisInternal[1];\n  inverse_kinematics_B.obj_idx_2 = obj_0->JointAxisInternal[2];\n  iobj_1[1].JointAxisInternal[0] = inverse_kinematics_B.obj_idx_0;\n  iobj_1[1].JointAxisInternal[1] = inverse_kinematics_B.obj_idx_1;\n  iobj_1[1].JointAxisInternal[2] = inverse_kinematics_B.obj_idx_2;\n  inverse_kinematics_B.loop_ub_h3 = 6 * obj_0->MotionSubspace->size[1];\n  inverse_kinematics_B.nmatched = iobj_1[1].MotionSubspace->size[0] * iobj_1[1].\n    MotionSubspace->size[1];\n  iobj_1[1].MotionSubspace->size[0] = 6;\n  iobj_1[1].MotionSubspace->size[1] = obj_0->MotionSubspace->size[1];\n  invers_emxEnsureCapacity_real_T(iobj_1[1].MotionSubspace,\n    inverse_kinematics_B.nmatched);\n  inverse_kinematics_B.nmatched = obj_3->size[0];\n  obj_3->size[0] = inverse_kinematics_B.loop_ub_h3;\n  invers_emxEnsureCapacity_real_T(obj_3, inverse_kinematics_B.nmatched);\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    obj_3->data[inverse_kinematics_B.minnanb] = obj_0->MotionSubspace->\n      data[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinematics_B.loop_ub_h3 = obj_3->size[0];\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <\n       inverse_kinematics_B.loop_ub_h3; inverse_kinematics_B.minnanb++) {\n    iobj_1[1].MotionSubspace->data[inverse_kinematics_B.minnanb] = obj_3->\n      data[inverse_kinematics_B.minnanb];\n  }\n\n  inverse_kinemati_emxFree_real_T(&obj_3);\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 16;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.obj_c[inverse_kinematics_B.minnanb] =\n      obj_0->JointToParentTransform[inverse_kinematics_B.minnanb];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 16;\n       inverse_kinematics_B.minnanb++) {\n    iobj_1[1].JointToParentTransform[inverse_kinematics_B.minnanb] =\n      inverse_kinematics_B.obj_c[inverse_kinematics_B.minnanb];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 16;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.obj_c[inverse_kinematics_B.minnanb] =\n      obj_0->ChildToJointTransform[inverse_kinematics_B.minnanb];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 16;\n       inverse_kinematics_B.minnanb++) {\n    iobj_1[1].ChildToJointTransform[inverse_kinematics_B.minnanb] =\n      inverse_kinematics_B.obj_c[inverse_kinematics_B.minnanb];\n  }\n\n  iobj_2->JointInternal = &iobj_1[1];\n  iobj_2->MassInternal = obj->MassInternal;\n  inverse_kinematics_B.obj_idx_0 = obj->CenterOfMassInternal[0];\n  inverse_kinematics_B.obj_idx_1 = obj->CenterOfMassInternal[1];\n  inverse_kinematics_B.obj_idx_2 = obj->CenterOfMassInternal[2];\n  iobj_2->CenterOfMassInternal[0] = inverse_kinematics_B.obj_idx_0;\n  iobj_2->CenterOfMassInternal[1] = inverse_kinematics_B.obj_idx_1;\n  iobj_2->CenterOfMassInternal[2] = inverse_kinematics_B.obj_idx_2;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 9;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.obj_g[inverse_kinematics_B.minnanb] =\n      obj->InertiaInternal[inverse_kinematics_B.minnanb];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 9;\n       inverse_kinematics_B.minnanb++) {\n    iobj_2->InertiaInternal[inverse_kinematics_B.minnanb] =\n      inverse_kinematics_B.obj_g[inverse_kinematics_B.minnanb];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 36;\n       inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.obj[inverse_kinematics_B.minnanb] = obj->\n      SpatialInertia[inverse_kinematics_B.minnanb];\n  }\n\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb < 36;\n       inverse_kinematics_B.minnanb++) {\n    iobj_2->SpatialInertia[inverse_kinematics_B.minnanb] =\n      inverse_kinematics_B.obj[inverse_kinematics_B.minnanb];\n  }\n\n  obj_1 = obj->CollisionsInternal;\n  newObj = inver_CollisionSet_CollisionSet(&iobj_0[1], obj_1->MaxElements);\n  newObj->Size = obj_1->Size;\n  inverse_kinematics_B.obj_idx_0 = obj_1->Size;\n  inverse_kinematics_B.nmatched = static_cast<int32_T>\n    (inverse_kinematics_B.obj_idx_0) - 1;\n  for (inverse_kinematics_B.minnanb = 0; inverse_kinematics_B.minnanb <=\n       inverse_kinematics_B.nmatched; inverse_kinematics_B.minnanb++) {\n    inverse_kinematics_B.loop_ub_h3 = inverse_kinematics_B.minnanb;\n    obj_2 = obj_1->CollisionGeometries->data[inverse_kinematics_B.loop_ub_h3];\n    newObj->CollisionGeometries->data[inverse_kinematics_B.loop_ub_h3] = obj_2;\n  }\n\n  iobj_2->CollisionsInternal = newObj;\n  return newbody;\n}\n\nstatic void inverse_k_RigidBodyTree_addBody(v_robotics_manip_internal_Rig_T *obj,\n  t_robotics_manip_internal_Rig_T *bodyin, const emxArray_char_T_inverse_kinem_T\n  *parentName, c_rigidBodyJoint_inverse_kine_T *iobj_0,\n  t_robotics_manip_internal_Rig_T *iobj_1, l_robotics_manip_internal_Col_T\n  *iobj_2)\n{\n  c_rigidBodyJoint_inverse_kine_T *jnt;\n  emxArray_char_T_inverse_kinem_T *bname;\n  t_robotics_manip_internal_Rig_T *body;\n  static const char_T tmp[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  inverse_kinemati_emxInit_char_T(&bname, 2);\n  inverse_kinematics_B.i1 = bname->size[0] * bname->size[1];\n  bname->size[0] = 1;\n  bname->size[1] = bodyin->NameInternal->size[1];\n  invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.i1);\n  inverse_kinematics_B.loop_ub_mc = bodyin->NameInternal->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr_m = 0; inverse_kinematics_B.b_kstr_m <=\n       inverse_kinematics_B.loop_ub_mc; inverse_kinematics_B.b_kstr_m++) {\n    inverse_kinematics_B.i1 = inverse_kinematics_B.b_kstr_m;\n    bname->data[inverse_kinematics_B.i1] = bodyin->NameInternal->\n      data[inverse_kinematics_B.i1];\n  }\n\n  RigidBodyTree_findBodyIndexByNa(obj, bname);\n  inverse_kinematics_B.pid = RigidBodyTree_findBodyIndexByNa(obj, parentName);\n  inverse_kinematics_B.b_index = obj->NumBodies + 1.0;\n  body = inverse_kinemati_RigidBody_copy(bodyin, &iobj_2[0], &iobj_0[0], iobj_1);\n  obj->Bodies[static_cast<int32_T>(inverse_kinematics_B.b_index) - 1] = body;\n  body->Index = inverse_kinematics_B.b_index;\n  body->ParentIndex = inverse_kinematics_B.pid;\n  body->JointInternal->InTree = true;\n  obj->NumBodies++;\n  jnt = body->JointInternal;\n  inverse_kinematics_B.i1 = bname->size[0] * bname->size[1];\n  bname->size[0] = 1;\n  bname->size[1] = jnt->Type->size[1];\n  invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.i1);\n  inverse_kinematics_B.loop_ub_mc = jnt->Type->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr_m = 0; inverse_kinematics_B.b_kstr_m <=\n       inverse_kinematics_B.loop_ub_mc; inverse_kinematics_B.b_kstr_m++) {\n    inverse_kinematics_B.i1 = inverse_kinematics_B.b_kstr_m;\n    bname->data[inverse_kinematics_B.i1] = jnt->Type->\n      data[inverse_kinematics_B.i1];\n  }\n\n  for (inverse_kinematics_B.b_kstr_m = 0; inverse_kinematics_B.b_kstr_m < 5;\n       inverse_kinematics_B.b_kstr_m++) {\n    inverse_kinematics_B.b_e[inverse_kinematics_B.b_kstr_m] =\n      tmp[inverse_kinematics_B.b_kstr_m];\n  }\n\n  inverse_kinematics_B.b_bool_h = false;\n  if (bname->size[1] != 5) {\n  } else {\n    inverse_kinematics_B.b_kstr_m = 1;\n    int32_T exitg1;\n    do {\n      exitg1 = 0;\n      if (inverse_kinematics_B.b_kstr_m - 1 < 5) {\n        if (bname->data[inverse_kinematics_B.b_kstr_m - 1] !=\n            inverse_kinematics_B.b_e[inverse_kinematics_B.b_kstr_m - 1]) {\n          exitg1 = 1;\n        } else {\n          inverse_kinematics_B.b_kstr_m++;\n        }\n      } else {\n        inverse_kinematics_B.b_bool_h = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  inverse_kinemati_emxFree_char_T(&bname);\n  if (!inverse_kinematics_B.b_bool_h) {\n    obj->NumNonFixedBodies++;\n    jnt = body->JointInternal;\n    inverse_kinematics_B.b_kstr_m = static_cast<int32_T>(body->Index) - 1;\n    obj->PositionDoFMap[inverse_kinematics_B.b_kstr_m] = obj->PositionNumber +\n      1.0;\n    obj->PositionDoFMap[inverse_kinematics_B.b_kstr_m + 6] = obj->PositionNumber\n      + jnt->PositionNumber;\n    jnt = body->JointInternal;\n    inverse_kinematics_B.b_kstr_m = static_cast<int32_T>(body->Index) - 1;\n    obj->VelocityDoFMap[inverse_kinematics_B.b_kstr_m] = obj->VelocityNumber +\n      1.0;\n    obj->VelocityDoFMap[inverse_kinematics_B.b_kstr_m + 6] = obj->VelocityNumber\n      + jnt->VelocityNumber;\n  } else {\n    inverse_kinematics_B.b_kstr_m = static_cast<int32_T>(body->Index);\n    obj->PositionDoFMap[inverse_kinematics_B.b_kstr_m - 1] = 0.0;\n    obj->PositionDoFMap[inverse_kinematics_B.b_kstr_m + 5] = -1.0;\n    inverse_kinematics_B.b_kstr_m = static_cast<int32_T>(body->Index);\n    obj->VelocityDoFMap[inverse_kinematics_B.b_kstr_m - 1] = 0.0;\n    obj->VelocityDoFMap[inverse_kinematics_B.b_kstr_m + 5] = -1.0;\n  }\n\n  jnt = body->JointInternal;\n  obj->PositionNumber += jnt->PositionNumber;\n  jnt = body->JointInternal;\n  obj->VelocityNumber += jnt->VelocityNumber;\n}\n\nstatic void inverseKinematics_set_RigidBody(b_inverseKinematics_inverse_k_T *obj,\n  u_robotics_manip_internal_Rig_T *rigidbodytree,\n  c_rigidBodyJoint_inverse_kine_T *iobj_0, t_robotics_manip_internal_Rig_T\n  *iobj_1, l_robotics_manip_internal_Col_T *iobj_2,\n  v_robotics_manip_internal_Rig_T *iobj_3)\n{\n  c_rigidBodyJoint_inverse_kine_T *iobj_1_0;\n  emxArray_char_T_inverse_kinem_T *bname;\n  emxArray_char_T_inverse_kinem_T *switch_expression;\n  k_robotics_manip_internal_Col_T *obj_0;\n  l_robotics_manip_internal_Col_T *iobj_0_0;\n  l_robotics_manip_internal_Col_T *newObj;\n  t_robotics_manip_internal_Rig_T *body;\n  t_robotics_manip_internal_Rig_T *parent;\n  static const int8_T tmp[16] = { 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1\n  };\n\n  static const char_T tmp_0[8] = { 'b', 'a', 's', 'e', '_', 'j', 'n', 't' };\n\n  static const char_T tmp_1[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_2[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_3[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  body = &iobj_3->Base;\n  iobj_0_0 = &iobj_3->_pobj1[0];\n  inverse_kinematics_B.obj_tmp = body->NameInternal->size[0] *\n    body->NameInternal->size[1];\n  body->NameInternal->size[0] = 1;\n  body->NameInternal->size[1] = 4;\n  invers_emxEnsureCapacity_char_T(body->NameInternal,\n    inverse_kinematics_B.obj_tmp);\n  body->NameInternal->data[0] = 'b';\n  body->NameInternal->data[1] = 'a';\n  body->NameInternal->data[2] = 's';\n  body->NameInternal->data[3] = 'e';\n  iobj_3->_pobj2[0].InTree = false;\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 16;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->_pobj2[0].JointToParentTransform[inverse_kinematics_B.b_kstr] =\n      tmp[inverse_kinematics_B.b_kstr];\n  }\n\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 16;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->_pobj2[0].ChildToJointTransform[inverse_kinematics_B.b_kstr] =\n      tmp[inverse_kinematics_B.b_kstr];\n  }\n\n  inverse_kinematics_B.obj_tmp = iobj_3->_pobj2[0].NameInternal->size[0] *\n    iobj_3->_pobj2[0].NameInternal->size[1];\n  iobj_3->_pobj2[0].NameInternal->size[0] = 1;\n  iobj_3->_pobj2[0].NameInternal->size[1] = 8;\n  invers_emxEnsureCapacity_char_T(iobj_3->_pobj2[0].NameInternal,\n    inverse_kinematics_B.obj_tmp);\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 8;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->_pobj2[0].NameInternal->data[inverse_kinematics_B.b_kstr] =\n      tmp_0[inverse_kinematics_B.b_kstr];\n  }\n\n  inverse_kinematics_B.obj_tmp = iobj_3->_pobj2[0].Type->size[0] *\n    iobj_3->_pobj2[0].Type->size[1];\n  iobj_3->_pobj2[0].Type->size[0] = 1;\n  iobj_3->_pobj2[0].Type->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(iobj_3->_pobj2[0].Type,\n    inverse_kinematics_B.obj_tmp);\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 5;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->_pobj2[0].Type->data[inverse_kinematics_B.b_kstr] =\n      tmp_1[inverse_kinematics_B.b_kstr];\n  }\n\n  inverse_kinemati_emxInit_char_T(&switch_expression, 2);\n  inverse_kinematics_B.obj_tmp = switch_expression->size[0] *\n    switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = iobj_3->_pobj2[0].Type->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression,\n    inverse_kinematics_B.obj_tmp);\n  inverse_kinematics_B.loop_ub_h = iobj_3->_pobj2[0].Type->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n       inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n    inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n    switch_expression->data[inverse_kinematics_B.obj_tmp] = iobj_3->_pobj2[0].\n      Type->data[inverse_kinematics_B.obj_tmp];\n  }\n\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 8;\n       inverse_kinematics_B.b_kstr++) {\n    inverse_kinematics_B.b_f[inverse_kinematics_B.b_kstr] =\n      tmp_2[inverse_kinematics_B.b_kstr];\n  }\n\n  inverse_kinematics_B.b_bool_f = false;\n  if (switch_expression->size[1] != 8) {\n  } else {\n    inverse_kinematics_B.b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (inverse_kinematics_B.b_kstr - 1 < 8) {\n        if (switch_expression->data[inverse_kinematics_B.b_kstr - 1] !=\n            inverse_kinematics_B.b_f[inverse_kinematics_B.b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          inverse_kinematics_B.b_kstr++;\n        }\n      } else {\n        inverse_kinematics_B.b_bool_f = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  if (inverse_kinematics_B.b_bool_f) {\n    inverse_kinematics_B.b_kstr = 0;\n  } else {\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 9;\n         inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.b_b[inverse_kinematics_B.b_kstr] =\n        tmp_3[inverse_kinematics_B.b_kstr];\n    }\n\n    inverse_kinematics_B.b_bool_f = false;\n    if (switch_expression->size[1] != 9) {\n    } else {\n      inverse_kinematics_B.b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (inverse_kinematics_B.b_kstr - 1 < 9) {\n          if (switch_expression->data[inverse_kinematics_B.b_kstr - 1] !=\n              inverse_kinematics_B.b_b[inverse_kinematics_B.b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.b_kstr++;\n          }\n        } else {\n          inverse_kinematics_B.b_bool_f = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (inverse_kinematics_B.b_bool_f) {\n      inverse_kinematics_B.b_kstr = 1;\n    } else {\n      inverse_kinematics_B.b_kstr = -1;\n    }\n  }\n\n  switch (inverse_kinematics_B.b_kstr) {\n   case 0:\n    inverse_kinematics_B.iv[0] = 0;\n    inverse_kinematics_B.iv[1] = 0;\n    inverse_kinematics_B.iv[2] = 1;\n    inverse_kinematics_B.iv[3] = 0;\n    inverse_kinematics_B.iv[4] = 0;\n    inverse_kinematics_B.iv[5] = 0;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n         inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.msubspace_data[inverse_kinematics_B.b_kstr] =\n        inverse_kinematics_B.iv[inverse_kinematics_B.b_kstr];\n    }\n\n    inverse_kinematics_B.poslim_data[0] = -3.1415926535897931;\n    inverse_kinematics_B.poslim_data[1] = 3.1415926535897931;\n    iobj_3->_pobj2[0].VelocityNumber = 1.0;\n    iobj_3->_pobj2[0].PositionNumber = 1.0;\n    iobj_3->_pobj2[0].JointAxisInternal[0] = 0.0;\n    iobj_3->_pobj2[0].JointAxisInternal[1] = 0.0;\n    iobj_3->_pobj2[0].JointAxisInternal[2] = 1.0;\n    break;\n\n   case 1:\n    inverse_kinematics_B.iv[0] = 0;\n    inverse_kinematics_B.iv[1] = 0;\n    inverse_kinematics_B.iv[2] = 0;\n    inverse_kinematics_B.iv[3] = 0;\n    inverse_kinematics_B.iv[4] = 0;\n    inverse_kinematics_B.iv[5] = 1;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n         inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.msubspace_data[inverse_kinematics_B.b_kstr] =\n        inverse_kinematics_B.iv[inverse_kinematics_B.b_kstr];\n    }\n\n    inverse_kinematics_B.poslim_data[0] = -0.5;\n    inverse_kinematics_B.poslim_data[1] = 0.5;\n    iobj_3->_pobj2[0].VelocityNumber = 1.0;\n    iobj_3->_pobj2[0].PositionNumber = 1.0;\n    iobj_3->_pobj2[0].JointAxisInternal[0] = 0.0;\n    iobj_3->_pobj2[0].JointAxisInternal[1] = 0.0;\n    iobj_3->_pobj2[0].JointAxisInternal[2] = 1.0;\n    break;\n\n   default:\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n         inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.msubspace_data[inverse_kinematics_B.b_kstr] = 0;\n    }\n\n    inverse_kinematics_B.poslim_data[0] = 0.0;\n    inverse_kinematics_B.poslim_data[1] = 0.0;\n    iobj_3->_pobj2[0].VelocityNumber = 0.0;\n    iobj_3->_pobj2[0].PositionNumber = 0.0;\n    iobj_3->_pobj2[0].JointAxisInternal[0] = 0.0;\n    iobj_3->_pobj2[0].JointAxisInternal[1] = 0.0;\n    iobj_3->_pobj2[0].JointAxisInternal[2] = 0.0;\n    break;\n  }\n\n  inverse_kinematics_B.obj_tmp = iobj_3->_pobj2[0].MotionSubspace->size[0] *\n    iobj_3->_pobj2[0].MotionSubspace->size[1];\n  iobj_3->_pobj2[0].MotionSubspace->size[0] = 6;\n  iobj_3->_pobj2[0].MotionSubspace->size[1] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_3->_pobj2[0].MotionSubspace,\n    inverse_kinematics_B.obj_tmp);\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->_pobj2[0].MotionSubspace->data[inverse_kinematics_B.b_kstr] =\n      inverse_kinematics_B.msubspace_data[inverse_kinematics_B.b_kstr];\n  }\n\n  inverse_kinematics_B.obj_tmp = iobj_3->_pobj2[0].PositionLimitsInternal->size\n    [0] * iobj_3->_pobj2[0].PositionLimitsInternal->size[1];\n  iobj_3->_pobj2[0].PositionLimitsInternal->size[0] = 1;\n  iobj_3->_pobj2[0].PositionLimitsInternal->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(iobj_3->_pobj2[0].PositionLimitsInternal,\n    inverse_kinematics_B.obj_tmp);\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 2;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->_pobj2[0].PositionLimitsInternal->data[inverse_kinematics_B.b_kstr] =\n      inverse_kinematics_B.poslim_data[inverse_kinematics_B.b_kstr];\n  }\n\n  inverse_kinematics_B.obj_tmp = iobj_3->_pobj2[0].HomePositionInternal->size[0];\n  iobj_3->_pobj2[0].HomePositionInternal->size[0] = 1;\n  invers_emxEnsureCapacity_real_T(iobj_3->_pobj2[0].HomePositionInternal,\n    inverse_kinematics_B.obj_tmp);\n  iobj_3->_pobj2[0].HomePositionInternal->data[0] = 0.0;\n  body->JointInternal = &iobj_3->_pobj2[0];\n  body->Index = -1.0;\n  body->ParentIndex = -1.0;\n  body->MassInternal = 1.0;\n  body->CenterOfMassInternal[0] = 0.0;\n  body->CenterOfMassInternal[1] = 0.0;\n  body->CenterOfMassInternal[2] = 0.0;\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 9;\n       inverse_kinematics_B.b_kstr++) {\n    inverse_kinematics_B.b_I_n[inverse_kinematics_B.b_kstr] = 0;\n  }\n\n  inverse_kinematics_B.b_I_n[0] = 1;\n  inverse_kinematics_B.b_I_n[4] = 1;\n  inverse_kinematics_B.b_I_n[8] = 1;\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 9;\n       inverse_kinematics_B.b_kstr++) {\n    body->InertiaInternal[inverse_kinematics_B.b_kstr] =\n      inverse_kinematics_B.b_I_n[inverse_kinematics_B.b_kstr];\n  }\n\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 36;\n       inverse_kinematics_B.b_kstr++) {\n    inverse_kinematics_B.msubspace_data[inverse_kinematics_B.b_kstr] = 0;\n  }\n\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n       inverse_kinematics_B.b_kstr++) {\n    inverse_kinematics_B.msubspace_data[inverse_kinematics_B.b_kstr + 6 *\n      inverse_kinematics_B.b_kstr] = 1;\n  }\n\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 36;\n       inverse_kinematics_B.b_kstr++) {\n    body->SpatialInertia[inverse_kinematics_B.b_kstr] =\n      inverse_kinematics_B.msubspace_data[inverse_kinematics_B.b_kstr];\n  }\n\n  body->CollisionsInternal = inver_CollisionSet_CollisionSet(iobj_0_0, 0.0);\n  iobj_3->Base.Index = 0.0;\n  inverse_kinematics_rand(inverse_kinematics_B.unusedExpr);\n  iobj_0_0 = &iobj_3->_pobj1[1];\n  iobj_1_0 = &iobj_3->_pobj2[1];\n  body = &iobj_3->_pobj0[0];\n  iobj_3->Bodies[0] = inverse_kin_RigidBody_RigidBody(&(&(&iobj_3->_pobj0[0])[0])\n    [0], &(&iobj_0_0[0])[0], &(&iobj_1_0[0])[0]);\n  iobj_3->Bodies[1] = inverse_k_RigidBody_RigidBody_g(&(&body[0])[1],\n    &(&iobj_0_0[0])[1], &(&iobj_1_0[0])[1]);\n  iobj_3->Bodies[2] = inverse__RigidBody_RigidBody_ga(&(&body[0])[2],\n    &(&iobj_0_0[0])[2], &(&iobj_1_0[0])[2]);\n  iobj_3->Bodies[3] = inverse_RigidBody_RigidBody_gaq(&(&body[0])[3],\n    &(&iobj_0_0[0])[3], &(&iobj_1_0[0])[3]);\n  iobj_3->Bodies[4] = invers_RigidBody_RigidBody_gaqy(&(&body[0])[4],\n    &(&iobj_0_0[0])[4], &(&iobj_1_0[0])[4]);\n  iobj_3->Bodies[5] = inver_RigidBody_RigidBody_gaqyy(&(&body[0])[5],\n    &(&iobj_0_0[0])[5], &(&iobj_1_0[0])[5]);\n  iobj_3->NumBodies = 0.0;\n  iobj_3->NumNonFixedBodies = 0.0;\n  iobj_3->PositionNumber = 0.0;\n  iobj_3->VelocityNumber = 0.0;\n  inverse_kinematics_rand(inverse_kinematics_B.unusedExpr);\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->PositionDoFMap[inverse_kinematics_B.b_kstr] = 0.0;\n  }\n\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->PositionDoFMap[inverse_kinematics_B.b_kstr + 6] = -1.0;\n  }\n\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->VelocityDoFMap[inverse_kinematics_B.b_kstr] = 0.0;\n  }\n\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr < 6;\n       inverse_kinematics_B.b_kstr++) {\n    iobj_3->VelocityDoFMap[inverse_kinematics_B.b_kstr + 6] = -1.0;\n  }\n\n  inverse_kinematics_B.obj_tmp = switch_expression->size[0] *\n    switch_expression->size[1];\n  switch_expression->size[0] = 1;\n  switch_expression->size[1] = rigidbodytree->Base.NameInternal->size[1];\n  invers_emxEnsureCapacity_char_T(switch_expression,\n    inverse_kinematics_B.obj_tmp);\n  inverse_kinematics_B.loop_ub_h = rigidbodytree->Base.NameInternal->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n       inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n    inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n    switch_expression->data[inverse_kinematics_B.obj_tmp] =\n      rigidbodytree->Base.NameInternal->data[inverse_kinematics_B.obj_tmp];\n  }\n\n  inverse_kinemati_emxInit_char_T(&bname, 2);\n  inverse_kinematics_B.bid_m = -1.0;\n  inverse_kinematics_B.obj_tmp = bname->size[0] * bname->size[1];\n  bname->size[0] = 1;\n  bname->size[1] = iobj_3->Base.NameInternal->size[1];\n  invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.obj_tmp);\n  inverse_kinematics_B.loop_ub_h = iobj_3->Base.NameInternal->size[1] - 1;\n  for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n       inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n    inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n    bname->data[inverse_kinematics_B.obj_tmp] = iobj_3->Base.NameInternal->\n      data[inverse_kinematics_B.obj_tmp];\n  }\n\n  if (inverse_kinematics_strcmp(bname, switch_expression)) {\n    inverse_kinematics_B.bid_m = 0.0;\n  } else {\n    boolean_T exitg2;\n    inverse_kinematics_B.b_m = iobj_3->NumBodies;\n    inverse_kinematics_B.iobj_3 = 0;\n    exitg2 = false;\n    while ((!exitg2) && (inverse_kinematics_B.iobj_3 <= static_cast<int32_T>\n                         (inverse_kinematics_B.b_m) - 1)) {\n      body = iobj_3->Bodies[inverse_kinematics_B.iobj_3];\n      inverse_kinematics_B.obj_tmp = bname->size[0] * bname->size[1];\n      bname->size[0] = 1;\n      bname->size[1] = body->NameInternal->size[1];\n      invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.obj_tmp);\n      inverse_kinematics_B.loop_ub_h = body->NameInternal->size[1] - 1;\n      for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n           inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n        inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n        bname->data[inverse_kinematics_B.obj_tmp] = body->NameInternal->\n          data[inverse_kinematics_B.obj_tmp];\n      }\n\n      if (inverse_kinematics_strcmp(bname, switch_expression)) {\n        inverse_kinematics_B.bid_m = static_cast<real_T>\n          (inverse_kinematics_B.iobj_3) + 1.0;\n        exitg2 = true;\n      } else {\n        inverse_kinematics_B.iobj_3++;\n      }\n    }\n  }\n\n  if ((!(inverse_kinematics_B.bid_m == 0.0)) && (inverse_kinematics_B.bid_m <\n       0.0)) {\n    inverse_kinematics_B.obj_tmp = iobj_3->Base.NameInternal->size[0] *\n      iobj_3->Base.NameInternal->size[1];\n    iobj_3->Base.NameInternal->size[0] = 1;\n    iobj_3->Base.NameInternal->size[1] = switch_expression->size[1];\n    invers_emxEnsureCapacity_char_T(iobj_3->Base.NameInternal,\n      inverse_kinematics_B.obj_tmp);\n    inverse_kinematics_B.loop_ub_h = switch_expression->size[1] - 1;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n         inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n      iobj_3->Base.NameInternal->data[inverse_kinematics_B.obj_tmp] =\n        switch_expression->data[inverse_kinematics_B.obj_tmp];\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&switch_expression);\n  iobj_0_0 = rigidbodytree->Base.CollisionsInternal;\n  newObj = inver_CollisionSet_CollisionSet(&(&iobj_2[0])[0],\n    iobj_0_0->MaxElements);\n  newObj->Size = iobj_0_0->Size;\n  inverse_kinematics_B.b_m = iobj_0_0->Size;\n  inverse_kinematics_B.b_kstr = static_cast<int32_T>(inverse_kinematics_B.b_m) -\n    1;\n  for (inverse_kinematics_B.iobj_3 = 0; inverse_kinematics_B.iobj_3 <=\n       inverse_kinematics_B.b_kstr; inverse_kinematics_B.iobj_3++) {\n    inverse_kinematics_B.obj_tmp = inverse_kinematics_B.iobj_3;\n    obj_0 = iobj_0_0->CollisionGeometries->data[inverse_kinematics_B.obj_tmp];\n    newObj->CollisionGeometries->data[inverse_kinematics_B.obj_tmp] = obj_0;\n  }\n\n  iobj_3->Base.CollisionsInternal = newObj;\n  if (rigidbodytree->NumBodies >= 1.0) {\n    body = rigidbodytree->Bodies[0];\n    inverse_kinematics_B.bid_m = body->ParentIndex;\n    if (inverse_kinematics_B.bid_m > 0.0) {\n      parent = rigidbodytree->Bodies[static_cast<int32_T>\n        (inverse_kinematics_B.bid_m) - 1];\n    } else {\n      parent = &rigidbodytree->Base;\n    }\n\n    inverse_kinematics_B.obj_tmp = bname->size[0] * bname->size[1];\n    bname->size[0] = 1;\n    bname->size[1] = parent->NameInternal->size[1];\n    invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.obj_tmp);\n    inverse_kinematics_B.loop_ub_h = parent->NameInternal->size[1] - 1;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n         inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n      bname->data[inverse_kinematics_B.obj_tmp] = parent->NameInternal->\n        data[inverse_kinematics_B.obj_tmp];\n    }\n\n    inverse_k_RigidBodyTree_addBody(iobj_3, body, bname, &(&iobj_0[0])[0],\n      &(&iobj_1[0])[0], &(&iobj_2[0])[1]);\n  }\n\n  if (rigidbodytree->NumBodies >= 2.0) {\n    body = rigidbodytree->Bodies[1];\n    inverse_kinematics_B.bid_m = body->ParentIndex;\n    if (inverse_kinematics_B.bid_m > 0.0) {\n      parent = rigidbodytree->Bodies[static_cast<int32_T>\n        (inverse_kinematics_B.bid_m) - 1];\n    } else {\n      parent = &rigidbodytree->Base;\n    }\n\n    inverse_kinematics_B.obj_tmp = bname->size[0] * bname->size[1];\n    bname->size[0] = 1;\n    bname->size[1] = parent->NameInternal->size[1];\n    invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.obj_tmp);\n    inverse_kinematics_B.loop_ub_h = parent->NameInternal->size[1] - 1;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n         inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n      bname->data[inverse_kinematics_B.obj_tmp] = parent->NameInternal->\n        data[inverse_kinematics_B.obj_tmp];\n    }\n\n    inverse_k_RigidBodyTree_addBody(iobj_3, body, bname, &(&iobj_0[0])[2],\n      &(&iobj_1[0])[1], &(&iobj_2[0])[3]);\n  }\n\n  if (rigidbodytree->NumBodies >= 3.0) {\n    body = rigidbodytree->Bodies[2];\n    inverse_kinematics_B.bid_m = body->ParentIndex;\n    if (inverse_kinematics_B.bid_m > 0.0) {\n      parent = rigidbodytree->Bodies[static_cast<int32_T>\n        (inverse_kinematics_B.bid_m) - 1];\n    } else {\n      parent = &rigidbodytree->Base;\n    }\n\n    inverse_kinematics_B.obj_tmp = bname->size[0] * bname->size[1];\n    bname->size[0] = 1;\n    bname->size[1] = parent->NameInternal->size[1];\n    invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.obj_tmp);\n    inverse_kinematics_B.loop_ub_h = parent->NameInternal->size[1] - 1;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n         inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n      bname->data[inverse_kinematics_B.obj_tmp] = parent->NameInternal->\n        data[inverse_kinematics_B.obj_tmp];\n    }\n\n    inverse_k_RigidBodyTree_addBody(iobj_3, body, bname, &(&iobj_0[0])[4],\n      &(&iobj_1[0])[2], &(&iobj_2[0])[5]);\n  }\n\n  if (rigidbodytree->NumBodies >= 4.0) {\n    body = rigidbodytree->Bodies[3];\n    inverse_kinematics_B.bid_m = body->ParentIndex;\n    if (inverse_kinematics_B.bid_m > 0.0) {\n      parent = rigidbodytree->Bodies[static_cast<int32_T>\n        (inverse_kinematics_B.bid_m) - 1];\n    } else {\n      parent = &rigidbodytree->Base;\n    }\n\n    inverse_kinematics_B.obj_tmp = bname->size[0] * bname->size[1];\n    bname->size[0] = 1;\n    bname->size[1] = parent->NameInternal->size[1];\n    invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.obj_tmp);\n    inverse_kinematics_B.loop_ub_h = parent->NameInternal->size[1] - 1;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n         inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n      bname->data[inverse_kinematics_B.obj_tmp] = parent->NameInternal->\n        data[inverse_kinematics_B.obj_tmp];\n    }\n\n    inverse_k_RigidBodyTree_addBody(iobj_3, body, bname, &(&iobj_0[0])[6],\n      &(&iobj_1[0])[3], &(&iobj_2[0])[7]);\n  }\n\n  if (rigidbodytree->NumBodies >= 5.0) {\n    body = rigidbodytree->Bodies[4];\n    inverse_kinematics_B.bid_m = body->ParentIndex;\n    if (inverse_kinematics_B.bid_m > 0.0) {\n      parent = rigidbodytree->Bodies[static_cast<int32_T>\n        (inverse_kinematics_B.bid_m) - 1];\n    } else {\n      parent = &rigidbodytree->Base;\n    }\n\n    inverse_kinematics_B.obj_tmp = bname->size[0] * bname->size[1];\n    bname->size[0] = 1;\n    bname->size[1] = parent->NameInternal->size[1];\n    invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.obj_tmp);\n    inverse_kinematics_B.loop_ub_h = parent->NameInternal->size[1] - 1;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n         inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n      bname->data[inverse_kinematics_B.obj_tmp] = parent->NameInternal->\n        data[inverse_kinematics_B.obj_tmp];\n    }\n\n    inverse_k_RigidBodyTree_addBody(iobj_3, body, bname, &(&iobj_0[0])[8],\n      &(&iobj_1[0])[4], &(&iobj_2[0])[9]);\n  }\n\n  if (rigidbodytree->NumBodies >= 6.0) {\n    body = rigidbodytree->Bodies[5];\n    inverse_kinematics_B.bid_m = body->ParentIndex;\n    if (inverse_kinematics_B.bid_m > 0.0) {\n      parent = rigidbodytree->Bodies[static_cast<int32_T>\n        (inverse_kinematics_B.bid_m) - 1];\n    } else {\n      parent = &rigidbodytree->Base;\n    }\n\n    inverse_kinematics_B.obj_tmp = bname->size[0] * bname->size[1];\n    bname->size[0] = 1;\n    bname->size[1] = parent->NameInternal->size[1];\n    invers_emxEnsureCapacity_char_T(bname, inverse_kinematics_B.obj_tmp);\n    inverse_kinematics_B.loop_ub_h = parent->NameInternal->size[1] - 1;\n    for (inverse_kinematics_B.b_kstr = 0; inverse_kinematics_B.b_kstr <=\n         inverse_kinematics_B.loop_ub_h; inverse_kinematics_B.b_kstr++) {\n      inverse_kinematics_B.obj_tmp = inverse_kinematics_B.b_kstr;\n      bname->data[inverse_kinematics_B.obj_tmp] = parent->NameInternal->\n        data[inverse_kinematics_B.obj_tmp];\n    }\n\n    inverse_k_RigidBodyTree_addBody(iobj_3, body, bname, &(&iobj_0[0])[10],\n      &(&iobj_1[0])[5], &(&iobj_2[0])[11]);\n  }\n\n  inverse_kinemati_emxFree_char_T(&bname);\n  obj->RigidBodyTreeInternal = iobj_3;\n}\n\nstatic void inverse_kinema_SystemCore_setup(robotics_slmanip_internal_blo_T *obj)\n{\n  b_inverseKinematics_inverse_k_T *obj_0;\n  c_rigidBodyJoint_inverse_kine_T *iobj_0;\n  h_robotics_core_internal_Erro_T *iobj_4;\n  l_robotics_manip_internal_Col_T *iobj_2;\n  t_robotics_manip_internal_Rig_T *iobj_1;\n  v_robotics_manip_internal_Rig_T *iobj_3;\n  static const sdAmwXbnJnEmimT0NaJRtAD_inver_T tmp = { 0.0,/* tv_sec */\n    0.0                                /* tv_nsec */\n  };\n\n  static const char_T tmp_0[18] = { 'L', 'e', 'v', 'e', 'n', 'b', 'e', 'r', 'g',\n    'M', 'a', 'r', 'q', 'u', 'a', 'r', 'd', 't' };\n\n  obj->isInitialized = 1;\n  inv_RigidBodyTree_RigidBodyTree(&obj->TreeInternal);\n  obj_0 = &obj->IKInternal;\n  obj->IKInternal.isInitialized = 0;\n  iobj_0 = &obj->IKInternal._pobj1[0];\n  iobj_1 = &obj->IKInternal._pobj2[0];\n  iobj_2 = &obj->IKInternal._pobj3[0];\n  iobj_3 = &obj->IKInternal._pobj4;\n  iobj_4 = &obj->IKInternal._pobj5;\n  inverseKinematics_set_RigidBody(&obj->IKInternal, &obj->TreeInternal,\n    &(&(&iobj_0[0])[0])[0], &(&(&iobj_1[0])[0])[0], &(&(&iobj_2[0])[0])[0],\n    iobj_3);\n  iobj_4->MaxNumIteration = 1500.0;\n  iobj_4->MaxTime = 10.0;\n  iobj_4->SolutionTolerance = 1.0E-6;\n  iobj_4->ConstraintsOn = true;\n  iobj_4->RandomRestart = true;\n  iobj_4->StepTolerance = 1.0E-12;\n  iobj_4->GradientTolerance = 5.0E-9;\n  iobj_4->ErrorChangeTolerance = 1.0E-12;\n  iobj_4->DampingBias = 0.0025;\n  iobj_4->UseErrorDamping = true;\n  for (inverse_kinematics_B.ret = 0; inverse_kinematics_B.ret < 18;\n       inverse_kinematics_B.ret++) {\n    iobj_4->Name[inverse_kinematics_B.ret] = tmp_0[inverse_kinematics_B.ret];\n  }\n\n  iobj_4->TimeObj.StartTime = tmp;\n  iobj_4->TimeObjInternal.StartTime = tmp;\n  obj_0->Solver = iobj_4;\n  iobj_4 = obj_0->Solver;\n  inverse_kinematics_B.params_ErrorChangeTolerance =\n    iobj_4->ErrorChangeTolerance;\n  inverse_kinematics_B.params_DampingBias = iobj_4->DampingBias;\n  inverse_kinematics_B.params_UseErrorDamping = iobj_4->UseErrorDamping;\n  for (inverse_kinematics_B.ret = 0; inverse_kinematics_B.ret < 18;\n       inverse_kinematics_B.ret++) {\n    inverse_kinematics_B.switch_expression[inverse_kinematics_B.ret] =\n      obj_0->Solver->Name[inverse_kinematics_B.ret];\n  }\n\n  for (inverse_kinematics_B.ret = 0; inverse_kinematics_B.ret < 18;\n       inverse_kinematics_B.ret++) {\n    inverse_kinematics_B.b_d[inverse_kinematics_B.ret] =\n      tmp_0[inverse_kinematics_B.ret];\n  }\n\n  inverse_kinematics_B.ret = memcmp(&inverse_kinematics_B.switch_expression[0],\n    &inverse_kinematics_B.b_d[0], 18);\n  if (inverse_kinematics_B.ret == 0) {\n    inverse_kinematics_B.params_ErrorChangeTolerance = 1.0E-12;\n    inverse_kinematics_B.params_DampingBias = 0.0025;\n    inverse_kinematics_B.params_UseErrorDamping = true;\n  }\n\n  iobj_4 = obj_0->Solver;\n  iobj_4->MaxNumIteration = 1500.0;\n  iobj_4->MaxTime = 10.0;\n  iobj_4->GradientTolerance = 1.0E-7;\n  iobj_4->SolutionTolerance = 1.0E-6;\n  iobj_4->ConstraintsOn = true;\n  iobj_4->RandomRestart = false;\n  iobj_4->StepTolerance = 1.0E-14;\n  iobj_4->ErrorChangeTolerance =\n    inverse_kinematics_B.params_ErrorChangeTolerance;\n  iobj_4->DampingBias = inverse_kinematics_B.params_DampingBias;\n  iobj_4->UseErrorDamping = inverse_kinematics_B.params_UseErrorDamping;\n  obj_0->matlabCodegenIsDeleted = false;\n}\n\nstatic void RigidBodyTree_get_JointPosition(v_robotics_manip_internal_Rig_T *obj,\n  emxArray_real_T_inverse_kinem_T *limits)\n{\n  c_rigidBodyJoint_inverse_kine_T *obj_0;\n  emxArray_char_T_inverse_kinem_T *a;\n  t_robotics_manip_internal_Rig_T *body;\n  real_T k;\n  real_T pnum;\n  int32_T b_kstr;\n  int32_T loop_ub;\n  char_T b[5];\n  static const char_T tmp[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  int32_T c_tmp;\n  int32_T i;\n  i = limits->size[0] * limits->size[1];\n  limits->size[0] = static_cast<int32_T>(obj->PositionNumber);\n  limits->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(limits, i);\n  loop_ub = (static_cast<int32_T>(obj->PositionNumber) << 1) - 1;\n  if (loop_ub >= 0) {\n    memset(&limits->data[0], 0, (loop_ub + 1) * sizeof(real_T));\n  }\n\n  k = 1.0;\n  pnum = obj->NumBodies;\n  c_tmp = static_cast<int32_T>(pnum) - 1;\n  if (static_cast<int32_T>(pnum) - 1 >= 0) {\n    for (b_kstr = 0; b_kstr < 5; b_kstr++) {\n      b[b_kstr] = tmp[b_kstr];\n    }\n  }\n\n  inverse_kinemati_emxInit_char_T(&a, 2);\n  for (int32_T limits_0 = 0; limits_0 <= c_tmp; limits_0++) {\n    boolean_T b_bool;\n    body = obj->Bodies[limits_0];\n    i = a->size[0] * a->size[1];\n    a->size[0] = 1;\n    a->size[1] = body->JointInternal->Type->size[1];\n    invers_emxEnsureCapacity_char_T(a, i);\n    loop_ub = body->JointInternal->Type->size[1] - 1;\n    for (b_kstr = 0; b_kstr <= loop_ub; b_kstr++) {\n      a->data[b_kstr] = body->JointInternal->Type->data[b_kstr];\n    }\n\n    b_bool = false;\n    if (a->size[1] != 5) {\n    } else {\n      b_kstr = 1;\n      int32_T exitg1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 5) {\n          if (a->data[b_kstr - 1] != b[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (!b_bool) {\n      int32_T f;\n      pnum = body->JointInternal->PositionNumber;\n      pnum += k;\n      if (k > pnum - 1.0) {\n        f = 0;\n      } else {\n        f = static_cast<int32_T>(k) - 1;\n      }\n\n      obj_0 = body->JointInternal;\n      loop_ub = obj_0->PositionLimitsInternal->size[0];\n      for (b_kstr = 0; b_kstr < 2; b_kstr++) {\n        for (i = 0; i < loop_ub; i++) {\n          limits->data[(f + i) + limits->size[0] * b_kstr] =\n            obj_0->PositionLimitsInternal->data[obj_0->\n            PositionLimitsInternal->size[0] * b_kstr + i];\n        }\n      }\n\n      k = pnum;\n    }\n  }\n\n  inverse_kinemati_emxFree_char_T(&a);\n}\n\nstatic void inverse_kinemati_emxInit_int8_T(emxArray_int8_T_inverse_kinem_T\n  **pEmxArray, int32_T numDimensions)\n{\n  emxArray_int8_T_inverse_kinem_T *emxArray;\n  *pEmxArray = static_cast<emxArray_int8_T_inverse_kinem_T *>(malloc(sizeof\n    (emxArray_int8_T_inverse_kinem_T)));\n  emxArray = *pEmxArray;\n  emxArray->data = static_cast<int8_T *>(NULL);\n  emxArray->numDimensions = numDimensions;\n  emxArray->size = static_cast<int32_T *>(malloc(sizeof(int32_T) * numDimensions));\n  emxArray->allocatedSize = 0;\n  emxArray->canFreeData = true;\n  for (int32_T i = 0; i < numDimensions; i++) {\n    emxArray->size[i] = 0;\n  }\n}\n\nstatic void invers_emxEnsureCapacity_int8_T(emxArray_int8_T_inverse_kinem_T\n  *emxArray, int32_T oldNumel)\n{\n  int32_T i;\n  int32_T newNumel;\n  void *newData;\n  if (oldNumel < 0) {\n    oldNumel = 0;\n  }\n\n  newNumel = 1;\n  for (i = 0; i < emxArray->numDimensions; i++) {\n    newNumel *= emxArray->size[i];\n  }\n\n  if (newNumel > emxArray->allocatedSize) {\n    i = emxArray->allocatedSize;\n    if (i < 16) {\n      i = 16;\n    }\n\n    while (i < newNumel) {\n      if (i > 1073741823) {\n        i = MAX_int32_T;\n      } else {\n        i <<= 1;\n      }\n    }\n\n    newData = calloc(static_cast<uint32_T>(i), sizeof(int8_T));\n    if (emxArray->data != NULL) {\n      memcpy(newData, emxArray->data, sizeof(int8_T) * oldNumel);\n      if (emxArray->canFreeData) {\n        free(emxArray->data);\n      }\n    }\n\n    emxArray->data = static_cast<int8_T *>(newData);\n    emxArray->allocatedSize = i;\n    emxArray->canFreeData = true;\n  }\n}\n\nstatic void inverse_kinemati_emxFree_int8_T(emxArray_int8_T_inverse_kinem_T\n  **pEmxArray)\n{\n  if (*pEmxArray != static_cast<emxArray_int8_T_inverse_kinem_T *>(NULL)) {\n    if (((*pEmxArray)->data != static_cast<int8_T *>(NULL)) && (*pEmxArray)\n        ->canFreeData) {\n      free((*pEmxArray)->data);\n    }\n\n    free((*pEmxArray)->size);\n    free(*pEmxArray);\n    *pEmxArray = static_cast<emxArray_int8_T_inverse_kinem_T *>(NULL);\n  }\n}\n\nstatic void inverse_ki_binary_expand_op_gaq(boolean_T in1[4], const real_T in2[4],\n  const emxArray_real_T_inverse_kinem_T *in3)\n{\n  int32_T stride_0_0;\n  stride_0_0 = (in3->size[0] != 1);\n  in1[0] = (in2[0] <= in3->data[in3->size[0]] + 4.4408920985006262E-16);\n  in1[1] = (in2[1] <= in3->data[stride_0_0 + in3->size[0]] +\n            4.4408920985006262E-16);\n  in1[2] = (in2[2] <= in3->data[(stride_0_0 << 1) + in3->size[0]] +\n            4.4408920985006262E-16);\n  in1[3] = (in2[3] <= in3->data[3 * stride_0_0 + in3->size[0]] +\n            4.4408920985006262E-16);\n}\n\nstatic void inverse_kin_binary_expand_op_ga(boolean_T in1[4], const real_T in2[4],\n  const emxArray_real_T_inverse_kinem_T *in3)\n{\n  int32_T stride_0_0;\n  stride_0_0 = (in3->size[0] != 1);\n  in1[0] = (in2[0] >= in3->data[0] - 4.4408920985006262E-16);\n  in1[1] = (in2[1] >= in3->data[stride_0_0] - 4.4408920985006262E-16);\n  in1[2] = (in2[2] >= in3->data[stride_0_0 << 1] - 4.4408920985006262E-16);\n  in1[3] = (in2[3] >= in3->data[3 * stride_0_0] - 4.4408920985006262E-16);\n}\n\nstatic void inverse_kinematics_eml_find(const boolean_T x[4], int32_T i_data[],\n  int32_T *i_size)\n{\n  int32_T b_ii;\n  int32_T idx;\n  boolean_T exitg1;\n  idx = 0;\n  b_ii = 1;\n  exitg1 = false;\n  while ((!exitg1) && (b_ii - 1 < 4)) {\n    if (x[b_ii - 1]) {\n      idx++;\n      i_data[idx - 1] = b_ii;\n      if (idx >= 4) {\n        exitg1 = true;\n      } else {\n        b_ii++;\n      }\n    } else {\n      b_ii++;\n    }\n  }\n\n  if (idx < 1) {\n    idx = 0;\n  }\n\n  *i_size = idx;\n}\n\nstatic void inverse_kinematics_tic(real_T *tstart_tv_sec, real_T *tstart_tv_nsec)\n{\n  coderTimespec b_timespec;\n  if (!inverse_kinematics_DW.method_not_empty) {\n    inverse_kinematics_DW.method_not_empty = true;\n    coderInitTimeFunctions(&inverse_kinematics_DW.freq);\n  }\n\n  coderTimeClockGettimeMonotonic(&b_timespec, inverse_kinematics_DW.freq);\n  *tstart_tv_sec = b_timespec.tv_sec;\n  *tstart_tv_nsec = b_timespec.tv_nsec;\n}\n\nstatic void i_RigidBodyTree_ancestorIndices(v_robotics_manip_internal_Rig_T *obj,\n  t_robotics_manip_internal_Rig_T *body, emxArray_real_T_inverse_kinem_T\n  *indices)\n{\n  inverse_kinematics_B.loop_ub_f = indices->size[0] * indices->size[1];\n  indices->size[0] = 1;\n  indices->size[1] = static_cast<int32_T>(obj->NumBodies + 1.0);\n  invers_emxEnsureCapacity_real_T(indices, inverse_kinematics_B.loop_ub_f);\n  inverse_kinematics_B.loop_ub_f = static_cast<int32_T>(obj->NumBodies + 1.0) -\n    1;\n  if (inverse_kinematics_B.loop_ub_f >= 0) {\n    memset(&indices->data[0], 0, (inverse_kinematics_B.loop_ub_f + 1) * sizeof\n           (real_T));\n  }\n\n  inverse_kinematics_B.i = 2.0;\n  indices->data[0] = body->Index;\n  while (body->ParentIndex > 0.0) {\n    body = obj->Bodies[static_cast<int32_T>(body->ParentIndex) - 1];\n    indices->data[static_cast<int32_T>(inverse_kinematics_B.i) - 1] =\n      body->Index;\n    inverse_kinematics_B.i++;\n  }\n\n  if (body->Index > 0.0) {\n    indices->data[static_cast<int32_T>(inverse_kinematics_B.i) - 1] =\n      body->ParentIndex;\n    inverse_kinematics_B.i++;\n  }\n\n  inverse_kinematics_B.loop_ub_tmp = static_cast<int32_T>(inverse_kinematics_B.i\n    - 1.0);\n  for (inverse_kinematics_B.loop_ub_f = 0; inverse_kinematics_B.loop_ub_f <\n       inverse_kinematics_B.loop_ub_tmp; inverse_kinematics_B.loop_ub_f++) {\n  }\n\n  inverse_kinematics_B.loop_ub_f = indices->size[0] * indices->size[1];\n  indices->size[0] = 1;\n  indices->size[1] = static_cast<int32_T>(inverse_kinematics_B.i - 1.0);\n  invers_emxEnsureCapacity_real_T(indices, inverse_kinematics_B.loop_ub_f);\n}\n\nstatic void RigidBodyTree_kinematicPathInte(v_robotics_manip_internal_Rig_T *obj,\n  t_robotics_manip_internal_Rig_T *body1, t_robotics_manip_internal_Rig_T *body2,\n  emxArray_real_T_inverse_kinem_T *indices)\n{\n  emxArray_real_T_inverse_kinem_T *ancestorIndices1;\n  emxArray_real_T_inverse_kinem_T *ancestorIndices2;\n  boolean_T exitg1;\n  inverse_kinemati_emxInit_real_T(&ancestorIndices1, 2);\n  inverse_kinemati_emxInit_real_T(&ancestorIndices2, 2);\n  i_RigidBodyTree_ancestorIndices(obj, body1, ancestorIndices1);\n  i_RigidBodyTree_ancestorIndices(obj, body2, ancestorIndices2);\n  if (static_cast<real_T>(ancestorIndices1->size[1]) <= ancestorIndices2->size[1])\n  {\n    inverse_kinematics_B.minPathLength = ancestorIndices1->size[1];\n  } else {\n    inverse_kinematics_B.minPathLength = ancestorIndices2->size[1];\n  }\n\n  inverse_kinematics_B.b_i_l = 0;\n  exitg1 = false;\n  while ((!exitg1) && (inverse_kinematics_B.b_i_l <=\n                       inverse_kinematics_B.minPathLength - 2)) {\n    if (ancestorIndices1->data[(ancestorIndices1->size[1] -\n         inverse_kinematics_B.b_i_l) - 2] != ancestorIndices2->data\n        [(ancestorIndices2->size[1] - inverse_kinematics_B.b_i_l) - 2]) {\n      inverse_kinematics_B.minPathLength = inverse_kinematics_B.b_i_l + 1;\n      exitg1 = true;\n    } else {\n      inverse_kinematics_B.b_i_l++;\n    }\n  }\n\n  inverse_kinematics_B.b_i_l = ancestorIndices1->size[1] -\n    inverse_kinematics_B.minPathLength;\n  if (inverse_kinematics_B.b_i_l < 1) {\n    inverse_kinematics_B.e_mv = -1;\n  } else {\n    inverse_kinematics_B.e_mv = inverse_kinematics_B.b_i_l - 1;\n  }\n\n  inverse_kinematics_B.b_i_l = ancestorIndices2->size[1] -\n    inverse_kinematics_B.minPathLength;\n  if (inverse_kinematics_B.b_i_l < 1) {\n    inverse_kinematics_B.j = 0;\n    inverse_kinematics_B.h = 1;\n    inverse_kinematics_B.b_i_l = -1;\n  } else {\n    inverse_kinematics_B.j = inverse_kinematics_B.b_i_l - 1;\n    inverse_kinematics_B.h = -1;\n    inverse_kinematics_B.b_i_l = 0;\n  }\n\n  inverse_kinematics_B.i_cn = indices->size[0] * indices->size[1];\n  indices->size[0] = 1;\n  inverse_kinematics_B.loop_ub_m = div_s32(inverse_kinematics_B.b_i_l -\n    inverse_kinematics_B.j, inverse_kinematics_B.h);\n  indices->size[1] = (inverse_kinematics_B.loop_ub_m + inverse_kinematics_B.e_mv)\n    + 3;\n  invers_emxEnsureCapacity_real_T(indices, inverse_kinematics_B.i_cn);\n  if (inverse_kinematics_B.e_mv >= 0) {\n    memcpy(&indices->data[0], &ancestorIndices1->data[0],\n           (inverse_kinematics_B.e_mv + 1) * sizeof(real_T));\n  }\n\n  indices->data[inverse_kinematics_B.e_mv + 1] = ancestorIndices1->\n    data[ancestorIndices1->size[1] - inverse_kinematics_B.minPathLength];\n  inverse_kinemati_emxFree_real_T(&ancestorIndices1);\n  for (inverse_kinematics_B.b_i_l = 0; inverse_kinematics_B.b_i_l <=\n       inverse_kinematics_B.loop_ub_m; inverse_kinematics_B.b_i_l++) {\n    indices->data[(inverse_kinematics_B.b_i_l + inverse_kinematics_B.e_mv) + 2] =\n      ancestorIndices2->data[inverse_kinematics_B.h * inverse_kinematics_B.b_i_l\n      + inverse_kinematics_B.j];\n  }\n\n  inverse_kinemati_emxFree_real_T(&ancestorIndices2);\n}\n\nstatic void in_rigidBodyJoint_get_JointAxis(const\n  c_rigidBodyJoint_inverse_kine_T *obj, real_T ax[3])\n{\n  int32_T b_kstr;\n  char_T b_0[9];\n  char_T b[8];\n  boolean_T b_bool;\n  static const char_T tmp[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  static const char_T tmp_0[9] = { 'p', 'r', 'i', 's', 'm', 'a', 't', 'i', 'c' };\n\n  int32_T exitg1;\n  boolean_T guard1 = false;\n  for (b_kstr = 0; b_kstr < 8; b_kstr++) {\n    b[b_kstr] = tmp[b_kstr];\n  }\n\n  b_bool = false;\n  if (obj->Type->size[1] != 8) {\n  } else {\n    b_kstr = 1;\n    do {\n      exitg1 = 0;\n      if (b_kstr - 1 < 8) {\n        if (obj->Type->data[b_kstr - 1] != b[b_kstr - 1]) {\n          exitg1 = 1;\n        } else {\n          b_kstr++;\n        }\n      } else {\n        b_bool = true;\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  guard1 = false;\n  if (b_bool) {\n    guard1 = true;\n  } else {\n    for (b_kstr = 0; b_kstr < 9; b_kstr++) {\n      b_0[b_kstr] = tmp_0[b_kstr];\n    }\n\n    b_bool = false;\n    if (obj->Type->size[1] != 9) {\n    } else {\n      b_kstr = 1;\n      do {\n        exitg1 = 0;\n        if (b_kstr - 1 < 9) {\n          if (obj->Type->data[b_kstr - 1] != b_0[b_kstr - 1]) {\n            exitg1 = 1;\n          } else {\n            b_kstr++;\n          }\n        } else {\n          b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (b_bool) {\n      guard1 = true;\n    } else {\n      ax[0] = (rtNaN);\n      ax[1] = (rtNaN);\n      ax[2] = (rtNaN);\n    }\n  }\n\n  if (guard1) {\n    ax[0] = obj->JointAxisInternal[0];\n    ax[1] = obj->JointAxisInternal[1];\n    ax[2] = obj->JointAxisInternal[2];\n  }\n}\n\nstatic void inverse_kinematics_cat(real_T varargin_1, real_T varargin_2, real_T\n  varargin_3, real_T varargin_4, real_T varargin_5, real_T varargin_6, real_T\n  varargin_7, real_T varargin_8, real_T varargin_9, real_T y[9])\n{\n  y[0] = varargin_1;\n  y[1] = varargin_2;\n  y[2] = varargin_3;\n  y[3] = varargin_4;\n  y[4] = varargin_5;\n  y[5] = varargin_6;\n  y[6] = varargin_7;\n  y[7] = varargin_8;\n  y[8] = varargin_9;\n}\n\nstatic void inverse_kinematics_mtimes(const real_T A[36], const\n  emxArray_real_T_inverse_kinem_T *B, emxArray_real_T_inverse_kinem_T *C)\n{\n  inverse_kinematics_B.n = B->size[1] - 1;\n  inverse_kinematics_B.b_j_p = C->size[0] * C->size[1];\n  C->size[0] = 6;\n  C->size[1] = B->size[1];\n  invers_emxEnsureCapacity_real_T(C, inverse_kinematics_B.b_j_p);\n  for (inverse_kinematics_B.b_j_p = 0; inverse_kinematics_B.b_j_p <=\n       inverse_kinematics_B.n; inverse_kinematics_B.b_j_p++) {\n    inverse_kinematics_B.coffset_tmp = inverse_kinematics_B.b_j_p * 6 - 1;\n    for (inverse_kinematics_B.b_i_p = 0; inverse_kinematics_B.b_i_p < 6;\n         inverse_kinematics_B.b_i_p++) {\n      inverse_kinematics_B.s_p = 0.0;\n      for (inverse_kinematics_B.b_k_ft = 0; inverse_kinematics_B.b_k_ft < 6;\n           inverse_kinematics_B.b_k_ft++) {\n        inverse_kinematics_B.s_p += A[inverse_kinematics_B.b_k_ft * 6 +\n          inverse_kinematics_B.b_i_p] * B->data\n          [(inverse_kinematics_B.coffset_tmp + inverse_kinematics_B.b_k_ft) + 1];\n      }\n\n      C->data[(inverse_kinematics_B.coffset_tmp + inverse_kinematics_B.b_i_p) +\n        1] = inverse_kinematics_B.s_p;\n    }\n  }\n}\n\nstatic void RigidBodyTree_efficientFKAndJac(v_robotics_manip_internal_Rig_T *obj,\n  const real_T qv[4], const emxArray_char_T_inverse_kinem_T *body1Name, real_T\n  T_data[], int32_T T_size[2], emxArray_real_T_inverse_kinem_T *Jac)\n{\n  c_rigidBodyJoint_inverse_kine_T *joint;\n  emxArray_char_T_inverse_kinem_T *body2Name;\n  emxArray_real_T_inverse_kinem_T *b;\n  emxArray_real_T_inverse_kinem_T *kinematicPathIndices;\n  emxArray_real_T_inverse_kinem_T *tmp;\n  t_robotics_manip_internal_Rig_T *body1;\n  t_robotics_manip_internal_Rig_T *body2;\n  static const char_T tmp_0[5] = { 'f', 'i', 'x', 'e', 'd' };\n\n  static const char_T tmp_1[8] = { 'r', 'e', 'v', 'o', 'l', 'u', 't', 'e' };\n\n  emxArray_real_T_inverse_kinem_T *Jac_0;\n  inverse_kinemati_emxInit_char_T(&body2Name, 2);\n  inverse_kinematics_B.result_data_tmp = body2Name->size[0] * body2Name->size[1];\n  body2Name->size[0] = 1;\n  body2Name->size[1] = obj->Base.NameInternal->size[1];\n  invers_emxEnsureCapacity_char_T(body2Name,\n    inverse_kinematics_B.result_data_tmp);\n  inverse_kinematics_B.loop_ub_o3 = obj->Base.NameInternal->size[1] - 1;\n  for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c <=\n       inverse_kinematics_B.loop_ub_o3; inverse_kinematics_B.i_c++) {\n    inverse_kinematics_B.result_data_tmp = inverse_kinematics_B.i_c;\n    body2Name->data[inverse_kinematics_B.result_data_tmp] =\n      obj->Base.NameInternal->data[inverse_kinematics_B.result_data_tmp];\n  }\n\n  inverse_kinematics_B.bid1 = RigidBodyTree_findBodyIndexByNa(obj, body1Name);\n  inverse_kinematics_B.bid2 = RigidBodyTree_findBodyIndexByNa(obj, body2Name);\n  if (inverse_kinematics_B.bid1 == 0.0) {\n    body1 = &obj->Base;\n  } else {\n    body1 = obj->Bodies[static_cast<int32_T>(inverse_kinematics_B.bid1) - 1];\n  }\n\n  if (inverse_kinematics_B.bid2 == 0.0) {\n    body2 = &obj->Base;\n  } else {\n    body2 = obj->Bodies[static_cast<int32_T>(inverse_kinematics_B.bid2) - 1];\n  }\n\n  inverse_kinemati_emxInit_real_T(&kinematicPathIndices, 2);\n  RigidBodyTree_kinematicPathInte(obj, body1, body2, kinematicPathIndices);\n  memset(&inverse_kinematics_B.T1[0], 0, sizeof(real_T) << 4U);\n  inverse_kinematics_B.T1[0] = 1.0;\n  inverse_kinematics_B.T1[5] = 1.0;\n  inverse_kinematics_B.T1[10] = 1.0;\n  inverse_kinematics_B.T1[15] = 1.0;\n  inverse_kinematics_B.result_data_tmp = Jac->size[0] * Jac->size[1];\n  Jac->size[0] = 6;\n  Jac->size[1] = static_cast<int32_T>(obj->PositionNumber);\n  invers_emxEnsureCapacity_real_T(Jac, inverse_kinematics_B.result_data_tmp);\n  inverse_kinematics_B.loop_ub_o3 = 6 * static_cast<int32_T>(obj->PositionNumber)\n    - 1;\n  if (inverse_kinematics_B.loop_ub_o3 >= 0) {\n    memset(&Jac->data[0], 0, (inverse_kinematics_B.loop_ub_o3 + 1) * sizeof\n           (real_T));\n  }\n\n  inverse_kinematics_B.c_g = kinematicPathIndices->size[1] - 2;\n  if (kinematicPathIndices->size[1] - 2 >= 0) {\n    for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 5;\n         inverse_kinematics_B.i_c++) {\n      inverse_kinematics_B.b_af[inverse_kinematics_B.i_c] =\n        tmp_0[inverse_kinematics_B.i_c];\n    }\n  }\n\n  inverse_kinemati_emxInit_real_T(&b, 2);\n  inverse_kinemati_emxInit_real_T(&tmp, 2);\n  for (inverse_kinematics_B.Jac = 0; inverse_kinematics_B.Jac <=\n       inverse_kinematics_B.c_g; inverse_kinematics_B.Jac++) {\n    int32_T exitg1;\n    inverse_kinematics_B.result_data_tmp = inverse_kinematics_B.Jac;\n    if (kinematicPathIndices->data[inverse_kinematics_B.result_data_tmp] != 0.0)\n    {\n      body1 = obj->Bodies[static_cast<int32_T>(kinematicPathIndices->\n        data[inverse_kinematics_B.result_data_tmp]) - 1];\n    } else {\n      body1 = &obj->Base;\n    }\n\n    inverse_kinematics_B.bid1 = kinematicPathIndices->\n      data[inverse_kinematics_B.Jac + 1];\n    if (inverse_kinematics_B.bid1 != 0.0) {\n      body2 = obj->Bodies[static_cast<int32_T>(inverse_kinematics_B.bid1) - 1];\n    } else {\n      body2 = &obj->Base;\n    }\n\n    inverse_kinematics_B.nextBodyIsParent = (body2->Index == body1->ParentIndex);\n    if (inverse_kinematics_B.nextBodyIsParent) {\n      body2 = body1;\n      inverse_kinematics_B.jointSign = 1;\n    } else {\n      inverse_kinematics_B.jointSign = -1;\n    }\n\n    joint = body2->JointInternal;\n    inverse_kinematics_B.result_data_tmp = body2Name->size[0] * body2Name->size\n      [1];\n    body2Name->size[0] = 1;\n    body2Name->size[1] = joint->Type->size[1];\n    invers_emxEnsureCapacity_char_T(body2Name,\n      inverse_kinematics_B.result_data_tmp);\n    inverse_kinematics_B.loop_ub_o3 = joint->Type->size[1] - 1;\n    for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c <=\n         inverse_kinematics_B.loop_ub_o3; inverse_kinematics_B.i_c++) {\n      inverse_kinematics_B.result_data_tmp = inverse_kinematics_B.i_c;\n      body2Name->data[inverse_kinematics_B.result_data_tmp] = joint->Type->\n        data[inverse_kinematics_B.result_data_tmp];\n    }\n\n    inverse_kinematics_B.b_bool = false;\n    if (body2Name->size[1] != 5) {\n    } else {\n      inverse_kinematics_B.i_c = 1;\n      do {\n        exitg1 = 0;\n        if (inverse_kinematics_B.i_c - 1 < 5) {\n          if (body2Name->data[inverse_kinematics_B.i_c - 1] !=\n              inverse_kinematics_B.b_af[inverse_kinematics_B.i_c - 1]) {\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.i_c++;\n          }\n        } else {\n          inverse_kinematics_B.b_bool = true;\n          exitg1 = 1;\n        }\n      } while (exitg1 == 0);\n    }\n\n    if (inverse_kinematics_B.b_bool) {\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 16;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c] =\n          joint->JointToParentTransform[inverse_kinematics_B.i_c];\n      }\n\n      inverse_kinematics_B.result_data_tmp = body2Name->size[0] *\n        body2Name->size[1];\n      body2Name->size[0] = 1;\n      body2Name->size[1] = joint->Type->size[1];\n      invers_emxEnsureCapacity_char_T(body2Name,\n        inverse_kinematics_B.result_data_tmp);\n      inverse_kinematics_B.loop_ub_o3 = joint->Type->size[1] - 1;\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c <=\n           inverse_kinematics_B.loop_ub_o3; inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.result_data_tmp = inverse_kinematics_B.i_c;\n        body2Name->data[inverse_kinematics_B.result_data_tmp] = joint->\n          Type->data[inverse_kinematics_B.result_data_tmp];\n      }\n\n      inverse_kinematics_B.b_bool = false;\n      if (body2Name->size[1] != 5) {\n      } else {\n        inverse_kinematics_B.i_c = 1;\n        do {\n          exitg1 = 0;\n          if (inverse_kinematics_B.i_c - 1 < 5) {\n            if (body2Name->data[inverse_kinematics_B.i_c - 1] !=\n                inverse_kinematics_B.b_af[inverse_kinematics_B.i_c - 1]) {\n              exitg1 = 1;\n            } else {\n              inverse_kinematics_B.i_c++;\n            }\n          } else {\n            inverse_kinematics_B.b_bool = true;\n            exitg1 = 1;\n          }\n        } while (exitg1 == 0);\n      }\n\n      if (inverse_kinematics_B.b_bool) {\n        inverse_kinematics_B.i_c = 0;\n      } else {\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 8;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.b_j[inverse_kinematics_B.i_c] =\n            tmp_1[inverse_kinematics_B.i_c];\n        }\n\n        inverse_kinematics_B.b_bool = false;\n        if (body2Name->size[1] != 8) {\n        } else {\n          inverse_kinematics_B.i_c = 1;\n          do {\n            exitg1 = 0;\n            if (inverse_kinematics_B.i_c - 1 < 8) {\n              if (body2Name->data[inverse_kinematics_B.i_c - 1] !=\n                  inverse_kinematics_B.b_j[inverse_kinematics_B.i_c - 1]) {\n                exitg1 = 1;\n              } else {\n                inverse_kinematics_B.i_c++;\n              }\n            } else {\n              inverse_kinematics_B.b_bool = true;\n              exitg1 = 1;\n            }\n          } while (exitg1 == 0);\n        }\n\n        if (inverse_kinematics_B.b_bool) {\n          inverse_kinematics_B.i_c = 1;\n        } else {\n          inverse_kinematics_B.i_c = -1;\n        }\n      }\n\n      switch (inverse_kinematics_B.i_c) {\n       case 0:\n        memset(&inverse_kinematics_B.T1j[0], 0, sizeof(real_T) << 4U);\n        inverse_kinematics_B.T1j[0] = 1.0;\n        inverse_kinematics_B.T1j[5] = 1.0;\n        inverse_kinematics_B.T1j[10] = 1.0;\n        inverse_kinematics_B.T1j[15] = 1.0;\n        break;\n\n       case 1:\n        in_rigidBodyJoint_get_JointAxis(joint, inverse_kinematics_B.v);\n        inverse_kinematics_B.bid2 = inverse_kinematics_B.v[0];\n        inverse_kinematics_B.bid1_tmp = inverse_kinematics_B.v[1];\n        inverse_kinematics_B.tempR_tmp = inverse_kinematics_B.v[2];\n        inverse_kinematics_B.bid1 = 1.0 / sqrt((inverse_kinematics_B.bid2 *\n          inverse_kinematics_B.bid2 + inverse_kinematics_B.bid1_tmp *\n          inverse_kinematics_B.bid1_tmp) + inverse_kinematics_B.tempR_tmp *\n          inverse_kinematics_B.tempR_tmp);\n        inverse_kinematics_B.v[0] = inverse_kinematics_B.bid2 *\n          inverse_kinematics_B.bid1;\n        inverse_kinematics_B.v[1] = inverse_kinematics_B.bid1_tmp *\n          inverse_kinematics_B.bid1;\n        inverse_kinematics_B.v[2] = inverse_kinematics_B.tempR_tmp *\n          inverse_kinematics_B.bid1;\n        inverse_kinematics_B.bid2 = inverse_kinematics_B.v[0] *\n          inverse_kinematics_B.v[1] * 0.0;\n        inverse_kinematics_B.bid1_tmp = inverse_kinematics_B.v[0] *\n          inverse_kinematics_B.v[2] * 0.0;\n        inverse_kinematics_B.tempR_tmp = inverse_kinematics_B.v[1] *\n          inverse_kinematics_B.v[2] * 0.0;\n        inverse_kinematics_cat(inverse_kinematics_B.v[0] *\n          inverse_kinematics_B.v[0] * 0.0 + 1.0, inverse_kinematics_B.bid2 -\n          inverse_kinematics_B.v[2] * 0.0, inverse_kinematics_B.bid1_tmp +\n          inverse_kinematics_B.v[1] * 0.0, inverse_kinematics_B.bid2 +\n          inverse_kinematics_B.v[2] * 0.0, inverse_kinematics_B.v[1] *\n          inverse_kinematics_B.v[1] * 0.0 + 1.0, inverse_kinematics_B.tempR_tmp\n          - inverse_kinematics_B.v[0] * 0.0, inverse_kinematics_B.bid1_tmp -\n          inverse_kinematics_B.v[1] * 0.0, inverse_kinematics_B.tempR_tmp +\n          inverse_kinematics_B.v[0] * 0.0, inverse_kinematics_B.v[2] *\n          inverse_kinematics_B.v[2] * 0.0 + 1.0, inverse_kinematics_B.tempR);\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.R[inverse_kinematics_B.i_c] =\n            inverse_kinematics_B.tempR[inverse_kinematics_B.i_c * 3];\n          inverse_kinematics_B.R[inverse_kinematics_B.i_c + 3] =\n            inverse_kinematics_B.tempR[inverse_kinematics_B.i_c * 3 + 1];\n          inverse_kinematics_B.R[inverse_kinematics_B.i_c + 6] =\n            inverse_kinematics_B.tempR[inverse_kinematics_B.i_c * 3 + 2];\n        }\n\n        memset(&inverse_kinematics_B.T1j[0], 0, sizeof(real_T) << 4U);\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c << 2;\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3 + 1] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 1];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3 + 2] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 2];\n        }\n\n        inverse_kinematics_B.T1j[15] = 1.0;\n        break;\n\n       default:\n        in_rigidBodyJoint_get_JointAxis(joint, inverse_kinematics_B.v);\n        memset(&inverse_kinematics_B.tempR[0], 0, 9U * sizeof(real_T));\n        inverse_kinematics_B.tempR[0] = 1.0;\n        inverse_kinematics_B.tempR[4] = 1.0;\n        inverse_kinematics_B.tempR[8] = 1.0;\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c << 2;\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] =\n            inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3 + 1] =\n            inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c + 1];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3 + 2] =\n            inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c + 2];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.i_c + 12] =\n            inverse_kinematics_B.v[inverse_kinematics_B.i_c] * 0.0;\n        }\n\n        inverse_kinematics_B.T1j[3] = 0.0;\n        inverse_kinematics_B.T1j[7] = 0.0;\n        inverse_kinematics_B.T1j[11] = 0.0;\n        inverse_kinematics_B.T1j[15] = 1.0;\n        break;\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 16;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.b[inverse_kinematics_B.i_c] =\n          joint->ChildToJointTransform[inverse_kinematics_B.i_c];\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 4;\n           inverse_kinematics_B.i_c++) {\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 4;\n             inverse_kinematics_B.g++) {\n          inverse_kinematics_B.f = inverse_kinematics_B.g << 2;\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c +\n            inverse_kinematics_B.f;\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] = 0.0;\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1j[inverse_kinematics_B.f] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1j[inverse_kinematics_B.f + 1] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 4];\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1j[inverse_kinematics_B.f + 2] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 8];\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1j[inverse_kinematics_B.f + 3] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 12];\n        }\n\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 4;\n             inverse_kinematics_B.g++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.g << 2;\n          inverse_kinematics_B.f = inverse_kinematics_B.i_c +\n            inverse_kinematics_B.loop_ub_o3;\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] = 0.0;\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.b[inverse_kinematics_B.loop_ub_o3] *\n            inverse_kinematics_B.Tj_k[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.b[inverse_kinematics_B.loop_ub_o3 + 1] *\n            inverse_kinematics_B.Tj_k[inverse_kinematics_B.i_c + 4];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.b[inverse_kinematics_B.loop_ub_o3 + 2] *\n            inverse_kinematics_B.Tj_k[inverse_kinematics_B.i_c + 8];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.b[inverse_kinematics_B.loop_ub_o3 + 3] *\n            inverse_kinematics_B.Tj_k[inverse_kinematics_B.i_c + 12];\n        }\n      }\n    } else {\n      inverse_kinematics_B.i_c = static_cast<int32_T>(body2->Index);\n      inverse_kinematics_B.bid1 = obj->PositionDoFMap[inverse_kinematics_B.i_c -\n        1];\n      inverse_kinematics_B.bid2 = obj->PositionDoFMap[inverse_kinematics_B.i_c +\n        5];\n      if (inverse_kinematics_B.bid1 > inverse_kinematics_B.bid2) {\n        inverse_kinematics_B.g = 0;\n        inverse_kinematics_B.f = 0;\n      } else {\n        inverse_kinematics_B.g = static_cast<int32_T>(inverse_kinematics_B.bid1)\n          - 1;\n        inverse_kinematics_B.f = static_cast<int32_T>(inverse_kinematics_B.bid2);\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 16;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c] =\n          joint->JointToParentTransform[inverse_kinematics_B.i_c];\n      }\n\n      inverse_kinematics_B.result_data_tmp = body2Name->size[0] *\n        body2Name->size[1];\n      body2Name->size[0] = 1;\n      body2Name->size[1] = joint->Type->size[1];\n      invers_emxEnsureCapacity_char_T(body2Name,\n        inverse_kinematics_B.result_data_tmp);\n      inverse_kinematics_B.loop_ub_o3 = joint->Type->size[1] - 1;\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c <=\n           inverse_kinematics_B.loop_ub_o3; inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.result_data_tmp = inverse_kinematics_B.i_c;\n        body2Name->data[inverse_kinematics_B.result_data_tmp] = joint->\n          Type->data[inverse_kinematics_B.result_data_tmp];\n      }\n\n      inverse_kinematics_B.b_bool = false;\n      if (body2Name->size[1] != 5) {\n      } else {\n        inverse_kinematics_B.i_c = 1;\n        do {\n          exitg1 = 0;\n          if (inverse_kinematics_B.i_c - 1 < 5) {\n            if (body2Name->data[inverse_kinematics_B.i_c - 1] !=\n                inverse_kinematics_B.b_af[inverse_kinematics_B.i_c - 1]) {\n              exitg1 = 1;\n            } else {\n              inverse_kinematics_B.i_c++;\n            }\n          } else {\n            inverse_kinematics_B.b_bool = true;\n            exitg1 = 1;\n          }\n        } while (exitg1 == 0);\n      }\n\n      if (inverse_kinematics_B.b_bool) {\n        inverse_kinematics_B.i_c = 0;\n      } else {\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 8;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.b_j[inverse_kinematics_B.i_c] =\n            tmp_1[inverse_kinematics_B.i_c];\n        }\n\n        inverse_kinematics_B.b_bool = false;\n        if (body2Name->size[1] != 8) {\n        } else {\n          inverse_kinematics_B.i_c = 1;\n          do {\n            exitg1 = 0;\n            if (inverse_kinematics_B.i_c - 1 < 8) {\n              if (body2Name->data[inverse_kinematics_B.i_c - 1] !=\n                  inverse_kinematics_B.b_j[inverse_kinematics_B.i_c - 1]) {\n                exitg1 = 1;\n              } else {\n                inverse_kinematics_B.i_c++;\n              }\n            } else {\n              inverse_kinematics_B.b_bool = true;\n              exitg1 = 1;\n            }\n          } while (exitg1 == 0);\n        }\n\n        if (inverse_kinematics_B.b_bool) {\n          inverse_kinematics_B.i_c = 1;\n        } else {\n          inverse_kinematics_B.i_c = -1;\n        }\n      }\n\n      switch (inverse_kinematics_B.i_c) {\n       case 0:\n        memset(&inverse_kinematics_B.T1j[0], 0, sizeof(real_T) << 4U);\n        inverse_kinematics_B.T1j[0] = 1.0;\n        inverse_kinematics_B.T1j[5] = 1.0;\n        inverse_kinematics_B.T1j[10] = 1.0;\n        inverse_kinematics_B.T1j[15] = 1.0;\n        break;\n\n       case 1:\n        in_rigidBodyJoint_get_JointAxis(joint, inverse_kinematics_B.v);\n        inverse_kinematics_B.i_c = 0;\n        inverse_kinematics_B.result_data[inverse_kinematics_B.i_c] =\n          inverse_kinematics_B.v[0];\n        inverse_kinematics_B.result_data_tmp = 1;\n        inverse_kinematics_B.result_data[inverse_kinematics_B.result_data_tmp] =\n          inverse_kinematics_B.v[1];\n        inverse_kinematics_B.loop_ub_o3 = 2;\n        inverse_kinematics_B.result_data[inverse_kinematics_B.loop_ub_o3] =\n          inverse_kinematics_B.v[2];\n        if ((inverse_kinematics_B.f - inverse_kinematics_B.g != 0) - 1 >= 0) {\n          inverse_kinematics_B.result_data[3] = qv[inverse_kinematics_B.g];\n        }\n\n        inverse_kinematics_B.bid2 =\n          inverse_kinematics_B.result_data[inverse_kinematics_B.i_c];\n        inverse_kinematics_B.sth =\n          inverse_kinematics_B.result_data[inverse_kinematics_B.result_data_tmp];\n        inverse_kinematics_B.bid1_tmp =\n          inverse_kinematics_B.result_data[inverse_kinematics_B.loop_ub_o3];\n        inverse_kinematics_B.bid1 = 1.0 / sqrt((inverse_kinematics_B.bid2 *\n          inverse_kinematics_B.bid2 + inverse_kinematics_B.sth *\n          inverse_kinematics_B.sth) + inverse_kinematics_B.bid1_tmp *\n          inverse_kinematics_B.bid1_tmp);\n        inverse_kinematics_B.v[0] = inverse_kinematics_B.bid2 *\n          inverse_kinematics_B.bid1;\n        inverse_kinematics_B.v[1] = inverse_kinematics_B.sth *\n          inverse_kinematics_B.bid1;\n        inverse_kinematics_B.v[2] = inverse_kinematics_B.bid1_tmp *\n          inverse_kinematics_B.bid1;\n        inverse_kinematics_B.bid2 = inverse_kinematics_B.result_data[3];\n        inverse_kinematics_B.bid1 = cos(inverse_kinematics_B.bid2);\n        inverse_kinematics_B.sth = sin(inverse_kinematics_B.bid2);\n        inverse_kinematics_B.bid2 = inverse_kinematics_B.v[0] *\n          inverse_kinematics_B.v[1] * (1.0 - inverse_kinematics_B.bid1);\n        inverse_kinematics_B.bid1_tmp = inverse_kinematics_B.v[2] *\n          inverse_kinematics_B.sth;\n        inverse_kinematics_B.tempR_tmp = inverse_kinematics_B.v[0] *\n          inverse_kinematics_B.v[2] * (1.0 - inverse_kinematics_B.bid1);\n        inverse_kinematics_B.tempR_tmp_m = inverse_kinematics_B.v[1] *\n          inverse_kinematics_B.sth;\n        inverse_kinematics_B.tempR_tmp_c = inverse_kinematics_B.v[1] *\n          inverse_kinematics_B.v[2] * (1.0 - inverse_kinematics_B.bid1);\n        inverse_kinematics_B.sth *= inverse_kinematics_B.v[0];\n        inverse_kinematics_cat(inverse_kinematics_B.v[0] *\n          inverse_kinematics_B.v[0] * (1.0 - inverse_kinematics_B.bid1) +\n          inverse_kinematics_B.bid1, inverse_kinematics_B.bid2 -\n          inverse_kinematics_B.bid1_tmp, inverse_kinematics_B.tempR_tmp +\n          inverse_kinematics_B.tempR_tmp_m, inverse_kinematics_B.bid2 +\n          inverse_kinematics_B.bid1_tmp, inverse_kinematics_B.v[1] *\n          inverse_kinematics_B.v[1] * (1.0 - inverse_kinematics_B.bid1) +\n          inverse_kinematics_B.bid1, inverse_kinematics_B.tempR_tmp_c -\n          inverse_kinematics_B.sth, inverse_kinematics_B.tempR_tmp -\n          inverse_kinematics_B.tempR_tmp_m, inverse_kinematics_B.tempR_tmp_c +\n          inverse_kinematics_B.sth, inverse_kinematics_B.v[2] *\n          inverse_kinematics_B.v[2] * (1.0 - inverse_kinematics_B.bid1) +\n          inverse_kinematics_B.bid1, inverse_kinematics_B.tempR);\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.R[inverse_kinematics_B.i_c] =\n            inverse_kinematics_B.tempR[inverse_kinematics_B.i_c * 3];\n          inverse_kinematics_B.R[inverse_kinematics_B.i_c + 3] =\n            inverse_kinematics_B.tempR[inverse_kinematics_B.i_c * 3 + 1];\n          inverse_kinematics_B.R[inverse_kinematics_B.i_c + 6] =\n            inverse_kinematics_B.tempR[inverse_kinematics_B.i_c * 3 + 2];\n        }\n\n        memset(&inverse_kinematics_B.T1j[0], 0, sizeof(real_T) << 4U);\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c << 2;\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3 + 1] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 1];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3 + 2] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 2];\n        }\n\n        inverse_kinematics_B.T1j[15] = 1.0;\n        break;\n\n       default:\n        in_rigidBodyJoint_get_JointAxis(joint, inverse_kinematics_B.v);\n        memset(&inverse_kinematics_B.tempR[0], 0, 9U * sizeof(real_T));\n        inverse_kinematics_B.tempR[0] = 1.0;\n        inverse_kinematics_B.tempR[4] = 1.0;\n        inverse_kinematics_B.tempR[8] = 1.0;\n        inverse_kinematics_B.bid1 = qv[inverse_kinematics_B.g];\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c << 2;\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] =\n            inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3 + 1] =\n            inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c + 1];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3 + 2] =\n            inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c + 2];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.i_c + 12] =\n            inverse_kinematics_B.v[inverse_kinematics_B.i_c] *\n            inverse_kinematics_B.bid1;\n        }\n\n        inverse_kinematics_B.T1j[3] = 0.0;\n        inverse_kinematics_B.T1j[7] = 0.0;\n        inverse_kinematics_B.T1j[11] = 0.0;\n        inverse_kinematics_B.T1j[15] = 1.0;\n        break;\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 16;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.b[inverse_kinematics_B.i_c] =\n          joint->ChildToJointTransform[inverse_kinematics_B.i_c];\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 4;\n           inverse_kinematics_B.i_c++) {\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 4;\n             inverse_kinematics_B.g++) {\n          inverse_kinematics_B.f = inverse_kinematics_B.g << 2;\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c +\n            inverse_kinematics_B.f;\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] = 0.0;\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1j[inverse_kinematics_B.f] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1j[inverse_kinematics_B.f + 1] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 4];\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1j[inverse_kinematics_B.f + 2] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 8];\n          inverse_kinematics_B.Tj_k[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1j[inverse_kinematics_B.f + 3] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 12];\n        }\n\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 4;\n             inverse_kinematics_B.g++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.g << 2;\n          inverse_kinematics_B.f = inverse_kinematics_B.i_c +\n            inverse_kinematics_B.loop_ub_o3;\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] = 0.0;\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.b[inverse_kinematics_B.loop_ub_o3] *\n            inverse_kinematics_B.Tj_k[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.b[inverse_kinematics_B.loop_ub_o3 + 1] *\n            inverse_kinematics_B.Tj_k[inverse_kinematics_B.i_c + 4];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.b[inverse_kinematics_B.loop_ub_o3 + 2] *\n            inverse_kinematics_B.Tj_k[inverse_kinematics_B.i_c + 8];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.b[inverse_kinematics_B.loop_ub_o3 + 3] *\n            inverse_kinematics_B.Tj_k[inverse_kinematics_B.i_c + 12];\n        }\n      }\n\n      inverse_kinematics_B.i_c = static_cast<int32_T>(body2->Index);\n      inverse_kinematics_B.bid1 = obj->VelocityDoFMap[inverse_kinematics_B.i_c -\n        1];\n      inverse_kinematics_B.bid2 = obj->VelocityDoFMap[inverse_kinematics_B.i_c +\n        5];\n      if (inverse_kinematics_B.nextBodyIsParent) {\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 16;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c] =\n            joint->ChildToJointTransform[inverse_kinematics_B.i_c];\n        }\n      } else {\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 16;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.T1j[inverse_kinematics_B.i_c] =\n            joint->JointToParentTransform[inverse_kinematics_B.i_c];\n        }\n\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c] =\n            inverse_kinematics_B.T1j[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 1] =\n            inverse_kinematics_B.T1j[inverse_kinematics_B.i_c + 4];\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 2] =\n            inverse_kinematics_B.T1j[inverse_kinematics_B.i_c + 8];\n        }\n\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 9;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.tempR[inverse_kinematics_B.i_c] =\n            -inverse_kinematics_B.R[inverse_kinematics_B.i_c];\n        }\n\n        for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n             inverse_kinematics_B.i_c++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c << 2;\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c];\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3 + 1] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 1];\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3 + 2] =\n            inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 2];\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 12] =\n            (inverse_kinematics_B.tempR[inverse_kinematics_B.i_c + 3] *\n             inverse_kinematics_B.T1j[13] +\n             inverse_kinematics_B.tempR[inverse_kinematics_B.i_c] *\n             inverse_kinematics_B.T1j[12]) +\n            inverse_kinematics_B.tempR[inverse_kinematics_B.i_c + 6] *\n            inverse_kinematics_B.T1j[14];\n        }\n\n        inverse_kinematics_B.Tj_c[3] = 0.0;\n        inverse_kinematics_B.Tj_c[7] = 0.0;\n        inverse_kinematics_B.Tj_c[11] = 0.0;\n        inverse_kinematics_B.Tj_c[15] = 1.0;\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 4;\n           inverse_kinematics_B.i_c++) {\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 4;\n             inverse_kinematics_B.g++) {\n          inverse_kinematics_B.f = inverse_kinematics_B.g << 2;\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c +\n            inverse_kinematics_B.f;\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] = 0.0;\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.f] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.f + 1] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 4];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.f + 2] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 8];\n          inverse_kinematics_B.T1j[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.f + 3] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 12];\n        }\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c] =\n          inverse_kinematics_B.T1j[inverse_kinematics_B.i_c];\n        inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 1] =\n          inverse_kinematics_B.T1j[inverse_kinematics_B.i_c + 4];\n        inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 2] =\n          inverse_kinematics_B.T1j[inverse_kinematics_B.i_c + 8];\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 9;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.tempR[inverse_kinematics_B.i_c] =\n          -inverse_kinematics_B.R[inverse_kinematics_B.i_c];\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c << 2;\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3] =\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c];\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3 + 1] =\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 1];\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3 + 2] =\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 2];\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 12] =\n          (inverse_kinematics_B.tempR[inverse_kinematics_B.i_c + 3] *\n           inverse_kinematics_B.T1j[13] +\n           inverse_kinematics_B.tempR[inverse_kinematics_B.i_c] *\n           inverse_kinematics_B.T1j[12]) +\n          inverse_kinematics_B.tempR[inverse_kinematics_B.i_c + 6] *\n          inverse_kinematics_B.T1j[14];\n      }\n\n      inverse_kinematics_B.Tj_c[3] = 0.0;\n      inverse_kinematics_B.Tj_c[7] = 0.0;\n      inverse_kinematics_B.Tj_c[11] = 0.0;\n      inverse_kinematics_B.Tj_c[15] = 1.0;\n      inverse_kinematics_B.result_data_tmp = b->size[0] * b->size[1];\n      b->size[0] = 6;\n      b->size[1] = joint->MotionSubspace->size[1];\n      invers_emxEnsureCapacity_real_T(b, inverse_kinematics_B.result_data_tmp);\n      inverse_kinematics_B.loop_ub_o3 = 6 * joint->MotionSubspace->size[1];\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c <\n           inverse_kinematics_B.loop_ub_o3; inverse_kinematics_B.i_c++) {\n        b->data[inverse_kinematics_B.i_c] = joint->MotionSubspace->\n          data[inverse_kinematics_B.i_c];\n      }\n\n      if (inverse_kinematics_B.bid1 > inverse_kinematics_B.bid2) {\n        inverse_kinematics_B.f = 0;\n      } else {\n        inverse_kinematics_B.f = static_cast<int32_T>(inverse_kinematics_B.bid1)\n          - 1;\n      }\n\n      inverse_kinematics_B.R[0] = 0.0;\n      inverse_kinematics_B.R[3] = -inverse_kinematics_B.Tj_c[14];\n      inverse_kinematics_B.R[6] = inverse_kinematics_B.Tj_c[13];\n      inverse_kinematics_B.R[1] = inverse_kinematics_B.Tj_c[14];\n      inverse_kinematics_B.R[4] = 0.0;\n      inverse_kinematics_B.R[7] = -inverse_kinematics_B.Tj_c[12];\n      inverse_kinematics_B.R[2] = -inverse_kinematics_B.Tj_c[13];\n      inverse_kinematics_B.R[5] = inverse_kinematics_B.Tj_c[12];\n      inverse_kinematics_B.R[8] = 0.0;\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n           inverse_kinematics_B.i_c++) {\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 3;\n             inverse_kinematics_B.g++) {\n          inverse_kinematics_B.loop_ub_o3 = 3 * inverse_kinematics_B.g +\n            inverse_kinematics_B.i_c;\n          inverse_kinematics_B.tempR[inverse_kinematics_B.loop_ub_o3] = 0.0;\n          inverse_kinematics_B.result_data_tmp = inverse_kinematics_B.g << 2;\n          inverse_kinematics_B.tempR[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.result_data_tmp] *\n            inverse_kinematics_B.R[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.tempR[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.result_data_tmp + 1] *\n            inverse_kinematics_B.R[inverse_kinematics_B.i_c + 3];\n          inverse_kinematics_B.tempR[inverse_kinematics_B.loop_ub_o3] +=\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.result_data_tmp + 2] *\n            inverse_kinematics_B.R[inverse_kinematics_B.i_c + 6];\n          inverse_kinematics_B.Tj[inverse_kinematics_B.g + 6 *\n            inverse_kinematics_B.i_c] = inverse_kinematics_B.Tj_c\n            [(inverse_kinematics_B.i_c << 2) + inverse_kinematics_B.g];\n          inverse_kinematics_B.Tj[inverse_kinematics_B.g + 6 *\n            (inverse_kinematics_B.i_c + 3)] = 0.0;\n        }\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c + 3] =\n          inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c];\n        inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.i_c << 2;\n        inverse_kinematics_B.g = (inverse_kinematics_B.i_c + 3) * 6;\n        inverse_kinematics_B.Tj[inverse_kinematics_B.g + 3] =\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3];\n        inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c + 4] =\n          inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c + 1];\n        inverse_kinematics_B.Tj[inverse_kinematics_B.g + 4] =\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3 + 1];\n        inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c + 5] =\n          inverse_kinematics_B.tempR[3 * inverse_kinematics_B.i_c + 2];\n        inverse_kinematics_B.Tj[inverse_kinematics_B.g + 5] =\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.loop_ub_o3 + 2];\n      }\n\n      inverse_kinematics_mtimes(inverse_kinematics_B.Tj, b, tmp);\n      inverse_kinematics_B.loop_ub_o3 = tmp->size[1];\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c <\n           inverse_kinematics_B.loop_ub_o3; inverse_kinematics_B.i_c++) {\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 6;\n             inverse_kinematics_B.g++) {\n          Jac->data[inverse_kinematics_B.g + 6 * (inverse_kinematics_B.f +\n            inverse_kinematics_B.i_c)] = tmp->data[6 * inverse_kinematics_B.i_c\n            + inverse_kinematics_B.g] * static_cast<real_T>\n            (inverse_kinematics_B.jointSign);\n        }\n      }\n    }\n\n    if (inverse_kinematics_B.nextBodyIsParent) {\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 4;\n           inverse_kinematics_B.i_c++) {\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 4;\n             inverse_kinematics_B.g++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.g << 2;\n          inverse_kinematics_B.f = inverse_kinematics_B.i_c +\n            inverse_kinematics_B.loop_ub_o3;\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.f] = 0.0;\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.loop_ub_o3] *\n            inverse_kinematics_B.Tc2p[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.loop_ub_o3 + 1] *\n            inverse_kinematics_B.Tc2p[inverse_kinematics_B.i_c + 4];\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.loop_ub_o3 + 2] *\n            inverse_kinematics_B.Tc2p[inverse_kinematics_B.i_c + 8];\n          inverse_kinematics_B.Tj_c[inverse_kinematics_B.f] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.loop_ub_o3 + 3] *\n            inverse_kinematics_B.Tc2p[inverse_kinematics_B.i_c + 12];\n        }\n      }\n\n      memcpy(&inverse_kinematics_B.T1[0], &inverse_kinematics_B.Tj_c[0], sizeof\n             (real_T) << 4U);\n    } else {\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c] =\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.i_c];\n        inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 1] =\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.i_c + 4];\n        inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 2] =\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.i_c + 8];\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 9;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.tempR[inverse_kinematics_B.i_c] =\n          -inverse_kinematics_B.R[inverse_kinematics_B.i_c];\n      }\n\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n           inverse_kinematics_B.i_c++) {\n        inverse_kinematics_B.jointSign = inverse_kinematics_B.i_c << 2;\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.jointSign] =\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c];\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.jointSign + 1] =\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 1];\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.jointSign + 2] =\n          inverse_kinematics_B.R[3 * inverse_kinematics_B.i_c + 2];\n        inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 12] =\n          (inverse_kinematics_B.tempR[inverse_kinematics_B.i_c + 3] *\n           inverse_kinematics_B.Tc2p[13] +\n           inverse_kinematics_B.tempR[inverse_kinematics_B.i_c] *\n           inverse_kinematics_B.Tc2p[12]) +\n          inverse_kinematics_B.tempR[inverse_kinematics_B.i_c + 6] *\n          inverse_kinematics_B.Tc2p[14];\n      }\n\n      inverse_kinematics_B.Tj_c[3] = 0.0;\n      inverse_kinematics_B.Tj_c[7] = 0.0;\n      inverse_kinematics_B.Tj_c[11] = 0.0;\n      inverse_kinematics_B.Tj_c[15] = 1.0;\n      for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 4;\n           inverse_kinematics_B.i_c++) {\n        for (inverse_kinematics_B.g = 0; inverse_kinematics_B.g < 4;\n             inverse_kinematics_B.g++) {\n          inverse_kinematics_B.loop_ub_o3 = inverse_kinematics_B.g << 2;\n          inverse_kinematics_B.jointSign = inverse_kinematics_B.i_c +\n            inverse_kinematics_B.loop_ub_o3;\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.jointSign] = 0.0;\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.jointSign] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.loop_ub_o3] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.jointSign] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.loop_ub_o3 + 1] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 4];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.jointSign] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.loop_ub_o3 + 2] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 8];\n          inverse_kinematics_B.Tc2p[inverse_kinematics_B.jointSign] +=\n            inverse_kinematics_B.T1[inverse_kinematics_B.loop_ub_o3 + 3] *\n            inverse_kinematics_B.Tj_c[inverse_kinematics_B.i_c + 12];\n        }\n      }\n\n      memcpy(&inverse_kinematics_B.T1[0], &inverse_kinematics_B.Tc2p[0], sizeof\n             (real_T) << 4U);\n    }\n  }\n\n  inverse_kinemati_emxFree_real_T(&tmp);\n  inverse_kinemati_emxFree_real_T(&b);\n  inverse_kinemati_emxFree_char_T(&body2Name);\n  inverse_kinemati_emxFree_real_T(&kinematicPathIndices);\n  for (inverse_kinematics_B.i_c = 0; inverse_kinematics_B.i_c < 3;\n       inverse_kinematics_B.i_c++) {\n    inverse_kinematics_B.Jac = inverse_kinematics_B.i_c << 2;\n    inverse_kinematics_B.bid1 = inverse_kinematics_B.T1[inverse_kinematics_B.Jac];\n    inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c] =\n      inverse_kinematics_B.bid1;\n    inverse_kinematics_B.c_g = (inverse_kinematics_B.i_c + 3) * 6;\n    inverse_kinematics_B.Tj[inverse_kinematics_B.c_g] = 0.0;\n    inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c + 3] = 0.0;\n    inverse_kinematics_B.Tj[inverse_kinematics_B.c_g + 3] =\n      inverse_kinematics_B.bid1;\n    inverse_kinematics_B.bid1 = inverse_kinematics_B.T1[inverse_kinematics_B.Jac\n      + 1];\n    inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c + 1] =\n      inverse_kinematics_B.bid1;\n    inverse_kinematics_B.Tj[inverse_kinematics_B.c_g + 1] = 0.0;\n    inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c + 4] = 0.0;\n    inverse_kinematics_B.Tj[inverse_kinematics_B.c_g + 4] =\n      inverse_kinematics_B.bid1;\n    inverse_kinematics_B.bid1 = inverse_kinematics_B.T1[inverse_kinematics_B.Jac\n      + 2];\n    inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c + 2] =\n      inverse_kinematics_B.bid1;\n    inverse_kinematics_B.Tj[inverse_kinematics_B.c_g + 2] = 0.0;\n    inverse_kinematics_B.Tj[6 * inverse_kinematics_B.i_c + 5] = 0.0;\n    inverse_kinematics_B.Tj[inverse_kinematics_B.c_g + 5] =\n      inverse_kinematics_B.bid1;\n  }\n\n  inverse_kinemati_emxInit_real_T(&Jac_0, 2);\n  inverse_kinematics_B.result_data_tmp = Jac_0->size[0] * Jac_0->size[1];\n  Jac_0->size[0] = 6;\n  Jac_0->size[1] = Jac->size[1];\n  invers_emxEnsureCapacity_real_T(Jac_0, inverse_kinematics_B.result_data_tmp);\n  inverse_kinematics_B.loop_ub_o3 = Jac->size[0] * Jac->size[1] - 1;\n  if (inverse_kinematics_B.loop_ub_o3 >= 0) {\n    memcpy(&Jac_0->data[0], &Jac->data[0], (inverse_kinematics_B.loop_ub_o3 + 1)\n           * sizeof(real_T));\n  }\n\n  inverse_kinematics_mtimes(inverse_kinematics_B.Tj, Jac_0, Jac);\n  T_size[0] = 4;\n  T_size[1] = 4;\n  inverse_kinemati_emxFree_real_T(&Jac_0);\n  memcpy(&T_data[0], &inverse_kinematics_B.T1[0], sizeof(real_T) << 4U);\n}\n\nreal_T rt_hypotd_snf(real_T u0, real_T u1)\n{\n  real_T a;\n  real_T y;\n  a = fabs(u0);\n  y = fabs(u1);\n  if (a < y) {\n    a /= y;\n    y *= sqrt(a * a + 1.0);\n  } else if (a > y) {\n    y /= a;\n    y = sqrt(y * y + 1.0) * a;\n  } else if (!rtIsNaN(y)) {\n    y = a * 1.4142135623730951;\n  }\n\n  return y;\n}\n\nstatic creal_T inverse_kinematics_sqrt(const creal_T x)\n{\n  creal_T b_x;\n  real_T absxi;\n  real_T absxr;\n  if (x.im == 0.0) {\n    if (x.re < 0.0) {\n      absxr = 0.0;\n      absxi = sqrt(-x.re);\n    } else {\n      absxr = sqrt(x.re);\n      absxi = 0.0;\n    }\n  } else if (x.re == 0.0) {\n    if (x.im < 0.0) {\n      absxr = sqrt(-x.im / 2.0);\n      absxi = -absxr;\n    } else {\n      absxr = sqrt(x.im / 2.0);\n      absxi = absxr;\n    }\n  } else if (rtIsNaN(x.re)) {\n    absxr = x.re;\n    absxi = x.re;\n  } else if (rtIsNaN(x.im)) {\n    absxr = x.im;\n    absxi = x.im;\n  } else if (rtIsInf(x.im)) {\n    absxr = fabs(x.im);\n    absxi = x.im;\n  } else if (rtIsInf(x.re)) {\n    if (x.re < 0.0) {\n      absxr = 0.0;\n      absxi = x.im * -x.re;\n    } else {\n      absxr = x.re;\n      absxi = 0.0;\n    }\n  } else {\n    absxr = fabs(x.re);\n    absxi = fabs(x.im);\n    if ((absxr > 4.4942328371557893E+307) || (absxi > 4.4942328371557893E+307))\n    {\n      absxr *= 0.5;\n      absxi = rt_hypotd_snf(absxr, absxi * 0.5);\n      if (absxi > absxr) {\n        absxr = sqrt(absxr / absxi + 1.0) * sqrt(absxi);\n      } else {\n        absxr = sqrt(absxi) * 1.4142135623730951;\n      }\n    } else {\n      absxr = sqrt((rt_hypotd_snf(absxr, absxi) + absxr) * 0.5);\n    }\n\n    if (x.re > 0.0) {\n      absxi = x.im / absxr * 0.5;\n    } else {\n      if (x.im < 0.0) {\n        absxi = -absxr;\n      } else {\n        absxi = absxr;\n      }\n\n      absxr = x.im / absxi * 0.5;\n    }\n  }\n\n  b_x.re = absxr;\n  b_x.im = absxi;\n  return b_x;\n}\n\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\n{\n  real_T y;\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\n    y = (rtNaN);\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\n    int32_T u0_0;\n    int32_T u1_0;\n    if (u0 > 0.0) {\n      u0_0 = 1;\n    } else {\n      u0_0 = -1;\n    }\n\n    if (u1 > 0.0) {\n      u1_0 = 1;\n    } else {\n      u1_0 = -1;\n    }\n\n    y = atan2(static_cast<real_T>(u0_0), static_cast<real_T>(u1_0));\n  } else if (u1 == 0.0) {\n    if (u0 > 0.0) {\n      y = RT_PI / 2.0;\n    } else if (u0 < 0.0) {\n      y = -(RT_PI / 2.0);\n    } else {\n      y = 0.0;\n    }\n  } else {\n    y = atan2(u0, u1);\n  }\n\n  return y;\n}\n\nstatic real_T inverse_kinematics_xnrm2(int32_T n, const real_T x[9], int32_T ix0)\n{\n  real_T scale;\n  real_T y;\n  int32_T kend;\n  y = 0.0;\n  scale = 3.3121686421112381E-170;\n  kend = ix0 + n;\n  for (int32_T k = ix0; k < kend; k++) {\n    real_T absxk;\n    absxk = fabs(x[k - 1]);\n    if (absxk > scale) {\n      real_T t;\n      t = scale / absxk;\n      y = y * t * t + 1.0;\n      scale = absxk;\n    } else {\n      real_T t;\n      t = absxk / scale;\n      y += t * t;\n    }\n  }\n\n  return scale * sqrt(y);\n}\n\nstatic real_T inverse_kinematics_xdotc(int32_T n, const real_T x[9], int32_T ix0,\n  const real_T y[9], int32_T iy0)\n{\n  real_T d;\n  d = 0.0;\n  for (int32_T k = 0; k < n; k++) {\n    d += x[(ix0 + k) - 1] * y[(iy0 + k) - 1];\n  }\n\n  return d;\n}\n\nstatic void inverse_kinematics_xaxpy(int32_T n, real_T a, int32_T ix0, const\n  real_T y[9], int32_T iy0, real_T b_y[9])\n{\n  memcpy(&b_y[0], &y[0], 9U * sizeof(real_T));\n  if (!(a == 0.0)) {\n    for (int32_T k = 0; k < n; k++) {\n      int32_T b_y_tmp;\n      b_y_tmp = (iy0 + k) - 1;\n      b_y[b_y_tmp] += b_y[(ix0 + k) - 1] * a;\n    }\n  }\n}\n\nstatic real_T inverse_kinematics_xnrm2_g(const real_T x[3], int32_T ix0)\n{\n  real_T scale;\n  real_T y;\n  y = 0.0;\n  scale = 3.3121686421112381E-170;\n  for (int32_T k = ix0; k <= ix0 + 1; k++) {\n    real_T absxk;\n    absxk = fabs(x[k - 1]);\n    if (absxk > scale) {\n      real_T t;\n      t = scale / absxk;\n      y = y * t * t + 1.0;\n      scale = absxk;\n    } else {\n      real_T t;\n      t = absxk / scale;\n      y += t * t;\n    }\n  }\n\n  return scale * sqrt(y);\n}\n\nstatic void inverse_kinematics_xaxpy_gaq(int32_T n, real_T a, const real_T x[9],\n  int32_T ix0, real_T y[3], int32_T iy0)\n{\n  if (!(a == 0.0)) {\n    for (int32_T k = 0; k < n; k++) {\n      int32_T tmp;\n      tmp = (iy0 + k) - 1;\n      y[tmp] += x[(ix0 + k) - 1] * a;\n    }\n  }\n}\n\nstatic void inverse_kinematics_xaxpy_ga(int32_T n, real_T a, const real_T x[3],\n  int32_T ix0, const real_T y[9], int32_T iy0, real_T b_y[9])\n{\n  memcpy(&b_y[0], &y[0], 9U * sizeof(real_T));\n  if (!(a == 0.0)) {\n    for (int32_T k = 0; k < n; k++) {\n      int32_T b_y_tmp;\n      b_y_tmp = (iy0 + k) - 1;\n      b_y[b_y_tmp] += x[(ix0 + k) - 1] * a;\n    }\n  }\n}\n\nstatic void inverse_kinematics_xswap(const real_T x[9], int32_T ix0, int32_T iy0,\n  real_T b_x[9])\n{\n  real_T temp;\n  memcpy(&b_x[0], &x[0], 9U * sizeof(real_T));\n  temp = b_x[ix0 - 1];\n  b_x[ix0 - 1] = b_x[iy0 - 1];\n  b_x[iy0 - 1] = temp;\n  temp = b_x[ix0];\n  b_x[ix0] = b_x[iy0];\n  b_x[iy0] = temp;\n  temp = b_x[ix0 + 1];\n  b_x[ix0 + 1] = b_x[iy0 + 1];\n  b_x[iy0 + 1] = temp;\n}\n\nstatic void inverse_kinematics_xrotg(real_T a, real_T b, real_T *b_a, real_T\n  *b_b, real_T *c, real_T *s)\n{\n  inverse_kinematics_B.roe = b;\n  inverse_kinematics_B.absa = fabs(a);\n  inverse_kinematics_B.absb = fabs(b);\n  if (inverse_kinematics_B.absa > inverse_kinematics_B.absb) {\n    inverse_kinematics_B.roe = a;\n  }\n\n  inverse_kinematics_B.scale_c = inverse_kinematics_B.absa +\n    inverse_kinematics_B.absb;\n  if (inverse_kinematics_B.scale_c == 0.0) {\n    *s = 0.0;\n    *c = 1.0;\n    *b_a = 0.0;\n    *b_b = 0.0;\n  } else {\n    inverse_kinematics_B.ads = inverse_kinematics_B.absa /\n      inverse_kinematics_B.scale_c;\n    inverse_kinematics_B.bds = inverse_kinematics_B.absb /\n      inverse_kinematics_B.scale_c;\n    *b_a = sqrt(inverse_kinematics_B.ads * inverse_kinematics_B.ads +\n                inverse_kinematics_B.bds * inverse_kinematics_B.bds) *\n      inverse_kinematics_B.scale_c;\n    if (inverse_kinematics_B.roe < 0.0) {\n      *b_a = -*b_a;\n    }\n\n    *c = a / *b_a;\n    *s = b / *b_a;\n    if (inverse_kinematics_B.absa > inverse_kinematics_B.absb) {\n      *b_b = *s;\n    } else if (*c != 0.0) {\n      *b_b = 1.0 / *c;\n    } else {\n      *b_b = 1.0;\n    }\n  }\n}\n\nstatic void inverse_kinematics_xrot(const real_T x[9], int32_T ix0, int32_T iy0,\n  real_T c, real_T s, real_T b_x[9])\n{\n  real_T temp;\n  real_T temp_tmp;\n  memcpy(&b_x[0], &x[0], 9U * sizeof(real_T));\n  temp = b_x[iy0 - 1];\n  temp_tmp = b_x[ix0 - 1];\n  b_x[iy0 - 1] = temp * c - temp_tmp * s;\n  b_x[ix0 - 1] = temp_tmp * c + temp * s;\n  temp = b_x[ix0] * c + b_x[iy0] * s;\n  b_x[iy0] = b_x[iy0] * c - b_x[ix0] * s;\n  b_x[ix0] = temp;\n  temp = b_x[iy0 + 1];\n  temp_tmp = b_x[ix0 + 1];\n  b_x[iy0 + 1] = temp * c - temp_tmp * s;\n  b_x[ix0 + 1] = temp_tmp * c + temp * s;\n}\n\nstatic void inverse_kinematics_svd(const real_T A[9], real_T U[9], real_T s[3],\n  real_T V[9])\n{\n  inverse_kinematics_B.s[0] = 0.0;\n  inverse_kinematics_B.e_d[0] = 0.0;\n  inverse_kinematics_B.work[0] = 0.0;\n  inverse_kinematics_B.s[1] = 0.0;\n  inverse_kinematics_B.e_d[1] = 0.0;\n  inverse_kinematics_B.work[1] = 0.0;\n  inverse_kinematics_B.s[2] = 0.0;\n  inverse_kinematics_B.e_d[2] = 0.0;\n  inverse_kinematics_B.work[2] = 0.0;\n  for (inverse_kinematics_B.m_e = 0; inverse_kinematics_B.m_e < 9;\n       inverse_kinematics_B.m_e++) {\n    inverse_kinematics_B.A[inverse_kinematics_B.m_e] =\n      A[inverse_kinematics_B.m_e];\n    U[inverse_kinematics_B.m_e] = 0.0;\n    V[inverse_kinematics_B.m_e] = 0.0;\n  }\n\n  for (inverse_kinematics_B.m_e = 0; inverse_kinematics_B.m_e < 2;\n       inverse_kinematics_B.m_e++) {\n    inverse_kinematics_B.q_j = inverse_kinematics_B.m_e + 1;\n    inverse_kinematics_B.qp1 = inverse_kinematics_B.m_e + 2;\n    inverse_kinematics_B.qq_tmp = inverse_kinematics_B.m_e * 3 +\n      inverse_kinematics_B.m_e;\n    inverse_kinematics_B.qq = inverse_kinematics_B.qq_tmp + 1;\n    inverse_kinematics_B.apply_transform = false;\n    inverse_kinematics_B.nrm = inverse_kinematics_xnrm2(3 -\n      inverse_kinematics_B.m_e, inverse_kinematics_B.A,\n      inverse_kinematics_B.qq_tmp + 1);\n    if (inverse_kinematics_B.nrm > 0.0) {\n      inverse_kinematics_B.apply_transform = true;\n      if (inverse_kinematics_B.A[inverse_kinematics_B.qq_tmp] < 0.0) {\n        inverse_kinematics_B.s[inverse_kinematics_B.m_e] =\n          -inverse_kinematics_B.nrm;\n      } else {\n        inverse_kinematics_B.s[inverse_kinematics_B.m_e] =\n          inverse_kinematics_B.nrm;\n      }\n\n      if (fabs(inverse_kinematics_B.s[inverse_kinematics_B.m_e]) >=\n          1.0020841800044864E-292) {\n        inverse_kinematics_B.nrm = 1.0 /\n          inverse_kinematics_B.s[inverse_kinematics_B.m_e];\n        inverse_kinematics_B.b_ol = inverse_kinematics_B.qq_tmp -\n          inverse_kinematics_B.m_e;\n        for (inverse_kinematics_B.qjj = inverse_kinematics_B.qq;\n             inverse_kinematics_B.qjj <= inverse_kinematics_B.b_ol + 3;\n             inverse_kinematics_B.qjj++) {\n          inverse_kinematics_B.A[inverse_kinematics_B.qjj - 1] *=\n            inverse_kinematics_B.nrm;\n        }\n      } else {\n        inverse_kinematics_B.b_ol = inverse_kinematics_B.qq_tmp -\n          inverse_kinematics_B.m_e;\n        for (inverse_kinematics_B.qjj = inverse_kinematics_B.qq;\n             inverse_kinematics_B.qjj <= inverse_kinematics_B.b_ol + 3;\n             inverse_kinematics_B.qjj++) {\n          inverse_kinematics_B.A[inverse_kinematics_B.qjj - 1] /=\n            inverse_kinematics_B.s[inverse_kinematics_B.m_e];\n        }\n      }\n\n      inverse_kinematics_B.A[inverse_kinematics_B.qq_tmp]++;\n      inverse_kinematics_B.s[inverse_kinematics_B.m_e] =\n        -inverse_kinematics_B.s[inverse_kinematics_B.m_e];\n    } else {\n      inverse_kinematics_B.s[inverse_kinematics_B.m_e] = 0.0;\n    }\n\n    for (inverse_kinematics_B.qq = inverse_kinematics_B.qp1;\n         inverse_kinematics_B.qq < 4; inverse_kinematics_B.qq++) {\n      inverse_kinematics_B.qjj = ((inverse_kinematics_B.qq - 1) * 3 +\n        inverse_kinematics_B.m_e) + 1;\n      if (inverse_kinematics_B.apply_transform) {\n        memcpy(&inverse_kinematics_B.A_g[0], &inverse_kinematics_B.A[0], 9U *\n               sizeof(real_T));\n        inverse_kinematics_xaxpy(3 - inverse_kinematics_B.m_e,\n          -(inverse_kinematics_xdotc(3 - inverse_kinematics_B.m_e,\n          inverse_kinematics_B.A, inverse_kinematics_B.qq_tmp + 1,\n          inverse_kinematics_B.A, inverse_kinematics_B.qjj) /\n            inverse_kinematics_B.A[inverse_kinematics_B.qq_tmp]),\n          inverse_kinematics_B.qq_tmp + 1, inverse_kinematics_B.A_g,\n          inverse_kinematics_B.qjj, inverse_kinematics_B.A);\n      }\n\n      inverse_kinematics_B.e_d[inverse_kinematics_B.qq - 1] =\n        inverse_kinematics_B.A[inverse_kinematics_B.qjj - 1];\n    }\n\n    memcpy(&U[(inverse_kinematics_B.m_e * 3 + inverse_kinematics_B.q_j) + -1],\n           &inverse_kinematics_B.A[(inverse_kinematics_B.m_e * 3 +\n            inverse_kinematics_B.q_j) + -1], (-inverse_kinematics_B.q_j + 4) *\n           sizeof(real_T));\n    if (inverse_kinematics_B.m_e + 1 <= 1) {\n      inverse_kinematics_B.nrm = inverse_kinematics_xnrm2_g\n        (inverse_kinematics_B.e_d, 2);\n      if (inverse_kinematics_B.nrm == 0.0) {\n        inverse_kinematics_B.e_d[0] = 0.0;\n      } else {\n        if (inverse_kinematics_B.e_d[1] < 0.0) {\n          inverse_kinematics_B.rt = -inverse_kinematics_B.nrm;\n          inverse_kinematics_B.e_d[0] = -inverse_kinematics_B.nrm;\n        } else {\n          inverse_kinematics_B.rt = inverse_kinematics_B.nrm;\n          inverse_kinematics_B.e_d[0] = inverse_kinematics_B.nrm;\n        }\n\n        if (fabs(inverse_kinematics_B.rt) >= 1.0020841800044864E-292) {\n          inverse_kinematics_B.nrm = 1.0 / inverse_kinematics_B.rt;\n          for (inverse_kinematics_B.qjj = inverse_kinematics_B.qp1;\n               inverse_kinematics_B.qjj < 4; inverse_kinematics_B.qjj++) {\n            inverse_kinematics_B.e_d[inverse_kinematics_B.qjj - 1] *=\n              inverse_kinematics_B.nrm;\n          }\n        } else {\n          for (inverse_kinematics_B.qjj = inverse_kinematics_B.qp1;\n               inverse_kinematics_B.qjj < 4; inverse_kinematics_B.qjj++) {\n            inverse_kinematics_B.e_d[inverse_kinematics_B.qjj - 1] /=\n              inverse_kinematics_B.rt;\n          }\n        }\n\n        inverse_kinematics_B.e_d[1]++;\n        inverse_kinematics_B.e_d[0] = -inverse_kinematics_B.e_d[0];\n        for (inverse_kinematics_B.q_j = inverse_kinematics_B.qp1;\n             inverse_kinematics_B.q_j < 4; inverse_kinematics_B.q_j++) {\n          inverse_kinematics_B.work[inverse_kinematics_B.q_j - 1] = 0.0;\n        }\n\n        for (inverse_kinematics_B.q_j = inverse_kinematics_B.qp1;\n             inverse_kinematics_B.q_j < 4; inverse_kinematics_B.q_j++) {\n          inverse_kinematics_xaxpy_gaq(2,\n            inverse_kinematics_B.e_d[inverse_kinematics_B.q_j - 1],\n            inverse_kinematics_B.A, 3 * (inverse_kinematics_B.q_j - 1) + 2,\n            inverse_kinematics_B.work, 2);\n        }\n\n        for (inverse_kinematics_B.q_j = inverse_kinematics_B.qp1;\n             inverse_kinematics_B.q_j < 4; inverse_kinematics_B.q_j++) {\n          memcpy(&inverse_kinematics_B.A_g[0], &inverse_kinematics_B.A[0], 9U *\n                 sizeof(real_T));\n          inverse_kinematics_xaxpy_ga(2,\n            -inverse_kinematics_B.e_d[inverse_kinematics_B.q_j - 1] /\n            inverse_kinematics_B.e_d[1], inverse_kinematics_B.work, 2,\n            inverse_kinematics_B.A_g, (inverse_kinematics_B.q_j - 1) * 3 + 2,\n            inverse_kinematics_B.A);\n        }\n      }\n\n      for (inverse_kinematics_B.q_j = inverse_kinematics_B.qp1;\n           inverse_kinematics_B.q_j < 4; inverse_kinematics_B.q_j++) {\n        V[inverse_kinematics_B.q_j - 1] =\n          inverse_kinematics_B.e_d[inverse_kinematics_B.q_j - 1];\n      }\n    }\n  }\n\n  inverse_kinematics_B.m_e = 2;\n  inverse_kinematics_B.s[2] = inverse_kinematics_B.A[8];\n  inverse_kinematics_B.e_d[1] = inverse_kinematics_B.A[7];\n  inverse_kinematics_B.e_d[2] = 0.0;\n  U[6] = 0.0;\n  U[7] = 0.0;\n  U[8] = 1.0;\n  for (inverse_kinematics_B.q_j = 1; inverse_kinematics_B.q_j >= 0;\n       inverse_kinematics_B.q_j--) {\n    inverse_kinematics_B.qq = 3 * inverse_kinematics_B.q_j +\n      inverse_kinematics_B.q_j;\n    if (inverse_kinematics_B.s[inverse_kinematics_B.q_j] != 0.0) {\n      for (inverse_kinematics_B.qp1 = inverse_kinematics_B.q_j + 2;\n           inverse_kinematics_B.qp1 < 4; inverse_kinematics_B.qp1++) {\n        inverse_kinematics_B.qjj = ((inverse_kinematics_B.qp1 - 1) * 3 +\n          inverse_kinematics_B.q_j) + 1;\n        memcpy(&inverse_kinematics_B.A[0], &U[0], 9U * sizeof(real_T));\n        inverse_kinematics_xaxpy(3 - inverse_kinematics_B.q_j,\n          -(inverse_kinematics_xdotc(3 - inverse_kinematics_B.q_j, U,\n          inverse_kinematics_B.qq + 1, U, inverse_kinematics_B.qjj) /\n            U[inverse_kinematics_B.qq]), inverse_kinematics_B.qq + 1,\n          inverse_kinematics_B.A, inverse_kinematics_B.qjj, U);\n      }\n\n      for (inverse_kinematics_B.qp1 = inverse_kinematics_B.q_j + 1;\n           inverse_kinematics_B.qp1 < 4; inverse_kinematics_B.qp1++) {\n        inverse_kinematics_B.qjj = (3 * inverse_kinematics_B.q_j +\n          inverse_kinematics_B.qp1) - 1;\n        U[inverse_kinematics_B.qjj] = -U[inverse_kinematics_B.qjj];\n      }\n\n      U[inverse_kinematics_B.qq]++;\n      if (inverse_kinematics_B.q_j - 1 >= 0) {\n        U[3 * inverse_kinematics_B.q_j] = 0.0;\n      }\n    } else {\n      U[3 * inverse_kinematics_B.q_j] = 0.0;\n      U[3 * inverse_kinematics_B.q_j + 1] = 0.0;\n      U[3 * inverse_kinematics_B.q_j + 2] = 0.0;\n      U[inverse_kinematics_B.qq] = 1.0;\n    }\n  }\n\n  for (inverse_kinematics_B.q_j = 2; inverse_kinematics_B.q_j >= 0;\n       inverse_kinematics_B.q_j--) {\n    if ((inverse_kinematics_B.q_j + 1 <= 1) && (inverse_kinematics_B.e_d[0] !=\n         0.0)) {\n      memcpy(&inverse_kinematics_B.A[0], &V[0], 9U * sizeof(real_T));\n      inverse_kinematics_xaxpy(2, -(inverse_kinematics_xdotc(2, V, 2, V, 5) / V\n        [1]), 2, inverse_kinematics_B.A, 5, V);\n      memcpy(&inverse_kinematics_B.A[0], &V[0], 9U * sizeof(real_T));\n      inverse_kinematics_xaxpy(2, -(inverse_kinematics_xdotc(2, V, 2, V, 8) / V\n        [1]), 2, inverse_kinematics_B.A, 8, V);\n    }\n\n    V[3 * inverse_kinematics_B.q_j] = 0.0;\n    V[3 * inverse_kinematics_B.q_j + 1] = 0.0;\n    V[3 * inverse_kinematics_B.q_j + 2] = 0.0;\n    V[inverse_kinematics_B.q_j + 3 * inverse_kinematics_B.q_j] = 1.0;\n  }\n\n  for (inverse_kinematics_B.q_j = 0; inverse_kinematics_B.q_j < 3;\n       inverse_kinematics_B.q_j++) {\n    inverse_kinematics_B.ztest =\n      inverse_kinematics_B.e_d[inverse_kinematics_B.q_j];\n    if (inverse_kinematics_B.s[inverse_kinematics_B.q_j] != 0.0) {\n      inverse_kinematics_B.rt = fabs\n        (inverse_kinematics_B.s[inverse_kinematics_B.q_j]);\n      inverse_kinematics_B.nrm = inverse_kinematics_B.s[inverse_kinematics_B.q_j]\n        / inverse_kinematics_B.rt;\n      inverse_kinematics_B.s[inverse_kinematics_B.q_j] = inverse_kinematics_B.rt;\n      if (inverse_kinematics_B.q_j + 1 < 3) {\n        inverse_kinematics_B.ztest /= inverse_kinematics_B.nrm;\n      }\n\n      inverse_kinematics_B.qp1 = 3 * inverse_kinematics_B.q_j;\n      for (inverse_kinematics_B.qjj = inverse_kinematics_B.qp1 + 1;\n           inverse_kinematics_B.qjj <= inverse_kinematics_B.qp1 + 3;\n           inverse_kinematics_B.qjj++) {\n        U[inverse_kinematics_B.qjj - 1] *= inverse_kinematics_B.nrm;\n      }\n    }\n\n    if ((inverse_kinematics_B.q_j + 1 < 3) && (inverse_kinematics_B.ztest != 0.0))\n    {\n      inverse_kinematics_B.rt = fabs(inverse_kinematics_B.ztest);\n      inverse_kinematics_B.nrm = inverse_kinematics_B.rt /\n        inverse_kinematics_B.ztest;\n      inverse_kinematics_B.ztest = inverse_kinematics_B.rt;\n      inverse_kinematics_B.s[inverse_kinematics_B.q_j + 1] *=\n        inverse_kinematics_B.nrm;\n      inverse_kinematics_B.qp1 = (inverse_kinematics_B.q_j + 1) * 3;\n      for (inverse_kinematics_B.qjj = inverse_kinematics_B.qp1 + 1;\n           inverse_kinematics_B.qjj <= inverse_kinematics_B.qp1 + 3;\n           inverse_kinematics_B.qjj++) {\n        V[inverse_kinematics_B.qjj - 1] *= inverse_kinematics_B.nrm;\n      }\n    }\n\n    inverse_kinematics_B.e_d[inverse_kinematics_B.q_j] =\n      inverse_kinematics_B.ztest;\n  }\n\n  inverse_kinematics_B.qp1 = 0;\n  inverse_kinematics_B.nrm = 0.0;\n  inverse_kinematics_B.ztest = fabs(inverse_kinematics_B.s[0]);\n  inverse_kinematics_B.rt = fabs(inverse_kinematics_B.e_d[0]);\n  if ((inverse_kinematics_B.ztest >= inverse_kinematics_B.rt) || rtIsNaN\n      (inverse_kinematics_B.rt)) {\n    inverse_kinematics_B.rt = inverse_kinematics_B.ztest;\n  }\n\n  if ((!(inverse_kinematics_B.rt <= 0.0)) && (!rtIsNaN(inverse_kinematics_B.rt)))\n  {\n    inverse_kinematics_B.nrm = inverse_kinematics_B.rt;\n  }\n\n  inverse_kinematics_B.ztest = fabs(inverse_kinematics_B.s[1]);\n  inverse_kinematics_B.rt = fabs(inverse_kinematics_B.e_d[1]);\n  if ((inverse_kinematics_B.ztest >= inverse_kinematics_B.rt) || rtIsNaN\n      (inverse_kinematics_B.rt)) {\n    inverse_kinematics_B.rt = inverse_kinematics_B.ztest;\n  }\n\n  if ((!(inverse_kinematics_B.nrm >= inverse_kinematics_B.rt)) && (!rtIsNaN\n       (inverse_kinematics_B.rt))) {\n    inverse_kinematics_B.nrm = inverse_kinematics_B.rt;\n  }\n\n  inverse_kinematics_B.ztest = fabs(inverse_kinematics_B.s[2]);\n  inverse_kinematics_B.rt = fabs(inverse_kinematics_B.e_d[2]);\n  if ((inverse_kinematics_B.ztest >= inverse_kinematics_B.rt) || rtIsNaN\n      (inverse_kinematics_B.rt)) {\n    inverse_kinematics_B.rt = inverse_kinematics_B.ztest;\n  }\n\n  if ((!(inverse_kinematics_B.nrm >= inverse_kinematics_B.rt)) && (!rtIsNaN\n       (inverse_kinematics_B.rt))) {\n    inverse_kinematics_B.nrm = inverse_kinematics_B.rt;\n  }\n\n  while ((inverse_kinematics_B.m_e + 1 > 0) && (!(inverse_kinematics_B.qp1 >= 75)))\n  {\n    boolean_T exitg1;\n    inverse_kinematics_B.q_j = inverse_kinematics_B.m_e;\n    inverse_kinematics_B.qq = inverse_kinematics_B.m_e;\n    exitg1 = false;\n    while ((!exitg1) && (inverse_kinematics_B.qq > -1)) {\n      inverse_kinematics_B.q_j = inverse_kinematics_B.qq;\n      if (inverse_kinematics_B.qq == 0) {\n        exitg1 = true;\n      } else {\n        inverse_kinematics_B.rt = fabs\n          (inverse_kinematics_B.e_d[inverse_kinematics_B.qq - 1]);\n        if ((inverse_kinematics_B.rt <= (fabs\n              (inverse_kinematics_B.s[inverse_kinematics_B.qq - 1]) + fabs\n              (inverse_kinematics_B.s[inverse_kinematics_B.qq])) *\n             2.2204460492503131E-16) || (inverse_kinematics_B.rt <=\n             1.0020841800044864E-292) || ((inverse_kinematics_B.qp1 > 20) &&\n             (inverse_kinematics_B.rt <= 2.2204460492503131E-16 *\n              inverse_kinematics_B.nrm))) {\n          inverse_kinematics_B.e_d[inverse_kinematics_B.qq - 1] = 0.0;\n          exitg1 = true;\n        } else {\n          inverse_kinematics_B.qq--;\n        }\n      }\n    }\n\n    if (inverse_kinematics_B.q_j == inverse_kinematics_B.m_e) {\n      inverse_kinematics_B.qjj = 4;\n    } else {\n      inverse_kinematics_B.qq = inverse_kinematics_B.m_e + 1;\n      inverse_kinematics_B.qjj = inverse_kinematics_B.m_e + 1;\n      exitg1 = false;\n      while ((!exitg1) && (inverse_kinematics_B.qjj >= inverse_kinematics_B.q_j))\n      {\n        inverse_kinematics_B.qq = inverse_kinematics_B.qjj;\n        if (inverse_kinematics_B.qjj == inverse_kinematics_B.q_j) {\n          exitg1 = true;\n        } else {\n          inverse_kinematics_B.rt = 0.0;\n          if (inverse_kinematics_B.qjj < inverse_kinematics_B.m_e + 1) {\n            inverse_kinematics_B.rt = fabs\n              (inverse_kinematics_B.e_d[inverse_kinematics_B.qjj - 1]);\n          }\n\n          if (inverse_kinematics_B.qjj > inverse_kinematics_B.q_j + 1) {\n            inverse_kinematics_B.rt += fabs\n              (inverse_kinematics_B.e_d[inverse_kinematics_B.qjj - 2]);\n          }\n\n          inverse_kinematics_B.ztest = fabs\n            (inverse_kinematics_B.s[inverse_kinematics_B.qjj - 1]);\n          if ((inverse_kinematics_B.ztest <= 2.2204460492503131E-16 *\n               inverse_kinematics_B.rt) || (inverse_kinematics_B.ztest <=\n               1.0020841800044864E-292)) {\n            inverse_kinematics_B.s[inverse_kinematics_B.qjj - 1] = 0.0;\n            exitg1 = true;\n          } else {\n            inverse_kinematics_B.qjj--;\n          }\n        }\n      }\n\n      if (inverse_kinematics_B.qq == inverse_kinematics_B.q_j) {\n        inverse_kinematics_B.qjj = 3;\n      } else if (inverse_kinematics_B.m_e + 1 == inverse_kinematics_B.qq) {\n        inverse_kinematics_B.qjj = 1;\n      } else {\n        inverse_kinematics_B.qjj = 2;\n        inverse_kinematics_B.q_j = inverse_kinematics_B.qq;\n      }\n    }\n\n    switch (inverse_kinematics_B.qjj) {\n     case 1:\n      inverse_kinematics_B.rt =\n        inverse_kinematics_B.e_d[inverse_kinematics_B.m_e - 1];\n      inverse_kinematics_B.e_d[inverse_kinematics_B.m_e - 1] = 0.0;\n      for (inverse_kinematics_B.qq = inverse_kinematics_B.m_e;\n           inverse_kinematics_B.qq >= inverse_kinematics_B.q_j + 1;\n           inverse_kinematics_B.qq--) {\n        inverse_kinematics_B.ztest = inverse_kinematics_B.e_d[0];\n        inverse_kinematics_xrotg(inverse_kinematics_B.s[inverse_kinematics_B.qq\n          - 1], inverse_kinematics_B.rt,\n          &inverse_kinematics_B.s[inverse_kinematics_B.qq - 1],\n          &inverse_kinematics_B.rt, &inverse_kinematics_B.sqds,\n          &inverse_kinematics_B.b_h5);\n        if (inverse_kinematics_B.qq > inverse_kinematics_B.q_j + 1) {\n          inverse_kinematics_B.rt = -inverse_kinematics_B.b_h5 *\n            inverse_kinematics_B.e_d[0];\n          inverse_kinematics_B.ztest = inverse_kinematics_B.e_d[0] *\n            inverse_kinematics_B.sqds;\n        }\n\n        memcpy(&inverse_kinematics_B.A[0], &V[0], 9U * sizeof(real_T));\n        inverse_kinematics_xrot(inverse_kinematics_B.A, (inverse_kinematics_B.qq\n          - 1) * 3 + 1, 3 * inverse_kinematics_B.m_e + 1,\n          inverse_kinematics_B.sqds, inverse_kinematics_B.b_h5, V);\n        inverse_kinematics_B.e_d[0] = inverse_kinematics_B.ztest;\n      }\n      break;\n\n     case 2:\n      inverse_kinematics_B.rt =\n        inverse_kinematics_B.e_d[inverse_kinematics_B.q_j - 1];\n      inverse_kinematics_B.e_d[inverse_kinematics_B.q_j - 1] = 0.0;\n      for (inverse_kinematics_B.qq = inverse_kinematics_B.q_j + 1;\n           inverse_kinematics_B.qq <= inverse_kinematics_B.m_e + 1;\n           inverse_kinematics_B.qq++) {\n        inverse_kinematics_xrotg(inverse_kinematics_B.s[inverse_kinematics_B.qq\n          - 1], inverse_kinematics_B.rt,\n          &inverse_kinematics_B.s[inverse_kinematics_B.qq - 1],\n          &inverse_kinematics_B.ztest, &inverse_kinematics_B.sqds,\n          &inverse_kinematics_B.b_h5);\n        inverse_kinematics_B.ztest =\n          inverse_kinematics_B.e_d[inverse_kinematics_B.qq - 1];\n        inverse_kinematics_B.rt = inverse_kinematics_B.ztest *\n          -inverse_kinematics_B.b_h5;\n        inverse_kinematics_B.e_d[inverse_kinematics_B.qq - 1] =\n          inverse_kinematics_B.ztest * inverse_kinematics_B.sqds;\n        memcpy(&inverse_kinematics_B.A[0], &U[0], 9U * sizeof(real_T));\n        inverse_kinematics_xrot(inverse_kinematics_B.A, (inverse_kinematics_B.qq\n          - 1) * 3 + 1, (inverse_kinematics_B.q_j - 1) * 3 + 1,\n          inverse_kinematics_B.sqds, inverse_kinematics_B.b_h5, U);\n      }\n      break;\n\n     case 3:\n      inverse_kinematics_B.ztest = fabs\n        (inverse_kinematics_B.s[inverse_kinematics_B.m_e]);\n      inverse_kinematics_B.sqds =\n        inverse_kinematics_B.s[inverse_kinematics_B.m_e - 1];\n      inverse_kinematics_B.rt = fabs(inverse_kinematics_B.sqds);\n      if ((inverse_kinematics_B.ztest >= inverse_kinematics_B.rt) || rtIsNaN\n          (inverse_kinematics_B.rt)) {\n        inverse_kinematics_B.rt = inverse_kinematics_B.ztest;\n      }\n\n      inverse_kinematics_B.b_h5 =\n        inverse_kinematics_B.e_d[inverse_kinematics_B.m_e - 1];\n      inverse_kinematics_B.ztest = fabs(inverse_kinematics_B.b_h5);\n      if ((inverse_kinematics_B.rt >= inverse_kinematics_B.ztest) || rtIsNaN\n          (inverse_kinematics_B.ztest)) {\n        inverse_kinematics_B.ztest = inverse_kinematics_B.rt;\n      }\n\n      inverse_kinematics_B.rt = fabs\n        (inverse_kinematics_B.s[inverse_kinematics_B.q_j]);\n      if ((inverse_kinematics_B.ztest >= inverse_kinematics_B.rt) || rtIsNaN\n          (inverse_kinematics_B.rt)) {\n        inverse_kinematics_B.rt = inverse_kinematics_B.ztest;\n      }\n\n      inverse_kinematics_B.ztest = fabs\n        (inverse_kinematics_B.e_d[inverse_kinematics_B.q_j]);\n      if ((inverse_kinematics_B.rt >= inverse_kinematics_B.ztest) || rtIsNaN\n          (inverse_kinematics_B.ztest)) {\n        inverse_kinematics_B.ztest = inverse_kinematics_B.rt;\n      }\n\n      inverse_kinematics_B.rt = inverse_kinematics_B.s[inverse_kinematics_B.m_e]\n        / inverse_kinematics_B.ztest;\n      inverse_kinematics_B.smm1 = inverse_kinematics_B.sqds /\n        inverse_kinematics_B.ztest;\n      inverse_kinematics_B.emm1 = inverse_kinematics_B.b_h5 /\n        inverse_kinematics_B.ztest;\n      inverse_kinematics_B.sqds =\n        inverse_kinematics_B.s[inverse_kinematics_B.q_j] /\n        inverse_kinematics_B.ztest;\n      inverse_kinematics_B.b_h5 = ((inverse_kinematics_B.smm1 +\n        inverse_kinematics_B.rt) * (inverse_kinematics_B.smm1 -\n        inverse_kinematics_B.rt) + inverse_kinematics_B.emm1 *\n        inverse_kinematics_B.emm1) / 2.0;\n      inverse_kinematics_B.smm1 = inverse_kinematics_B.rt *\n        inverse_kinematics_B.emm1;\n      inverse_kinematics_B.smm1 *= inverse_kinematics_B.smm1;\n      if ((inverse_kinematics_B.b_h5 != 0.0) || (inverse_kinematics_B.smm1 !=\n           0.0)) {\n        inverse_kinematics_B.emm1 = sqrt(inverse_kinematics_B.b_h5 *\n          inverse_kinematics_B.b_h5 + inverse_kinematics_B.smm1);\n        if (inverse_kinematics_B.b_h5 < 0.0) {\n          inverse_kinematics_B.emm1 = -inverse_kinematics_B.emm1;\n        }\n\n        inverse_kinematics_B.emm1 = inverse_kinematics_B.smm1 /\n          (inverse_kinematics_B.b_h5 + inverse_kinematics_B.emm1);\n      } else {\n        inverse_kinematics_B.emm1 = 0.0;\n      }\n\n      inverse_kinematics_B.rt = (inverse_kinematics_B.sqds +\n        inverse_kinematics_B.rt) * (inverse_kinematics_B.sqds -\n        inverse_kinematics_B.rt) + inverse_kinematics_B.emm1;\n      inverse_kinematics_B.sqds *=\n        inverse_kinematics_B.e_d[inverse_kinematics_B.q_j] /\n        inverse_kinematics_B.ztest;\n      for (inverse_kinematics_B.qq_tmp = inverse_kinematics_B.q_j + 1;\n           inverse_kinematics_B.qq_tmp <= inverse_kinematics_B.m_e;\n           inverse_kinematics_B.qq_tmp++) {\n        inverse_kinematics_xrotg(inverse_kinematics_B.rt,\n          inverse_kinematics_B.sqds, &inverse_kinematics_B.ztest,\n          &inverse_kinematics_B.emm1, &inverse_kinematics_B.b_h5,\n          &inverse_kinematics_B.smm1);\n        if (inverse_kinematics_B.qq_tmp > inverse_kinematics_B.q_j + 1) {\n          inverse_kinematics_B.e_d[0] = inverse_kinematics_B.ztest;\n        }\n\n        inverse_kinematics_B.ztest =\n          inverse_kinematics_B.e_d[inverse_kinematics_B.qq_tmp - 1];\n        inverse_kinematics_B.rt =\n          inverse_kinematics_B.s[inverse_kinematics_B.qq_tmp - 1];\n        inverse_kinematics_B.e_d[inverse_kinematics_B.qq_tmp - 1] =\n          inverse_kinematics_B.ztest * inverse_kinematics_B.b_h5 -\n          inverse_kinematics_B.rt * inverse_kinematics_B.smm1;\n        inverse_kinematics_B.sqds = inverse_kinematics_B.smm1 *\n          inverse_kinematics_B.s[inverse_kinematics_B.qq_tmp];\n        inverse_kinematics_B.s[inverse_kinematics_B.qq_tmp] *=\n          inverse_kinematics_B.b_h5;\n        inverse_kinematics_B.qq = (inverse_kinematics_B.qq_tmp - 1) * 3 + 1;\n        inverse_kinematics_B.qjj = 3 * inverse_kinematics_B.qq_tmp + 1;\n        memcpy(&inverse_kinematics_B.A[0], &V[0], 9U * sizeof(real_T));\n        inverse_kinematics_xrot(inverse_kinematics_B.A, inverse_kinematics_B.qq,\n          inverse_kinematics_B.qjj, inverse_kinematics_B.b_h5,\n          inverse_kinematics_B.smm1, V);\n        inverse_kinematics_xrotg(inverse_kinematics_B.rt *\n          inverse_kinematics_B.b_h5 + inverse_kinematics_B.ztest *\n          inverse_kinematics_B.smm1, inverse_kinematics_B.sqds,\n          &inverse_kinematics_B.s[inverse_kinematics_B.qq_tmp - 1],\n          &inverse_kinematics_B.a__3, &inverse_kinematics_B.emm1,\n          &inverse_kinematics_B.d_sn);\n        inverse_kinematics_B.rt =\n          inverse_kinematics_B.e_d[inverse_kinematics_B.qq_tmp - 1] *\n          inverse_kinematics_B.emm1 + inverse_kinematics_B.d_sn *\n          inverse_kinematics_B.s[inverse_kinematics_B.qq_tmp];\n        inverse_kinematics_B.s[inverse_kinematics_B.qq_tmp] =\n          inverse_kinematics_B.e_d[inverse_kinematics_B.qq_tmp - 1] *\n          -inverse_kinematics_B.d_sn + inverse_kinematics_B.emm1 *\n          inverse_kinematics_B.s[inverse_kinematics_B.qq_tmp];\n        inverse_kinematics_B.sqds = inverse_kinematics_B.d_sn *\n          inverse_kinematics_B.e_d[inverse_kinematics_B.qq_tmp];\n        inverse_kinematics_B.e_d[inverse_kinematics_B.qq_tmp] *=\n          inverse_kinematics_B.emm1;\n        memcpy(&inverse_kinematics_B.A[0], &U[0], 9U * sizeof(real_T));\n        inverse_kinematics_xrot(inverse_kinematics_B.A, inverse_kinematics_B.qq,\n          inverse_kinematics_B.qjj, inverse_kinematics_B.emm1,\n          inverse_kinematics_B.d_sn, U);\n      }\n\n      inverse_kinematics_B.e_d[inverse_kinematics_B.m_e - 1] =\n        inverse_kinematics_B.rt;\n      inverse_kinematics_B.qp1++;\n      break;\n\n     default:\n      if (inverse_kinematics_B.s[inverse_kinematics_B.q_j] < 0.0) {\n        inverse_kinematics_B.s[inverse_kinematics_B.q_j] =\n          -inverse_kinematics_B.s[inverse_kinematics_B.q_j];\n        inverse_kinematics_B.qp1 = 3 * inverse_kinematics_B.q_j;\n        for (inverse_kinematics_B.qjj = inverse_kinematics_B.qp1 + 1;\n             inverse_kinematics_B.qjj <= inverse_kinematics_B.qp1 + 3;\n             inverse_kinematics_B.qjj++) {\n          V[inverse_kinematics_B.qjj - 1] = -V[inverse_kinematics_B.qjj - 1];\n        }\n      }\n\n      inverse_kinematics_B.qp1 = inverse_kinematics_B.q_j + 1;\n      while ((inverse_kinematics_B.q_j + 1 < 3) &&\n             (inverse_kinematics_B.s[inverse_kinematics_B.q_j] <\n              inverse_kinematics_B.s[inverse_kinematics_B.qp1])) {\n        inverse_kinematics_B.rt =\n          inverse_kinematics_B.s[inverse_kinematics_B.q_j];\n        inverse_kinematics_B.s[inverse_kinematics_B.q_j] =\n          inverse_kinematics_B.s[inverse_kinematics_B.qp1];\n        inverse_kinematics_B.s[inverse_kinematics_B.qp1] =\n          inverse_kinematics_B.rt;\n        inverse_kinematics_B.qq = 3 * inverse_kinematics_B.q_j + 1;\n        inverse_kinematics_B.qjj = (inverse_kinematics_B.q_j + 1) * 3 + 1;\n        memcpy(&inverse_kinematics_B.A[0], &V[0], 9U * sizeof(real_T));\n        inverse_kinematics_xswap(inverse_kinematics_B.A, inverse_kinematics_B.qq,\n          inverse_kinematics_B.qjj, V);\n        memcpy(&inverse_kinematics_B.A[0], &U[0], 9U * sizeof(real_T));\n        inverse_kinematics_xswap(inverse_kinematics_B.A, inverse_kinematics_B.qq,\n          inverse_kinematics_B.qjj, U);\n        inverse_kinematics_B.q_j = inverse_kinematics_B.qp1;\n        inverse_kinematics_B.qp1++;\n      }\n\n      inverse_kinematics_B.qp1 = 0;\n      inverse_kinematics_B.m_e--;\n      break;\n    }\n  }\n\n  s[0] = inverse_kinematics_B.s[0];\n  s[1] = inverse_kinematics_B.s[1];\n  s[2] = inverse_kinematics_B.s[2];\n}\n\nstatic void inverse_kin_IKHelpers_poseError(const real_T Td[16], const real_T\n  T_data[], const int32_T T_size[2], real_T errorvec[6])\n{\n  boolean_T exitg1;\n  inverse_kinematics_B.y_tmp_i[0] = 1;\n  inverse_kinematics_B.y_tmp_i[1] = 2;\n  inverse_kinematics_B.y_tmp_i[2] = 3;\n  for (inverse_kinematics_B.b_k_p = 0; inverse_kinematics_B.b_k_p < 3;\n       inverse_kinematics_B.b_k_p++) {\n    inverse_kinematics_B.y_tmp_o =\n      inverse_kinematics_B.y_tmp_i[inverse_kinematics_B.b_k_p];\n    inverse_kinematics_B.T[3 * inverse_kinematics_B.b_k_p] =\n      T_data[inverse_kinematics_B.y_tmp_o - 1];\n    inverse_kinematics_B.T_tmp = 3 * inverse_kinematics_B.b_k_p + 1;\n    inverse_kinematics_B.T[inverse_kinematics_B.T_tmp] = T_data\n      [(inverse_kinematics_B.y_tmp_o + T_size[0]) - 1];\n    inverse_kinematics_B.T_tmp_a = 3 * inverse_kinematics_B.b_k_p + 2;\n    inverse_kinematics_B.T[inverse_kinematics_B.T_tmp_a] = T_data[((T_size[0] <<\n      1) + inverse_kinematics_B.y_tmp_o) - 1];\n    for (inverse_kinematics_B.i3 = 0; inverse_kinematics_B.i3 < 3;\n         inverse_kinematics_B.i3++) {\n      inverse_kinematics_B.y_tmp = 3 * inverse_kinematics_B.b_k_p +\n        inverse_kinematics_B.i3;\n      inverse_kinematics_B.y[inverse_kinematics_B.y_tmp] = 0.0;\n      inverse_kinematics_B.y[inverse_kinematics_B.y_tmp] +=\n        inverse_kinematics_B.T[3 * inverse_kinematics_B.b_k_p] *\n        Td[inverse_kinematics_B.i3];\n      inverse_kinematics_B.y[inverse_kinematics_B.y_tmp] +=\n        Td[inverse_kinematics_B.i3 + 4] *\n        inverse_kinematics_B.T[inverse_kinematics_B.T_tmp];\n      inverse_kinematics_B.y[inverse_kinematics_B.y_tmp] +=\n        Td[inverse_kinematics_B.i3 + 8] *\n        inverse_kinematics_B.T[inverse_kinematics_B.T_tmp_a];\n    }\n  }\n\n  inverse_kinematics_B.u.re = (((inverse_kinematics_B.y[0] +\n    inverse_kinematics_B.y[4]) + inverse_kinematics_B.y[8]) - 1.0) * 0.5;\n  if (!(fabs(inverse_kinematics_B.u.re) > 1.0)) {\n    inverse_kinematics_B.v_lx.re = acos(inverse_kinematics_B.u.re);\n  } else {\n    inverse_kinematics_B.u_o.re = inverse_kinematics_B.u.re + 1.0;\n    inverse_kinematics_B.u_o.im = 0.0;\n    inverse_kinematics_B.dc.re = 1.0 - inverse_kinematics_B.u.re;\n    inverse_kinematics_B.dc.im = 0.0;\n    inverse_kinematics_B.v_lx.re = 2.0 * rt_atan2d_snf((inverse_kinematics_sqrt\n      (inverse_kinematics_B.dc)).re, (inverse_kinematics_sqrt\n      (inverse_kinematics_B.u_o)).re);\n  }\n\n  inverse_kinematics_B.a_j = 2.0 * sin(inverse_kinematics_B.v_lx.re);\n  inverse_kinematics_B.v_g[0] = (inverse_kinematics_B.y[5] -\n    inverse_kinematics_B.y[7]) / inverse_kinematics_B.a_j;\n  inverse_kinematics_B.v_g[1] = (inverse_kinematics_B.y[6] -\n    inverse_kinematics_B.y[2]) / inverse_kinematics_B.a_j;\n  inverse_kinematics_B.v_g[2] = (inverse_kinematics_B.y[1] -\n    inverse_kinematics_B.y[3]) / inverse_kinematics_B.a_j;\n  if (rtIsNaN(inverse_kinematics_B.v_lx.re) || rtIsInf\n      (inverse_kinematics_B.v_lx.re)) {\n    inverse_kinematics_B.a_j = (rtNaN);\n  } else if (inverse_kinematics_B.v_lx.re == 0.0) {\n    inverse_kinematics_B.a_j = 0.0;\n  } else {\n    inverse_kinematics_B.a_j = fmod(inverse_kinematics_B.v_lx.re,\n      3.1415926535897931);\n    inverse_kinematics_B.rEQ0 = (inverse_kinematics_B.a_j == 0.0);\n    if (!inverse_kinematics_B.rEQ0) {\n      inverse_kinematics_B.q = fabs(inverse_kinematics_B.v_lx.re /\n        3.1415926535897931);\n      inverse_kinematics_B.rEQ0 = !(fabs(inverse_kinematics_B.q - floor\n        (inverse_kinematics_B.q + 0.5)) > 2.2204460492503131E-16 *\n        inverse_kinematics_B.q);\n    }\n\n    if (inverse_kinematics_B.rEQ0) {\n      inverse_kinematics_B.a_j = 0.0;\n    } else if (inverse_kinematics_B.v_lx.re < 0.0) {\n      inverse_kinematics_B.a_j += 3.1415926535897931;\n    }\n  }\n\n  inverse_kinematics_B.rEQ0 = (inverse_kinematics_B.a_j == 0.0);\n  inverse_kinematics_B.e_k = true;\n  inverse_kinematics_B.b_k_p = 0;\n  exitg1 = false;\n  while ((!exitg1) && (inverse_kinematics_B.b_k_p < 3)) {\n    if (!(inverse_kinematics_B.v_g[inverse_kinematics_B.b_k_p] == 0.0)) {\n      inverse_kinematics_B.e_k = false;\n      exitg1 = true;\n    } else {\n      inverse_kinematics_B.b_k_p++;\n    }\n  }\n\n  if (inverse_kinematics_B.rEQ0 || inverse_kinematics_B.e_k) {\n    inverse_kinematics_B.T_tmp = (inverse_kinematics_B.rEQ0 ||\n      inverse_kinematics_B.e_k) * 3 - 1;\n    if (inverse_kinematics_B.T_tmp >= 0) {\n      memset(&inverse_kinematics_B.vspecial_data[0], 0,\n             (inverse_kinematics_B.T_tmp + 1) * sizeof(real_T));\n    }\n\n    inverse_kinematics_B.T_tmp = (inverse_kinematics_B.rEQ0 ||\n      inverse_kinematics_B.e_k) - 1;\n    for (inverse_kinematics_B.T_tmp_a = 0; inverse_kinematics_B.T_tmp_a <=\n         inverse_kinematics_B.T_tmp; inverse_kinematics_B.T_tmp_a++) {\n      memset(&inverse_kinematics_B.T[0], 0, 9U * sizeof(real_T));\n      inverse_kinematics_B.T[0] = 1.0;\n      inverse_kinematics_B.T[4] = 1.0;\n      inverse_kinematics_B.T[8] = 1.0;\n      for (inverse_kinematics_B.b_k_p = 0; inverse_kinematics_B.b_k_p < 9;\n           inverse_kinematics_B.b_k_p++) {\n        inverse_kinematics_B.T[inverse_kinematics_B.b_k_p] -=\n          inverse_kinematics_B.y[inverse_kinematics_B.b_k_p];\n      }\n\n      inverse_kinematics_B.x_p = true;\n      for (inverse_kinematics_B.b_k_p = 0; inverse_kinematics_B.b_k_p < 9;\n           inverse_kinematics_B.b_k_p++) {\n        if (inverse_kinematics_B.x_p) {\n          inverse_kinematics_B.a_j =\n            inverse_kinematics_B.T[inverse_kinematics_B.b_k_p];\n          if ((!rtIsInf(inverse_kinematics_B.a_j)) && (!rtIsNaN\n               (inverse_kinematics_B.a_j))) {\n          } else {\n            inverse_kinematics_B.x_p = false;\n          }\n        } else {\n          inverse_kinematics_B.x_p = false;\n        }\n      }\n\n      if (inverse_kinematics_B.x_p) {\n        inverse_kinematics_svd(inverse_kinematics_B.T, inverse_kinematics_B.b_U,\n          inverse_kinematics_B.v_l, inverse_kinematics_B.V);\n      } else {\n        for (inverse_kinematics_B.b_k_p = 0; inverse_kinematics_B.b_k_p < 9;\n             inverse_kinematics_B.b_k_p++) {\n          inverse_kinematics_B.V[inverse_kinematics_B.b_k_p] = (rtNaN);\n        }\n      }\n\n      inverse_kinematics_B.vspecial_data[0] = inverse_kinematics_B.V[6];\n      inverse_kinematics_B.vspecial_data[1] = inverse_kinematics_B.V[7];\n      inverse_kinematics_B.vspecial_data[2] = inverse_kinematics_B.V[8];\n    }\n\n    inverse_kinematics_B.b_k_p = 0;\n    if (inverse_kinematics_B.rEQ0 || inverse_kinematics_B.e_k) {\n      for (inverse_kinematics_B.T_tmp = 0; inverse_kinematics_B.T_tmp < 1;\n           inverse_kinematics_B.T_tmp++) {\n        inverse_kinematics_B.b_k_p++;\n      }\n    }\n\n    if (inverse_kinematics_B.b_k_p - 1 >= 0) {\n      inverse_kinematics_B.v_g[0] = inverse_kinematics_B.vspecial_data[0];\n      inverse_kinematics_B.v_g[1] = inverse_kinematics_B.vspecial_data[1];\n      inverse_kinematics_B.v_g[2] = inverse_kinematics_B.vspecial_data[2];\n    }\n  }\n\n  inverse_kinematics_B.v_l[0] = inverse_kinematics_B.v_g[0];\n  inverse_kinematics_B.v_l[1] = inverse_kinematics_B.v_g[1];\n  inverse_kinematics_B.v_l[2] = inverse_kinematics_B.v_g[2];\n  inverse_kinematics_B.a_j = 1.0 / sqrt((inverse_kinematics_B.v_g[0] *\n    inverse_kinematics_B.v_g[0] + inverse_kinematics_B.v_g[1] *\n    inverse_kinematics_B.v_g[1]) + inverse_kinematics_B.v_g[2] *\n    inverse_kinematics_B.v_g[2]);\n  errorvec[0] = inverse_kinematics_B.v_l[0] * inverse_kinematics_B.a_j *\n    inverse_kinematics_B.v_lx.re;\n  errorvec[3] = Td[12] - T_data[T_size[0] * 3];\n  errorvec[1] = inverse_kinematics_B.v_l[1] * inverse_kinematics_B.a_j *\n    inverse_kinematics_B.v_lx.re;\n  errorvec[4] = Td[13] - T_data[T_size[0] * 3 + 1];\n  errorvec[2] = inverse_kinematics_B.v_l[2] * inverse_kinematics_B.a_j *\n    inverse_kinematics_B.v_lx.re;\n  errorvec[5] = Td[14] - T_data[T_size[0] * 3 + 2];\n}\n\nstatic void inverse_kinematics_mtimes_g(const real_T A[6], const\n  emxArray_real_T_inverse_kinem_T *B, emxArray_real_T_inverse_kinem_T *C)\n{\n  int32_T b_j;\n  int32_T n;\n  n = B->size[1] - 1;\n  b_j = C->size[0] * C->size[1];\n  C->size[0] = 1;\n  C->size[1] = B->size[1];\n  invers_emxEnsureCapacity_real_T(C, b_j);\n  for (b_j = 0; b_j <= n; b_j++) {\n    real_T s;\n    int32_T boffset;\n    boffset = b_j * 6 - 1;\n    s = 0.0;\n    for (int32_T b_k = 0; b_k < 6; b_k++) {\n      s += B->data[(boffset + b_k) + 1] * A[b_k];\n    }\n\n    C->data[b_j] = s;\n  }\n}\n\nstatic void inverse_kinem_emxInit_boolean_T(emxArray_boolean_T_inverse_ki_T\n  **pEmxArray, int32_T numDimensions)\n{\n  emxArray_boolean_T_inverse_ki_T *emxArray;\n  *pEmxArray = static_cast<emxArray_boolean_T_inverse_ki_T *>(malloc(sizeof\n    (emxArray_boolean_T_inverse_ki_T)));\n  emxArray = *pEmxArray;\n  emxArray->data = static_cast<boolean_T *>(NULL);\n  emxArray->numDimensions = numDimensions;\n  emxArray->size = static_cast<int32_T *>(malloc(sizeof(int32_T) * numDimensions));\n  emxArray->allocatedSize = 0;\n  emxArray->canFreeData = true;\n  for (int32_T i = 0; i < numDimensions; i++) {\n    emxArray->size[i] = 0;\n  }\n}\n\nstatic real_T inverse_kinematics_norm_g(const real_T x[6])\n{\n  real_T scale;\n  real_T y;\n  y = 0.0;\n  scale = 3.3121686421112381E-170;\n  for (int32_T b_k = 0; b_k < 6; b_k++) {\n    real_T absxk;\n    absxk = fabs(x[b_k]);\n    if (absxk > scale) {\n      real_T t;\n      t = scale / absxk;\n      y = y * t * t + 1.0;\n      scale = absxk;\n    } else {\n      real_T t;\n      t = absxk / scale;\n      y += t * t;\n    }\n  }\n\n  return scale * sqrt(y);\n}\n\nstatic void inverse_kinematics_minus_g(emxArray_real_T_inverse_kinem_T *in1,\n  const emxArray_real_T_inverse_kinem_T *in2)\n{\n  emxArray_real_T_inverse_kinem_T *in2_0;\n  int32_T i;\n  int32_T loop_ub;\n  int32_T stride_0_0;\n  int32_T stride_1_0;\n  inverse_kinemati_emxInit_real_T(&in2_0, 1);\n  i = in2_0->size[0];\n  in2_0->size[0] = in1->size[0] == 1 ? in2->size[0] : in1->size[0];\n  invers_emxEnsureCapacity_real_T(in2_0, i);\n  stride_0_0 = (in2->size[0] != 1);\n  stride_1_0 = (in1->size[0] != 1);\n  loop_ub = in1->size[0] == 1 ? in2->size[0] : in1->size[0];\n  for (i = 0; i < loop_ub; i++) {\n    in2_0->data[i] = in2->data[i * stride_0_0] - in1->data[i * stride_1_0];\n  }\n\n  i = in1->size[0];\n  in1->size[0] = in2_0->size[0];\n  invers_emxEnsureCapacity_real_T(in1, i);\n  loop_ub = in2_0->size[0];\n  if (loop_ub - 1 >= 0) {\n    memcpy(&in1->data[0], &in2_0->data[0], loop_ub * sizeof(real_T));\n  }\n\n  inverse_kinemati_emxFree_real_T(&in2_0);\n}\n\nstatic void inv_emxEnsureCapacity_boolean_T(emxArray_boolean_T_inverse_ki_T\n  *emxArray, int32_T oldNumel)\n{\n  int32_T i;\n  int32_T newNumel;\n  void *newData;\n  if (oldNumel < 0) {\n    oldNumel = 0;\n  }\n\n  newNumel = 1;\n  for (i = 0; i < emxArray->numDimensions; i++) {\n    newNumel *= emxArray->size[i];\n  }\n\n  if (newNumel > emxArray->allocatedSize) {\n    i = emxArray->allocatedSize;\n    if (i < 16) {\n      i = 16;\n    }\n\n    while (i < newNumel) {\n      if (i > 1073741823) {\n        i = MAX_int32_T;\n      } else {\n        i <<= 1;\n      }\n    }\n\n    newData = calloc(static_cast<uint32_T>(i), sizeof(boolean_T));\n    if (emxArray->data != NULL) {\n      memcpy(newData, emxArray->data, sizeof(boolean_T) * oldNumel);\n      if (emxArray->canFreeData) {\n        free(emxArray->data);\n      }\n    }\n\n    emxArray->data = static_cast<boolean_T *>(newData);\n    emxArray->allocatedSize = i;\n    emxArray->canFreeData = true;\n  }\n}\n\nstatic real_T inverse_kinematics_toc(real_T tstart_tv_sec, real_T tstart_tv_nsec)\n{\n  coderTimespec b_timespec;\n  if (!inverse_kinematics_DW.method_not_empty) {\n    inverse_kinematics_DW.method_not_empty = true;\n    coderInitTimeFunctions(&inverse_kinematics_DW.freq);\n  }\n\n  coderTimeClockGettimeMonotonic(&b_timespec, inverse_kinematics_DW.freq);\n  return (b_timespec.tv_nsec - tstart_tv_nsec) / 1.0E+9 + (b_timespec.tv_sec -\n    tstart_tv_sec);\n}\n\nstatic void inverse_kinematics_mldivide(const real_T A[16], const\n  emxArray_real_T_inverse_kinem_T *B, real_T Y_data[], int32_T *Y_size)\n{\n  memcpy(&inverse_kinematics_B.c_x[0], &A[0], sizeof(real_T) << 4U);\n  inverse_kinematics_B.b_ipiv[0] = 1;\n  inverse_kinematics_B.b_ipiv[1] = 2;\n  inverse_kinematics_B.b_ipiv[2] = 3;\n  for (inverse_kinematics_B.kAcol = 0; inverse_kinematics_B.kAcol < 3;\n       inverse_kinematics_B.kAcol++) {\n    inverse_kinematics_B.c_b = inverse_kinematics_B.kAcol * 5 + 2;\n    inverse_kinematics_B.jj = inverse_kinematics_B.kAcol * 5;\n    inverse_kinematics_B.c_a = 4 - inverse_kinematics_B.kAcol;\n    inverse_kinematics_B.a_g = 1;\n    inverse_kinematics_B.smax = fabs\n      (inverse_kinematics_B.c_x[inverse_kinematics_B.jj]);\n    for (inverse_kinematics_B.jA = 2; inverse_kinematics_B.jA <=\n         inverse_kinematics_B.c_a; inverse_kinematics_B.jA++) {\n      inverse_kinematics_B.s_c = fabs(inverse_kinematics_B.c_x\n        [(inverse_kinematics_B.c_b + inverse_kinematics_B.jA) - 3]);\n      if (inverse_kinematics_B.s_c > inverse_kinematics_B.smax) {\n        inverse_kinematics_B.a_g = inverse_kinematics_B.jA;\n        inverse_kinematics_B.smax = inverse_kinematics_B.s_c;\n      }\n    }\n\n    if (inverse_kinematics_B.c_x[(inverse_kinematics_B.c_b +\n         inverse_kinematics_B.a_g) - 3] != 0.0) {\n      if (inverse_kinematics_B.a_g - 1 != 0) {\n        inverse_kinematics_B.a_g += inverse_kinematics_B.kAcol;\n        inverse_kinematics_B.b_ipiv[inverse_kinematics_B.kAcol] =\n          static_cast<int8_T>(inverse_kinematics_B.a_g);\n        inverse_kinematics_B.smax =\n          inverse_kinematics_B.c_x[inverse_kinematics_B.kAcol];\n        inverse_kinematics_B.c_x[inverse_kinematics_B.kAcol] =\n          inverse_kinematics_B.c_x[inverse_kinematics_B.a_g - 1];\n        inverse_kinematics_B.c_x[inverse_kinematics_B.a_g - 1] =\n          inverse_kinematics_B.smax;\n        inverse_kinematics_B.smax =\n          inverse_kinematics_B.c_x[inverse_kinematics_B.kAcol + 4];\n        inverse_kinematics_B.c_x[inverse_kinematics_B.kAcol + 4] =\n          inverse_kinematics_B.c_x[inverse_kinematics_B.a_g + 3];\n        inverse_kinematics_B.c_x[inverse_kinematics_B.a_g + 3] =\n          inverse_kinematics_B.smax;\n        inverse_kinematics_B.smax =\n          inverse_kinematics_B.c_x[inverse_kinematics_B.kAcol + 8];\n        inverse_kinematics_B.c_x[inverse_kinematics_B.kAcol + 8] =\n          inverse_kinematics_B.c_x[inverse_kinematics_B.a_g + 7];\n        inverse_kinematics_B.c_x[inverse_kinematics_B.a_g + 7] =\n          inverse_kinematics_B.smax;\n        inverse_kinematics_B.smax =\n          inverse_kinematics_B.c_x[inverse_kinematics_B.kAcol + 12];\n        inverse_kinematics_B.c_x[inverse_kinematics_B.kAcol + 12] =\n          inverse_kinematics_B.c_x[inverse_kinematics_B.a_g + 11];\n        inverse_kinematics_B.c_x[inverse_kinematics_B.a_g + 11] =\n          inverse_kinematics_B.smax;\n      }\n\n      inverse_kinematics_B.a_g = inverse_kinematics_B.c_b -\n        inverse_kinematics_B.kAcol;\n      for (inverse_kinematics_B.c_a = inverse_kinematics_B.c_b;\n           inverse_kinematics_B.c_a <= inverse_kinematics_B.a_g + 2;\n           inverse_kinematics_B.c_a++) {\n        inverse_kinematics_B.c_x[inverse_kinematics_B.c_a - 1] /=\n          inverse_kinematics_B.c_x[inverse_kinematics_B.jj];\n      }\n    }\n\n    inverse_kinematics_B.c_a = 3 - inverse_kinematics_B.kAcol;\n    inverse_kinematics_B.jA = inverse_kinematics_B.jj;\n    for (inverse_kinematics_B.j_e = 0; inverse_kinematics_B.j_e <\n         inverse_kinematics_B.c_a; inverse_kinematics_B.j_e++) {\n      inverse_kinematics_B.smax = inverse_kinematics_B.c_x\n        [((inverse_kinematics_B.j_e << 2) + inverse_kinematics_B.jj) + 4];\n      if (inverse_kinematics_B.smax != 0.0) {\n        inverse_kinematics_B.a_g = inverse_kinematics_B.jA + 6;\n        inverse_kinematics_B.c_fi = inverse_kinematics_B.jA -\n          inverse_kinematics_B.kAcol;\n        for (inverse_kinematics_B.ijA = inverse_kinematics_B.a_g;\n             inverse_kinematics_B.ijA <= inverse_kinematics_B.c_fi + 8;\n             inverse_kinematics_B.ijA++) {\n          inverse_kinematics_B.c_x[inverse_kinematics_B.ijA - 1] +=\n            inverse_kinematics_B.c_x[((inverse_kinematics_B.c_b +\n            inverse_kinematics_B.ijA) - inverse_kinematics_B.jA) - 7] *\n            -inverse_kinematics_B.smax;\n        }\n      }\n\n      inverse_kinematics_B.jA += 4;\n    }\n  }\n\n  *Y_size = B->size[0];\n  inverse_kinematics_B.c_b = B->size[0];\n  if (inverse_kinematics_B.c_b - 1 >= 0) {\n    memcpy(&Y_data[0], &B->data[0], inverse_kinematics_B.c_b * sizeof(real_T));\n  }\n\n  if (inverse_kinematics_B.b_ipiv[0] != 1) {\n    inverse_kinematics_B.smax = Y_data[0];\n    Y_data[0] = Y_data[inverse_kinematics_B.b_ipiv[0] - 1];\n    Y_data[inverse_kinematics_B.b_ipiv[0] - 1] = inverse_kinematics_B.smax;\n  }\n\n  if (inverse_kinematics_B.b_ipiv[1] != 2) {\n    inverse_kinematics_B.smax = Y_data[1];\n    Y_data[1] = Y_data[inverse_kinematics_B.b_ipiv[1] - 1];\n    Y_data[inverse_kinematics_B.b_ipiv[1] - 1] = inverse_kinematics_B.smax;\n  }\n\n  if (inverse_kinematics_B.b_ipiv[2] != 3) {\n    inverse_kinematics_B.smax = Y_data[2];\n    Y_data[2] = Y_data[inverse_kinematics_B.b_ipiv[2] - 1];\n    Y_data[inverse_kinematics_B.b_ipiv[2] - 1] = inverse_kinematics_B.smax;\n  }\n\n  for (inverse_kinematics_B.c_b = 0; inverse_kinematics_B.c_b < 4;\n       inverse_kinematics_B.c_b++) {\n    inverse_kinematics_B.kAcol = (inverse_kinematics_B.c_b << 2) - 1;\n    if (Y_data[inverse_kinematics_B.c_b] != 0.0) {\n      for (inverse_kinematics_B.c_a = inverse_kinematics_B.c_b + 2;\n           inverse_kinematics_B.c_a < 5; inverse_kinematics_B.c_a++) {\n        Y_data[inverse_kinematics_B.c_a - 1] -=\n          inverse_kinematics_B.c_x[inverse_kinematics_B.c_a +\n          inverse_kinematics_B.kAcol] * Y_data[inverse_kinematics_B.c_b];\n      }\n    }\n  }\n\n  for (inverse_kinematics_B.jA = 3; inverse_kinematics_B.jA >= 0;\n       inverse_kinematics_B.jA--) {\n    inverse_kinematics_B.kAcol = inverse_kinematics_B.jA << 2;\n    if (Y_data[inverse_kinematics_B.jA] != 0.0) {\n      Y_data[inverse_kinematics_B.jA] /=\n        inverse_kinematics_B.c_x[inverse_kinematics_B.jA +\n        inverse_kinematics_B.kAcol];\n      inverse_kinematics_B.a_g = inverse_kinematics_B.jA - 1;\n      for (inverse_kinematics_B.c_b = 0; inverse_kinematics_B.c_b <=\n           inverse_kinematics_B.a_g; inverse_kinematics_B.c_b++) {\n        Y_data[inverse_kinematics_B.c_b] -=\n          inverse_kinematics_B.c_x[inverse_kinematics_B.c_b +\n          inverse_kinematics_B.kAcol] * Y_data[inverse_kinematics_B.jA];\n      }\n    }\n  }\n}\n\nstatic void inverse_kine_binary_expand_op_g(real_T in1_data[], int32_T *in1_size,\n  const emxArray_real_T_inverse_kinem_T *in2, real_T in3, const real_T in4[16],\n  const emxArray_real_T_inverse_kinem_T *in5)\n{\n  inverse_kinematics_B.stride_0_0 = (in2->size[0] != 1);\n  inverse_kinematics_B.stride_0_1 = (in2->size[1] != 1);\n  inverse_kinematics_B.aux_0_1 = 0;\n  for (inverse_kinematics_B.i4 = 0; inverse_kinematics_B.i4 < 4;\n       inverse_kinematics_B.i4++) {\n    inverse_kinematics_B.in2_tmp = inverse_kinematics_B.i4 << 2;\n    inverse_kinematics_B.in2[inverse_kinematics_B.in2_tmp] =\n      -(in4[inverse_kinematics_B.in2_tmp] * in3 + in2->data[in2->size[0] *\n        inverse_kinematics_B.aux_0_1]);\n    inverse_kinematics_B.in2[inverse_kinematics_B.in2_tmp + 1] =\n      -(in4[inverse_kinematics_B.in2_tmp + 1] * in3 + in2->data[in2->size[0] *\n        inverse_kinematics_B.aux_0_1 + inverse_kinematics_B.stride_0_0]);\n    inverse_kinematics_B.in2[inverse_kinematics_B.in2_tmp + 2] =\n      -(in4[inverse_kinematics_B.in2_tmp + 2] * in3 + in2->data\n        [(inverse_kinematics_B.stride_0_0 << 1) + in2->size[0] *\n        inverse_kinematics_B.aux_0_1]);\n    inverse_kinematics_B.in2[inverse_kinematics_B.in2_tmp + 3] =\n      -(in4[inverse_kinematics_B.in2_tmp + 3] * in3 + in2->data[3 *\n        inverse_kinematics_B.stride_0_0 + in2->size[0] *\n        inverse_kinematics_B.aux_0_1]);\n    inverse_kinematics_B.aux_0_1 += inverse_kinematics_B.stride_0_1;\n  }\n\n  inverse_kinematics_mldivide(inverse_kinematics_B.in2, in5, in1_data, in1_size);\n}\n\nstatic void inverse_kinematics_expand_max(const emxArray_real_T_inverse_kinem_T *\n  a, const real_T b[4], real_T c[4])\n{\n  real_T u0;\n  int32_T acoef;\n  acoef = (a->size[0] != 1);\n  if ((a->data[0] >= b[0]) || rtIsNaN(b[0])) {\n    c[0] = a->data[0];\n  } else {\n    c[0] = b[0];\n  }\n\n  u0 = a->data[acoef];\n  if ((u0 >= b[1]) || rtIsNaN(b[1])) {\n    c[1] = u0;\n  } else {\n    c[1] = b[1];\n  }\n\n  u0 = a->data[acoef << 1];\n  if ((u0 >= b[2]) || rtIsNaN(b[2])) {\n    c[2] = u0;\n  } else {\n    c[2] = b[2];\n  }\n\n  u0 = a->data[acoef * 3];\n  if ((u0 >= b[3]) || rtIsNaN(b[3])) {\n    c[3] = u0;\n  } else {\n    c[3] = b[3];\n  }\n}\n\nstatic void inverse_kinematics_expand_min(const emxArray_real_T_inverse_kinem_T *\n  a, const real_T b[4], real_T c[4])\n{\n  real_T u0;\n  int32_T acoef;\n  acoef = (a->size[0] != 1);\n  if ((a->data[0] <= b[0]) || rtIsNaN(b[0])) {\n    c[0] = a->data[0];\n  } else {\n    c[0] = b[0];\n  }\n\n  u0 = a->data[acoef];\n  if ((u0 <= b[1]) || rtIsNaN(b[1])) {\n    c[1] = u0;\n  } else {\n    c[1] = b[1];\n  }\n\n  u0 = a->data[acoef << 1];\n  if ((u0 <= b[2]) || rtIsNaN(b[2])) {\n    c[2] = u0;\n  } else {\n    c[2] = b[2];\n  }\n\n  u0 = a->data[acoef * 3];\n  if ((u0 <= b[3]) || rtIsNaN(b[3])) {\n    c[3] = u0;\n  } else {\n    c[3] = b[3];\n  }\n}\n\nstatic void inverse_kinem_emxFree_boolean_T(emxArray_boolean_T_inverse_ki_T\n  **pEmxArray)\n{\n  if (*pEmxArray != static_cast<emxArray_boolean_T_inverse_ki_T *>(NULL)) {\n    if (((*pEmxArray)->data != static_cast<boolean_T *>(NULL)) && (*pEmxArray)\n        ->canFreeData) {\n      free((*pEmxArray)->data);\n    }\n\n    free((*pEmxArray)->size);\n    free(*pEmxArray);\n    *pEmxArray = static_cast<emxArray_boolean_T_inverse_ki_T *>(NULL);\n  }\n}\n\nstatic void ErrorDampedLevenbergMarquardt_s(h_robotics_core_internal_Erro_T *obj,\n  real_T xSol[4], c_robotics_core_internal_NLPS_T *exitFlag, real_T *en, real_T *\n  iter)\n{\n  emxArray_boolean_T_inverse_ki_T *x;\n  emxArray_char_T_inverse_kinem_T *bodyName;\n  emxArray_real_T_inverse_kinem_T *H0;\n  emxArray_real_T_inverse_kinem_T *J;\n  emxArray_real_T_inverse_kinem_T *b;\n  emxArray_real_T_inverse_kinem_T *ev;\n  emxArray_real_T_inverse_kinem_T *evprev;\n  emxArray_real_T_inverse_kinem_T *grad;\n  emxArray_real_T_inverse_kinem_T *tmp;\n  emxArray_real_T_inverse_kinem_T *y;\n  f_robotics_manip_internal_IKE_T *args;\n  v_robotics_manip_internal_Rig_T *treeInternal;\n  static const real_T tmp_0[16] = { 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 };\n\n  emxArray_real_T_inverse_kinem_T *J_0;\n  inverse_kinemati_emxInit_char_T(&bodyName, 2);\n  xSol[0] = obj->SeedInternal[0];\n  xSol[1] = obj->SeedInternal[1];\n  xSol[2] = obj->SeedInternal[2];\n  xSol[3] = obj->SeedInternal[3];\n  inverse_kinematics_tic(&obj->TimeObjInternal.StartTime.tv_sec,\n    &obj->TimeObjInternal.StartTime.tv_nsec);\n  inverse_kinematics_B.xprev_idx_0 = xSol[0];\n  inverse_kinematics_B.xprev_idx_1 = xSol[1];\n  inverse_kinematics_B.xprev_idx_2 = xSol[2];\n  inverse_kinematics_B.xprev_idx_3 = xSol[3];\n  args = obj->ExtraArgs;\n  treeInternal = args->Robot;\n  inverse_kinematics_B.J = bodyName->size[0] * bodyName->size[1];\n  bodyName->size[0] = 1;\n  bodyName->size[1] = args->BodyName->size[1];\n  invers_emxEnsureCapacity_char_T(bodyName, inverse_kinematics_B.J);\n  inverse_kinematics_B.kend = args->BodyName->size[1] - 1;\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <=\n       inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n    inverse_kinematics_B.J = inverse_kinematics_B.b_k_f;\n    bodyName->data[inverse_kinematics_B.J] = args->BodyName->\n      data[inverse_kinematics_B.J];\n  }\n\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 16;\n       inverse_kinematics_B.b_k_f++) {\n    inverse_kinematics_B.Td[inverse_kinematics_B.b_k_f] = args->\n      Tform[inverse_kinematics_B.b_k_f];\n  }\n\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 36;\n       inverse_kinematics_B.b_k_f++) {\n    inverse_kinematics_B.weightMatrix_m[inverse_kinematics_B.b_k_f] =\n      args->WeightMatrix[inverse_kinematics_B.b_k_f];\n  }\n\n  inverse_kinemati_emxInit_real_T(&J, 2);\n  RigidBodyTree_efficientFKAndJac(treeInternal, xSol, bodyName,\n    inverse_kinematics_B.T_data, inverse_kinematics_B.T_size, J);\n  inverse_kin_IKHelpers_poseError(inverse_kinematics_B.Td,\n    inverse_kinematics_B.T_data, inverse_kinematics_B.T_size,\n    inverse_kinematics_B.e);\n  inverse_kinematics_B.J = args->ErrTemp->size[0];\n  args->ErrTemp->size[0] = 6;\n  invers_emxEnsureCapacity_real_T(args->ErrTemp, inverse_kinematics_B.J);\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n       inverse_kinematics_B.b_k_f++) {\n    args->ErrTemp->data[inverse_kinematics_B.b_k_f] =\n      inverse_kinematics_B.e[inverse_kinematics_B.b_k_f];\n  }\n\n  inverse_kinematics_B.absxk = 0.0;\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n       inverse_kinematics_B.b_k_f++) {\n    inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] = 0.0;\n    for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n         inverse_kinematics_B.kend++) {\n      inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] +=\n        inverse_kinematics_B.weightMatrix_m[6 * inverse_kinematics_B.b_k_f +\n        inverse_kinematics_B.kend] * (0.5 *\n        inverse_kinematics_B.e[inverse_kinematics_B.kend]);\n    }\n\n    inverse_kinematics_B.absxk +=\n      inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] *\n      inverse_kinematics_B.e[inverse_kinematics_B.b_k_f];\n  }\n\n  args->CostTemp = inverse_kinematics_B.absxk;\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n       inverse_kinematics_B.b_k_f++) {\n    inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] = 0.0;\n    for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n         inverse_kinematics_B.kend++) {\n      inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] +=\n        inverse_kinematics_B.weightMatrix_m[6 * inverse_kinematics_B.b_k_f +\n        inverse_kinematics_B.kend] *\n        inverse_kinematics_B.e[inverse_kinematics_B.kend];\n    }\n  }\n\n  inverse_kinemati_emxInit_real_T(&J_0, 2);\n  inverse_kinematics_B.J = J_0->size[0] * J_0->size[1];\n  J_0->size[0] = 6;\n  J_0->size[1] = J->size[1];\n  invers_emxEnsureCapacity_real_T(J_0, inverse_kinematics_B.J);\n  inverse_kinematics_B.kend = 6 * J->size[1];\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n       inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n    J_0->data[inverse_kinematics_B.b_k_f] = -J->data[inverse_kinematics_B.b_k_f];\n  }\n\n  inverse_kinemati_emxInit_real_T(&tmp, 2);\n  inverse_kinematics_mtimes_g(inverse_kinematics_B.e_m, J_0, tmp);\n  inverse_kinematics_B.J = args->GradTemp->size[0];\n  args->GradTemp->size[0] = tmp->size[1];\n  invers_emxEnsureCapacity_real_T(args->GradTemp, inverse_kinematics_B.J);\n  inverse_kinematics_B.kend = tmp->size[1];\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n       inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n    args->GradTemp->data[inverse_kinematics_B.b_k_f] = tmp->\n      data[inverse_kinematics_B.b_k_f];\n  }\n\n  inverse_kinemati_emxInit_real_T(&evprev, 1);\n  obj->ExtraArgs = args;\n  args = obj->ExtraArgs;\n  inverse_kinematics_B.J = evprev->size[0];\n  evprev->size[0] = args->ErrTemp->size[0];\n  invers_emxEnsureCapacity_real_T(evprev, inverse_kinematics_B.J);\n  inverse_kinematics_B.kend = args->ErrTemp->size[0];\n  for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n       inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n    evprev->data[inverse_kinematics_B.b_k_f] = args->ErrTemp->\n      data[inverse_kinematics_B.b_k_f];\n  }\n\n  inverse_kinematics_B.d = obj->MaxNumIterationInternal;\n  inverse_kinematics_B.b_i_i = 0;\n  inverse_kinemati_emxInit_real_T(&grad, 1);\n  inverse_kinemati_emxInit_real_T(&H0, 2);\n  inverse_kinemati_emxInit_real_T(&ev, 1);\n  inverse_kinemati_emxInit_real_T(&y, 2);\n  inverse_kinemati_emxInit_real_T(&b, 1);\n  inverse_kinem_emxInit_boolean_T(&x, 1);\n  int32_T exitg1;\n  do {\n    exitg1 = 0;\n    if (inverse_kinematics_B.b_i_i <= static_cast<int32_T>\n        (inverse_kinematics_B.d) - 1) {\n      args = obj->ExtraArgs;\n      treeInternal = args->Robot;\n      inverse_kinematics_B.J = bodyName->size[0] * bodyName->size[1];\n      bodyName->size[0] = 1;\n      bodyName->size[1] = args->BodyName->size[1];\n      invers_emxEnsureCapacity_char_T(bodyName, inverse_kinematics_B.J);\n      inverse_kinematics_B.kend = args->BodyName->size[1] - 1;\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <=\n           inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.J = inverse_kinematics_B.b_k_f;\n        bodyName->data[inverse_kinematics_B.J] = args->BodyName->\n          data[inverse_kinematics_B.J];\n      }\n\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 16;\n           inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.Td[inverse_kinematics_B.b_k_f] = args->\n          Tform[inverse_kinematics_B.b_k_f];\n      }\n\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 36;\n           inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.weightMatrix_m[inverse_kinematics_B.b_k_f] =\n          args->WeightMatrix[inverse_kinematics_B.b_k_f];\n      }\n\n      RigidBodyTree_efficientFKAndJac(treeInternal, xSol, bodyName,\n        inverse_kinematics_B.T_data, inverse_kinematics_B.T_size, J);\n      inverse_kinematics_B.J = J_0->size[0] * J_0->size[1];\n      J_0->size[0] = 6;\n      J_0->size[1] = J->size[1];\n      invers_emxEnsureCapacity_real_T(J_0, inverse_kinematics_B.J);\n      inverse_kinematics_B.kend = 6 * J->size[1];\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n           inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n        J_0->data[inverse_kinematics_B.b_k_f] = -J->\n          data[inverse_kinematics_B.b_k_f];\n      }\n\n      inverse_kin_IKHelpers_poseError(inverse_kinematics_B.Td,\n        inverse_kinematics_B.T_data, inverse_kinematics_B.T_size,\n        inverse_kinematics_B.e);\n      inverse_kinematics_B.J = args->ErrTemp->size[0];\n      args->ErrTemp->size[0] = 6;\n      invers_emxEnsureCapacity_real_T(args->ErrTemp, inverse_kinematics_B.J);\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n           inverse_kinematics_B.b_k_f++) {\n        args->ErrTemp->data[inverse_kinematics_B.b_k_f] =\n          inverse_kinematics_B.e[inverse_kinematics_B.b_k_f];\n      }\n\n      inverse_kinematics_B.absxk = 0.0;\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n           inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] = 0.0;\n        for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n             inverse_kinematics_B.kend++) {\n          inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] +=\n            inverse_kinematics_B.weightMatrix_m[6 * inverse_kinematics_B.b_k_f +\n            inverse_kinematics_B.kend] * (0.5 *\n            inverse_kinematics_B.e[inverse_kinematics_B.kend]);\n        }\n\n        inverse_kinematics_B.absxk +=\n          inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] *\n          inverse_kinematics_B.e[inverse_kinematics_B.b_k_f];\n      }\n\n      args->CostTemp = inverse_kinematics_B.absxk;\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n           inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] = 0.0;\n        for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n             inverse_kinematics_B.kend++) {\n          inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] +=\n            inverse_kinematics_B.weightMatrix_m[6 * inverse_kinematics_B.b_k_f +\n            inverse_kinematics_B.kend] *\n            inverse_kinematics_B.e[inverse_kinematics_B.kend];\n        }\n      }\n\n      inverse_kinematics_mtimes_g(inverse_kinematics_B.e_m, J_0, tmp);\n      inverse_kinematics_B.J = args->GradTemp->size[0];\n      args->GradTemp->size[0] = tmp->size[1];\n      invers_emxEnsureCapacity_real_T(args->GradTemp, inverse_kinematics_B.J);\n      inverse_kinematics_B.kend = tmp->size[1];\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n           inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n        args->GradTemp->data[inverse_kinematics_B.b_k_f] = tmp->\n          data[inverse_kinematics_B.b_k_f];\n      }\n\n      inverse_kinematics_B.cost = args->CostTemp;\n      obj->ExtraArgs = args;\n      args = obj->ExtraArgs;\n      inverse_kinematics_B.J = grad->size[0];\n      grad->size[0] = args->GradTemp->size[0];\n      invers_emxEnsureCapacity_real_T(grad, inverse_kinematics_B.J);\n      inverse_kinematics_B.kend = args->GradTemp->size[0];\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n           inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n        grad->data[inverse_kinematics_B.b_k_f] = args->GradTemp->\n          data[inverse_kinematics_B.b_k_f];\n      }\n\n      args = obj->ExtraArgs;\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 36;\n           inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.a[inverse_kinematics_B.b_k_f] = args->\n          WeightMatrix[inverse_kinematics_B.b_k_f];\n      }\n\n      inverse_kinematics_B.J = b->size[0];\n      b->size[0] = args->ErrTemp->size[0];\n      invers_emxEnsureCapacity_real_T(b, inverse_kinematics_B.J);\n      inverse_kinematics_B.kend = args->ErrTemp->size[0];\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n           inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n        b->data[inverse_kinematics_B.b_k_f] = args->ErrTemp->\n          data[inverse_kinematics_B.b_k_f];\n      }\n\n      inverse_kinematics_B.J = ev->size[0];\n      ev->size[0] = args->ErrTemp->size[0];\n      invers_emxEnsureCapacity_real_T(ev, inverse_kinematics_B.J);\n      inverse_kinematics_B.kend = args->ErrTemp->size[0];\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n           inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n        ev->data[inverse_kinematics_B.b_k_f] = args->ErrTemp->\n          data[inverse_kinematics_B.b_k_f];\n      }\n\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n           inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.e[inverse_kinematics_B.b_k_f] = 0.0;\n        for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n             inverse_kinematics_B.kend++) {\n          inverse_kinematics_B.e[inverse_kinematics_B.b_k_f] +=\n            inverse_kinematics_B.a[6 * inverse_kinematics_B.kend +\n            inverse_kinematics_B.b_k_f] * b->data[inverse_kinematics_B.kend];\n        }\n      }\n\n      *en = inverse_kinematics_norm_g(inverse_kinematics_B.e);\n      *iter = static_cast<real_T>(inverse_kinematics_B.b_i_i) + 1.0;\n      if (grad->size[0] == 0) {\n        inverse_kinematics_B.cc = 0.0;\n      } else {\n        inverse_kinematics_B.cc = 0.0;\n        if (grad->size[0] == 1) {\n          inverse_kinematics_B.cc = fabs(grad->data[0]);\n        } else {\n          inverse_kinematics_B.scale = 3.3121686421112381E-170;\n          inverse_kinematics_B.kend = grad->size[0] - 1;\n          for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <=\n               inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n            inverse_kinematics_B.absxk = fabs(grad->\n              data[inverse_kinematics_B.b_k_f]);\n            if (inverse_kinematics_B.absxk > inverse_kinematics_B.scale) {\n              inverse_kinematics_B.t = inverse_kinematics_B.scale /\n                inverse_kinematics_B.absxk;\n              inverse_kinematics_B.cc = inverse_kinematics_B.cc *\n                inverse_kinematics_B.t * inverse_kinematics_B.t + 1.0;\n              inverse_kinematics_B.scale = inverse_kinematics_B.absxk;\n            } else {\n              inverse_kinematics_B.t = inverse_kinematics_B.absxk /\n                inverse_kinematics_B.scale;\n              inverse_kinematics_B.cc += inverse_kinematics_B.t *\n                inverse_kinematics_B.t;\n            }\n          }\n\n          inverse_kinematics_B.cc = inverse_kinematics_B.scale * sqrt\n            (inverse_kinematics_B.cc);\n        }\n      }\n\n      inverse_kinematics_B.flag = (inverse_kinematics_B.cc <\n        obj->GradientTolerance);\n      if (inverse_kinematics_B.flag) {\n        *exitFlag = LocalMinimumFound;\n        exitg1 = 1;\n      } else {\n        boolean_T exitg2;\n        boolean_T guard1 = false;\n        boolean_T guard2 = false;\n        guard1 = false;\n        guard2 = false;\n        if (static_cast<real_T>(inverse_kinematics_B.b_i_i) + 1.0 > 1.0) {\n          inverse_kinematics_B.x_i[0] = (fabs(xSol[0] -\n            inverse_kinematics_B.xprev_idx_0) < obj->StepTolerance);\n          inverse_kinematics_B.x_i[1] = (fabs(xSol[1] -\n            inverse_kinematics_B.xprev_idx_1) < obj->StepTolerance);\n          inverse_kinematics_B.x_i[2] = (fabs(xSol[2] -\n            inverse_kinematics_B.xprev_idx_2) < obj->StepTolerance);\n          inverse_kinematics_B.x_i[3] = (fabs(xSol[3] -\n            inverse_kinematics_B.xprev_idx_3) < obj->StepTolerance);\n          inverse_kinematics_B.flag = true;\n          inverse_kinematics_B.b_k_f = 0;\n          exitg2 = false;\n          while ((!exitg2) && (inverse_kinematics_B.b_k_f < 4)) {\n            if (!inverse_kinematics_B.x_i[inverse_kinematics_B.b_k_f]) {\n              inverse_kinematics_B.flag = false;\n              exitg2 = true;\n            } else {\n              inverse_kinematics_B.b_k_f++;\n            }\n          }\n\n          if (inverse_kinematics_B.flag) {\n            *exitFlag = StepSizeBelowMinimum;\n            exitg1 = 1;\n          } else {\n            guard2 = true;\n          }\n        } else {\n          guard2 = true;\n        }\n\n        if (guard2) {\n          if (static_cast<real_T>(inverse_kinematics_B.b_i_i) + 1.0 > 1.0) {\n            if (ev->size[0] == evprev->size[0]) {\n              inverse_kinematics_B.J = evprev->size[0];\n              evprev->size[0] = ev->size[0];\n              invers_emxEnsureCapacity_real_T(evprev, inverse_kinematics_B.J);\n              inverse_kinematics_B.kend = ev->size[0];\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n                evprev->data[inverse_kinematics_B.b_k_f] = ev->\n                  data[inverse_kinematics_B.b_k_f] - evprev->\n                  data[inverse_kinematics_B.b_k_f];\n              }\n            } else {\n              inverse_kinematics_minus_g(evprev, ev);\n            }\n\n            inverse_kinematics_B.kend = evprev->size[0] - 1;\n            inverse_kinematics_B.J = b->size[0];\n            b->size[0] = evprev->size[0];\n            invers_emxEnsureCapacity_real_T(b, inverse_kinematics_B.J);\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <=\n                 inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n              b->data[inverse_kinematics_B.b_k_f] = fabs(evprev->\n                data[inverse_kinematics_B.b_k_f]);\n            }\n\n            inverse_kinematics_B.J = x->size[0];\n            x->size[0] = b->size[0];\n            inv_emxEnsureCapacity_boolean_T(x, inverse_kinematics_B.J);\n            inverse_kinematics_B.kend = b->size[0];\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                 inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n              x->data[inverse_kinematics_B.b_k_f] = (b->\n                data[inverse_kinematics_B.b_k_f] < obj->ErrorChangeTolerance);\n            }\n\n            inverse_kinematics_B.flag = true;\n            inverse_kinematics_B.b_k_f = 0;\n            exitg2 = false;\n            while ((!exitg2) && (inverse_kinematics_B.b_k_f + 1 <= x->size[0]))\n            {\n              if (!x->data[inverse_kinematics_B.b_k_f]) {\n                inverse_kinematics_B.flag = false;\n                exitg2 = true;\n              } else {\n                inverse_kinematics_B.b_k_f++;\n              }\n            }\n\n            if (inverse_kinematics_B.flag) {\n              *exitFlag = ChangeInErrorBelowMinimum;\n              exitg1 = 1;\n            } else {\n              guard1 = true;\n            }\n          } else {\n            guard1 = true;\n          }\n        }\n\n        if (guard1) {\n          inverse_kinematics_B.xprev_idx_0 = inverse_kinematics_toc\n            (obj->TimeObjInternal.StartTime.tv_sec,\n             obj->TimeObjInternal.StartTime.tv_nsec);\n          inverse_kinematics_B.flag = (inverse_kinematics_B.xprev_idx_0 >\n            obj->MaxTimeInternal);\n          if (inverse_kinematics_B.flag) {\n            *exitFlag = TimeLimitExceeded;\n            exitg1 = 1;\n          } else {\n            inverse_kinematics_B.J = evprev->size[0];\n            evprev->size[0] = ev->size[0];\n            invers_emxEnsureCapacity_real_T(evprev, inverse_kinematics_B.J);\n            inverse_kinematics_B.kend = ev->size[0];\n            if (inverse_kinematics_B.kend - 1 >= 0) {\n              memcpy(&evprev->data[0], &ev->data[0], inverse_kinematics_B.kend *\n                     sizeof(real_T));\n            }\n\n            inverse_kinematics_B.xprev_idx_0 = xSol[0];\n            inverse_kinematics_B.xprev_idx_1 = xSol[1];\n            inverse_kinematics_B.xprev_idx_2 = xSol[2];\n            inverse_kinematics_B.xprev_idx_3 = xSol[3];\n            inverse_kinematics_B.flag = obj->UseErrorDamping;\n            inverse_kinematics_B.cc = static_cast<real_T>\n              (inverse_kinematics_B.flag) * inverse_kinematics_B.cost;\n            inverse_kinematics_B.absxk = inverse_kinematics_B.cc +\n              obj->DampingBias;\n            inverse_kinematics_B.m = J_0->size[1];\n            inverse_kinematics_B.J = y->size[0] * y->size[1];\n            y->size[0] = J_0->size[1];\n            y->size[1] = 6;\n            invers_emxEnsureCapacity_real_T(y, inverse_kinematics_B.J);\n            for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n                 inverse_kinematics_B.kend++) {\n              inverse_kinematics_B.coffset = inverse_kinematics_B.kend *\n                inverse_kinematics_B.m - 1;\n              inverse_kinematics_B.boffset = inverse_kinematics_B.kend * 6 - 1;\n              for (inverse_kinematics_B.J = 0; inverse_kinematics_B.J <\n                   inverse_kinematics_B.m; inverse_kinematics_B.J++) {\n                inverse_kinematics_B.aoffset = inverse_kinematics_B.J * 6 - 1;\n                inverse_kinematics_B.scale = 0.0;\n                for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                     6; inverse_kinematics_B.b_k_f++) {\n                  inverse_kinematics_B.scale += J_0->data\n                    [(inverse_kinematics_B.b_k_f + inverse_kinematics_B.aoffset)\n                    + 1] * inverse_kinematics_B.weightMatrix_m\n                    [(inverse_kinematics_B.b_k_f + inverse_kinematics_B.boffset)\n                    + 1];\n                }\n\n                y->data[(inverse_kinematics_B.coffset + inverse_kinematics_B.J)\n                  + 1] = inverse_kinematics_B.scale;\n              }\n            }\n\n            inverse_kinematics_B.m = y->size[0];\n            inverse_kinematics_B.aoffset = J_0->size[1] - 1;\n            inverse_kinematics_B.J = H0->size[0] * H0->size[1];\n            H0->size[0] = y->size[0];\n            H0->size[1] = J_0->size[1];\n            invers_emxEnsureCapacity_real_T(H0, inverse_kinematics_B.J);\n            for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend <=\n                 inverse_kinematics_B.aoffset; inverse_kinematics_B.kend++) {\n              inverse_kinematics_B.coffset = inverse_kinematics_B.kend *\n                inverse_kinematics_B.m - 1;\n              inverse_kinematics_B.boffset = inverse_kinematics_B.kend * 6 - 1;\n              for (inverse_kinematics_B.J = 0; inverse_kinematics_B.J <\n                   inverse_kinematics_B.m; inverse_kinematics_B.J++) {\n                inverse_kinematics_B.scale = 0.0;\n                for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                     6; inverse_kinematics_B.b_k_f++) {\n                  inverse_kinematics_B.scale += y->\n                    data[inverse_kinematics_B.b_k_f * y->size[0] +\n                    inverse_kinematics_B.J] * J_0->data\n                    [(inverse_kinematics_B.boffset + inverse_kinematics_B.b_k_f)\n                    + 1];\n                }\n\n                H0->data[(inverse_kinematics_B.coffset + inverse_kinematics_B.J)\n                  + 1] = inverse_kinematics_B.scale;\n              }\n            }\n\n            if ((H0->size[0] == 4) && (H0->size[1] == 4)) {\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   4; inverse_kinematics_B.b_k_f++) {\n                for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend <\n                     4; inverse_kinematics_B.kend++) {\n                  inverse_kinematics_B.J = (inverse_kinematics_B.b_k_f << 2) +\n                    inverse_kinematics_B.kend;\n                  inverse_kinematics_B.Td[inverse_kinematics_B.J] = -(H0->\n                    data[H0->size[0] * inverse_kinematics_B.b_k_f +\n                    inverse_kinematics_B.kend] + tmp_0[inverse_kinematics_B.J] *\n                    inverse_kinematics_B.absxk);\n                }\n              }\n\n              inverse_kinematics_mldivide(inverse_kinematics_B.Td, grad,\n                inverse_kinematics_B.step_data, &inverse_kinematics_B.step_size);\n            } else {\n              inverse_kine_binary_expand_op_g(inverse_kinematics_B.step_data,\n                &inverse_kinematics_B.step_size, H0, inverse_kinematics_B.absxk,\n                tmp_0, grad);\n            }\n\n            args = obj->ExtraArgs;\n            treeInternal = args->Robot;\n            inverse_kinematics_B.J = bodyName->size[0] * bodyName->size[1];\n            bodyName->size[0] = 1;\n            bodyName->size[1] = args->BodyName->size[1];\n            invers_emxEnsureCapacity_char_T(bodyName, inverse_kinematics_B.J);\n            inverse_kinematics_B.kend = args->BodyName->size[1] - 1;\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <=\n                 inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n              inverse_kinematics_B.J = inverse_kinematics_B.b_k_f;\n              bodyName->data[inverse_kinematics_B.J] = args->BodyName->\n                data[inverse_kinematics_B.J];\n            }\n\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 16;\n                 inverse_kinematics_B.b_k_f++) {\n              inverse_kinematics_B.Td[inverse_kinematics_B.b_k_f] = args->\n                Tform[inverse_kinematics_B.b_k_f];\n            }\n\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 36;\n                 inverse_kinematics_B.b_k_f++) {\n              inverse_kinematics_B.weightMatrix_m[inverse_kinematics_B.b_k_f] =\n                args->WeightMatrix[inverse_kinematics_B.b_k_f];\n            }\n\n            inverse_kinematics_B.y_d[0] = xSol[0] +\n              inverse_kinematics_B.step_data[0];\n            inverse_kinematics_B.y_d[1] = xSol[1] +\n              inverse_kinematics_B.step_data[1];\n            inverse_kinematics_B.y_d[2] = xSol[2] +\n              inverse_kinematics_B.step_data[2];\n            inverse_kinematics_B.y_d[3] = xSol[3] +\n              inverse_kinematics_B.step_data[3];\n            RigidBodyTree_efficientFKAndJac(treeInternal,\n              inverse_kinematics_B.y_d, bodyName, inverse_kinematics_B.T_data,\n              inverse_kinematics_B.T_size, J);\n            inverse_kin_IKHelpers_poseError(inverse_kinematics_B.Td,\n              inverse_kinematics_B.T_data, inverse_kinematics_B.T_size,\n              inverse_kinematics_B.e);\n            inverse_kinematics_B.J = args->ErrTemp->size[0];\n            args->ErrTemp->size[0] = 6;\n            invers_emxEnsureCapacity_real_T(args->ErrTemp,\n              inverse_kinematics_B.J);\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n                 inverse_kinematics_B.b_k_f++) {\n              args->ErrTemp->data[inverse_kinematics_B.b_k_f] =\n                inverse_kinematics_B.e[inverse_kinematics_B.b_k_f];\n            }\n\n            inverse_kinematics_B.absxk = 0.0;\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n                 inverse_kinematics_B.b_k_f++) {\n              inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] = 0.0;\n              for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n                   inverse_kinematics_B.kend++) {\n                inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] +=\n                  inverse_kinematics_B.weightMatrix_m[6 *\n                  inverse_kinematics_B.b_k_f + inverse_kinematics_B.kend] * (0.5\n                  * inverse_kinematics_B.e[inverse_kinematics_B.kend]);\n              }\n\n              inverse_kinematics_B.absxk +=\n                inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] *\n                inverse_kinematics_B.e[inverse_kinematics_B.b_k_f];\n            }\n\n            args->CostTemp = inverse_kinematics_B.absxk;\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n                 inverse_kinematics_B.b_k_f++) {\n              inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] = 0.0;\n              for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n                   inverse_kinematics_B.kend++) {\n                inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] +=\n                  inverse_kinematics_B.weightMatrix_m[6 *\n                  inverse_kinematics_B.b_k_f + inverse_kinematics_B.kend] *\n                  inverse_kinematics_B.e[inverse_kinematics_B.kend];\n              }\n            }\n\n            inverse_kinematics_B.J = J_0->size[0] * J_0->size[1];\n            J_0->size[0] = 6;\n            J_0->size[1] = J->size[1];\n            invers_emxEnsureCapacity_real_T(J_0, inverse_kinematics_B.J);\n            inverse_kinematics_B.kend = 6 * J->size[1];\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                 inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n              J_0->data[inverse_kinematics_B.b_k_f] = -J->\n                data[inverse_kinematics_B.b_k_f];\n            }\n\n            inverse_kinematics_mtimes_g(inverse_kinematics_B.e_m, J_0, tmp);\n            inverse_kinematics_B.J = args->GradTemp->size[0];\n            args->GradTemp->size[0] = tmp->size[1];\n            invers_emxEnsureCapacity_real_T(args->GradTemp,\n              inverse_kinematics_B.J);\n            inverse_kinematics_B.kend = tmp->size[1];\n            for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                 inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n              args->GradTemp->data[inverse_kinematics_B.b_k_f] = tmp->\n                data[inverse_kinematics_B.b_k_f];\n            }\n\n            inverse_kinematics_B.absxk = args->CostTemp;\n            inverse_kinematics_B.scale = 1.0;\n            while (inverse_kinematics_B.absxk > inverse_kinematics_B.cost) {\n              inverse_kinematics_B.scale *= 2.5;\n              inverse_kinematics_B.absxk = inverse_kinematics_B.scale *\n                obj->DampingBias + inverse_kinematics_B.cc;\n              if ((H0->size[0] == 4) && (H0->size[1] == 4)) {\n                for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                     4; inverse_kinematics_B.b_k_f++) {\n                  for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend <\n                       4; inverse_kinematics_B.kend++) {\n                    inverse_kinematics_B.J = (inverse_kinematics_B.b_k_f << 2) +\n                      inverse_kinematics_B.kend;\n                    inverse_kinematics_B.Td[inverse_kinematics_B.J] = -(H0->\n                      data[H0->size[0] * inverse_kinematics_B.b_k_f +\n                      inverse_kinematics_B.kend] + tmp_0[inverse_kinematics_B.J]\n                      * inverse_kinematics_B.absxk);\n                  }\n                }\n\n                inverse_kinematics_mldivide(inverse_kinematics_B.Td, grad,\n                  inverse_kinematics_B.step_data,\n                  &inverse_kinematics_B.step_size);\n              } else {\n                inverse_kine_binary_expand_op_g(inverse_kinematics_B.step_data,\n                  &inverse_kinematics_B.step_size, H0,\n                  inverse_kinematics_B.absxk, tmp_0, grad);\n              }\n\n              args = obj->ExtraArgs;\n              treeInternal = args->Robot;\n              inverse_kinematics_B.J = bodyName->size[0] * bodyName->size[1];\n              bodyName->size[0] = 1;\n              bodyName->size[1] = args->BodyName->size[1];\n              invers_emxEnsureCapacity_char_T(bodyName, inverse_kinematics_B.J);\n              inverse_kinematics_B.kend = args->BodyName->size[1] - 1;\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <=\n                   inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n                inverse_kinematics_B.J = inverse_kinematics_B.b_k_f;\n                bodyName->data[inverse_kinematics_B.J] = args->BodyName->\n                  data[inverse_kinematics_B.J];\n              }\n\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   16; inverse_kinematics_B.b_k_f++) {\n                inverse_kinematics_B.Td[inverse_kinematics_B.b_k_f] =\n                  args->Tform[inverse_kinematics_B.b_k_f];\n              }\n\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   36; inverse_kinematics_B.b_k_f++) {\n                inverse_kinematics_B.weightMatrix_m[inverse_kinematics_B.b_k_f] =\n                  args->WeightMatrix[inverse_kinematics_B.b_k_f];\n              }\n\n              inverse_kinematics_B.y_d[0] = xSol[0] +\n                inverse_kinematics_B.step_data[0];\n              inverse_kinematics_B.y_d[1] = xSol[1] +\n                inverse_kinematics_B.step_data[1];\n              inverse_kinematics_B.y_d[2] = xSol[2] +\n                inverse_kinematics_B.step_data[2];\n              inverse_kinematics_B.y_d[3] = xSol[3] +\n                inverse_kinematics_B.step_data[3];\n              RigidBodyTree_efficientFKAndJac(treeInternal,\n                inverse_kinematics_B.y_d, bodyName, inverse_kinematics_B.T_data,\n                inverse_kinematics_B.T_size, J);\n              inverse_kin_IKHelpers_poseError(inverse_kinematics_B.Td,\n                inverse_kinematics_B.T_data, inverse_kinematics_B.T_size,\n                inverse_kinematics_B.e);\n              inverse_kinematics_B.J = args->ErrTemp->size[0];\n              args->ErrTemp->size[0] = 6;\n              invers_emxEnsureCapacity_real_T(args->ErrTemp,\n                inverse_kinematics_B.J);\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   6; inverse_kinematics_B.b_k_f++) {\n                args->ErrTemp->data[inverse_kinematics_B.b_k_f] =\n                  inverse_kinematics_B.e[inverse_kinematics_B.b_k_f];\n              }\n\n              inverse_kinematics_B.absxk = 0.0;\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   6; inverse_kinematics_B.b_k_f++) {\n                inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] = 0.0;\n                for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend <\n                     6; inverse_kinematics_B.kend++) {\n                  inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] +=\n                    inverse_kinematics_B.weightMatrix_m[6 *\n                    inverse_kinematics_B.b_k_f + inverse_kinematics_B.kend] *\n                    (0.5 * inverse_kinematics_B.e[inverse_kinematics_B.kend]);\n                }\n\n                inverse_kinematics_B.absxk +=\n                  inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] *\n                  inverse_kinematics_B.e[inverse_kinematics_B.b_k_f];\n              }\n\n              args->CostTemp = inverse_kinematics_B.absxk;\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   6; inverse_kinematics_B.b_k_f++) {\n                inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] = 0.0;\n                for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend <\n                     6; inverse_kinematics_B.kend++) {\n                  inverse_kinematics_B.e_m[inverse_kinematics_B.b_k_f] +=\n                    inverse_kinematics_B.weightMatrix_m[6 *\n                    inverse_kinematics_B.b_k_f + inverse_kinematics_B.kend] *\n                    inverse_kinematics_B.e[inverse_kinematics_B.kend];\n                }\n              }\n\n              inverse_kinematics_B.J = J_0->size[0] * J_0->size[1];\n              J_0->size[0] = 6;\n              J_0->size[1] = J->size[1];\n              invers_emxEnsureCapacity_real_T(J_0, inverse_kinematics_B.J);\n              inverse_kinematics_B.kend = 6 * J->size[1];\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n                J_0->data[inverse_kinematics_B.b_k_f] = -J->\n                  data[inverse_kinematics_B.b_k_f];\n              }\n\n              inverse_kinematics_mtimes_g(inverse_kinematics_B.e_m, J_0, tmp);\n              inverse_kinematics_B.J = args->GradTemp->size[0];\n              args->GradTemp->size[0] = tmp->size[1];\n              invers_emxEnsureCapacity_real_T(args->GradTemp,\n                inverse_kinematics_B.J);\n              inverse_kinematics_B.kend = tmp->size[1];\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n                args->GradTemp->data[inverse_kinematics_B.b_k_f] = tmp->\n                  data[inverse_kinematics_B.b_k_f];\n              }\n\n              inverse_kinematics_B.absxk = args->CostTemp;\n            }\n\n            inverse_kinematics_B.cost = xSol[0] +\n              inverse_kinematics_B.step_data[0];\n            xSol[0] += inverse_kinematics_B.step_data[0];\n            inverse_kinematics_B.absxk = xSol[1] +\n              inverse_kinematics_B.step_data[1];\n            xSol[1] += inverse_kinematics_B.step_data[1];\n            inverse_kinematics_B.cc = xSol[2] + inverse_kinematics_B.step_data[2];\n            xSol[2] += inverse_kinematics_B.step_data[2];\n            inverse_kinematics_B.scale = xSol[3] +\n              inverse_kinematics_B.step_data[3];\n            xSol[3] += inverse_kinematics_B.step_data[3];\n            if (obj->ConstraintsOn) {\n              args = obj->ExtraArgs;\n              inverse_kinematics_B.kend = args->Limits->size[0];\n              inverse_kinematics_B.J = grad->size[0];\n              grad->size[0] = inverse_kinematics_B.kend;\n              invers_emxEnsureCapacity_real_T(grad, inverse_kinematics_B.J);\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n                grad->data[inverse_kinematics_B.b_k_f] = args->Limits->\n                  data[inverse_kinematics_B.b_k_f];\n              }\n\n              if (grad->size[0] == 4) {\n                if ((grad->data[0] >= inverse_kinematics_B.cost) || rtIsNaN\n                    (inverse_kinematics_B.cost)) {\n                  inverse_kinematics_B.y_d[0] = grad->data[0];\n                } else {\n                  inverse_kinematics_B.y_d[0] = inverse_kinematics_B.cost;\n                }\n\n                if ((grad->data[1] >= inverse_kinematics_B.absxk) || rtIsNaN\n                    (inverse_kinematics_B.absxk)) {\n                  inverse_kinematics_B.y_d[1] = grad->data[1];\n                } else {\n                  inverse_kinematics_B.y_d[1] = inverse_kinematics_B.absxk;\n                }\n\n                if ((grad->data[2] >= inverse_kinematics_B.cc) || rtIsNaN\n                    (inverse_kinematics_B.cc)) {\n                  inverse_kinematics_B.y_d[2] = grad->data[2];\n                } else {\n                  inverse_kinematics_B.y_d[2] = inverse_kinematics_B.cc;\n                }\n\n                if ((grad->data[3] >= inverse_kinematics_B.scale) || rtIsNaN\n                    (inverse_kinematics_B.scale)) {\n                  inverse_kinematics_B.y_d[3] = grad->data[3];\n                } else {\n                  inverse_kinematics_B.y_d[3] = inverse_kinematics_B.scale;\n                }\n              } else {\n                inverse_kinematics_expand_max(grad, xSol,\n                  inverse_kinematics_B.y_d);\n              }\n\n              inverse_kinematics_B.kend = args->Limits->size[0];\n              inverse_kinematics_B.J = grad->size[0];\n              grad->size[0] = inverse_kinematics_B.kend;\n              invers_emxEnsureCapacity_real_T(grad, inverse_kinematics_B.J);\n              for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n                   inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n                grad->data[inverse_kinematics_B.b_k_f] = args->Limits->\n                  data[inverse_kinematics_B.b_k_f + args->Limits->size[0]];\n              }\n\n              if (grad->size[0] == 4) {\n                if ((grad->data[0] <= inverse_kinematics_B.y_d[0]) || rtIsNaN\n                    (inverse_kinematics_B.y_d[0])) {\n                  xSol[0] = grad->data[0];\n                } else {\n                  xSol[0] = inverse_kinematics_B.y_d[0];\n                }\n\n                if ((grad->data[1] <= inverse_kinematics_B.y_d[1]) || rtIsNaN\n                    (inverse_kinematics_B.y_d[1])) {\n                  xSol[1] = grad->data[1];\n                } else {\n                  xSol[1] = inverse_kinematics_B.y_d[1];\n                }\n\n                if ((grad->data[2] <= inverse_kinematics_B.y_d[2]) || rtIsNaN\n                    (inverse_kinematics_B.y_d[2])) {\n                  xSol[2] = grad->data[2];\n                } else {\n                  xSol[2] = inverse_kinematics_B.y_d[2];\n                }\n\n                if ((grad->data[3] <= inverse_kinematics_B.y_d[3]) || rtIsNaN\n                    (inverse_kinematics_B.y_d[3])) {\n                  xSol[3] = grad->data[3];\n                } else {\n                  xSol[3] = inverse_kinematics_B.y_d[3];\n                }\n              } else {\n                inverse_kinematics_expand_min(grad, inverse_kinematics_B.y_d,\n                  xSol);\n              }\n            }\n\n            inverse_kinematics_B.b_i_i++;\n          }\n        }\n      }\n    } else {\n      args = obj->ExtraArgs;\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 36;\n           inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.a[inverse_kinematics_B.b_k_f] = args->\n          WeightMatrix[inverse_kinematics_B.b_k_f];\n      }\n\n      inverse_kinematics_B.J = b->size[0];\n      b->size[0] = args->ErrTemp->size[0];\n      invers_emxEnsureCapacity_real_T(b, inverse_kinematics_B.J);\n      inverse_kinematics_B.kend = args->ErrTemp->size[0];\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f <\n           inverse_kinematics_B.kend; inverse_kinematics_B.b_k_f++) {\n        b->data[inverse_kinematics_B.b_k_f] = args->ErrTemp->\n          data[inverse_kinematics_B.b_k_f];\n      }\n\n      for (inverse_kinematics_B.b_k_f = 0; inverse_kinematics_B.b_k_f < 6;\n           inverse_kinematics_B.b_k_f++) {\n        inverse_kinematics_B.e[inverse_kinematics_B.b_k_f] = 0.0;\n        for (inverse_kinematics_B.kend = 0; inverse_kinematics_B.kend < 6;\n             inverse_kinematics_B.kend++) {\n          inverse_kinematics_B.e[inverse_kinematics_B.b_k_f] +=\n            inverse_kinematics_B.a[6 * inverse_kinematics_B.kend +\n            inverse_kinematics_B.b_k_f] * b->data[inverse_kinematics_B.kend];\n        }\n      }\n\n      *en = inverse_kinematics_norm_g(inverse_kinematics_B.e);\n      *iter = obj->MaxNumIterationInternal;\n      *exitFlag = IterationLimitExceeded;\n      exitg1 = 1;\n    }\n  } while (exitg1 == 0);\n\n  inverse_kinemati_emxFree_real_T(&J_0);\n  inverse_kinemati_emxFree_real_T(&tmp);\n  inverse_kinem_emxFree_boolean_T(&x);\n  inverse_kinemati_emxFree_real_T(&b);\n  inverse_kinemati_emxFree_real_T(&J);\n  inverse_kinemati_emxFree_char_T(&bodyName);\n  inverse_kinemati_emxFree_real_T(&y);\n  inverse_kinemati_emxFree_real_T(&ev);\n  inverse_kinemati_emxFree_real_T(&H0);\n  inverse_kinemati_emxFree_real_T(&grad);\n  inverse_kinemati_emxFree_real_T(&evprev);\n}\n\nstatic boolean_T inverse_kinematics_any(const emxArray_boolean_T_inverse_ki_T *x)\n{\n  int32_T ix;\n  boolean_T exitg1;\n  boolean_T y;\n  y = false;\n  ix = 0;\n  exitg1 = false;\n  while ((!exitg1) && (ix + 1 <= x->size[0])) {\n    if (x->data[ix]) {\n      y = true;\n      exitg1 = true;\n    } else {\n      ix++;\n    }\n  }\n\n  return y;\n}\n\nstatic void inverse_kinematics_randn(const real_T varargin_1[2],\n  emxArray_real_T_inverse_kinem_T *r)\n{\n  static const real_T tmp[257] = { 1.0, 0.977101701267673, 0.959879091800108,\n    0.9451989534423, 0.932060075959231, 0.919991505039348, 0.908726440052131,\n    0.898095921898344, 0.887984660755834, 0.878309655808918, 0.869008688036857,\n    0.860033621196332, 0.851346258458678, 0.842915653112205, 0.834716292986884,\n    0.826726833946222, 0.818929191603703, 0.811307874312656, 0.803849483170964,\n    0.796542330422959, 0.789376143566025, 0.782341832654803, 0.775431304981187,\n    0.768637315798486, 0.761953346836795, 0.755373506507096, 0.748892447219157,\n    0.742505296340151, 0.736207598126863, 0.729995264561476, 0.72386453346863,\n    0.717811932630722, 0.711834248878248, 0.705928501332754, 0.700091918136512,\n    0.694321916126117, 0.688616083004672, 0.682972161644995, 0.677388036218774,\n    0.671861719897082, 0.66639134390875, 0.660975147776663, 0.655611470579697,\n    0.650298743110817, 0.645035480820822, 0.639820277453057, 0.634651799287624,\n    0.629528779924837, 0.624450015547027, 0.619414360605834, 0.614420723888914,\n    0.609468064925773, 0.604555390697468, 0.599681752619125, 0.594846243767987,\n    0.590047996332826, 0.585286179263371, 0.580559996100791, 0.575868682972354,\n    0.571211506735253, 0.566587763256165, 0.561996775814525, 0.557437893618766,\n    0.552910490425833, 0.548413963255266, 0.543947731190026, 0.539511234256952,\n    0.535103932380458, 0.530725304403662, 0.526374847171684, 0.522052074672322,\n    0.517756517229756, 0.513487720747327, 0.509245245995748, 0.505028667943468,\n    0.500837575126149, 0.49667156905249, 0.492530263643869, 0.488413284705458,\n    0.484320269426683, 0.480250865909047, 0.476204732719506, 0.47218153846773,\n    0.468180961405694, 0.464202689048174, 0.460246417812843, 0.456311852678716,\n    0.452398706861849, 0.448506701507203, 0.444635565395739, 0.440785034665804,\n    0.436954852547985, 0.433144769112652, 0.429354541029442, 0.425583931338022,\n    0.421832709229496, 0.418100649837848, 0.414387534040891, 0.410693148270188,\n    0.407017284329473, 0.403359739221114, 0.399720314980197, 0.396098818515832,\n    0.392495061459315, 0.388908860018789, 0.385340034840077, 0.381788410873393,\n    0.378253817245619, 0.374736087137891, 0.371235057668239, 0.367750569779032,\n    0.364282468129004, 0.360830600989648, 0.357394820145781, 0.353974980800077,\n    0.350570941481406, 0.347182563956794, 0.343809713146851, 0.340452257044522,\n    0.337110066637006, 0.333783015830718, 0.330470981379163, 0.327173842813601,\n    0.323891482376391, 0.320623784956905, 0.317370638029914, 0.314131931596337,\n    0.310907558126286, 0.307697412504292, 0.30450139197665, 0.301319396100803,\n    0.298151326696685, 0.294997087799962, 0.291856585617095, 0.288729728482183,\n    0.285616426815502, 0.282516593083708, 0.279430141761638, 0.276356989295668,\n    0.273297054068577, 0.270250256365875, 0.267216518343561, 0.264195763997261,\n    0.261187919132721, 0.258192911337619, 0.255210669954662, 0.252241126055942,\n    0.249284212418529, 0.246339863501264, 0.24340801542275, 0.240488605940501,\n    0.237581574431238, 0.23468686187233, 0.231804410824339, 0.228934165414681,\n    0.226076071322381, 0.223230075763918, 0.220396127480152, 0.217574176724331,\n    0.214764175251174, 0.211966076307031, 0.209179834621125, 0.206405406397881,\n    0.203642749310335, 0.200891822494657, 0.198152586545776, 0.195425003514135,\n    0.192709036903589, 0.190004651670465, 0.187311814223801, 0.1846304924268,\n    0.181960655599523, 0.179302274522848, 0.176655321443735, 0.174019770081839,\n    0.171395595637506, 0.168782774801212, 0.166181285764482, 0.163591108232366,\n    0.161012223437511, 0.158444614155925, 0.15588826472448, 0.153343161060263,\n    0.150809290681846, 0.148286642732575, 0.145775208005994, 0.143274978973514,\n    0.140785949814445, 0.138308116448551, 0.135841476571254, 0.133386029691669,\n    0.130941777173644, 0.12850872228, 0.126086870220186, 0.123676228201597,\n    0.12127680548479, 0.11888861344291, 0.116511665625611, 0.114145977827839,\n    0.111791568163838, 0.109448457146812, 0.107116667774684, 0.104796225622487,\n    0.102487158941935, 0.10018949876881, 0.0979032790388625, 0.095628536713009,\n    0.093365311912691, 0.0911136480663738, 0.0888735920682759,\n    0.0866451944505581, 0.0844285095703535, 0.082223595813203,\n    0.0800305158146631, 0.0778493367020961, 0.0756801303589272,\n    0.0735229737139814, 0.0713779490588905, 0.0692451443970068,\n    0.0671246538277886, 0.065016577971243, 0.0629210244377582, 0.06083810834954,\n    0.0587679529209339, 0.0567106901062031, 0.0546664613248891,\n    0.0526354182767924, 0.0506177238609479, 0.0486135532158687,\n    0.0466230949019305, 0.0446465522512946, 0.0426841449164746,\n    0.0407361106559411, 0.0388027074045262, 0.0368842156885674,\n    0.0349809414617162, 0.0330932194585786, 0.0312214171919203,\n    0.0293659397581334, 0.0275272356696031, 0.0257058040085489,\n    0.0239022033057959, 0.0221170627073089, 0.0203510962300445,\n    0.0186051212757247, 0.0168800831525432, 0.0151770883079353,\n    0.0134974506017399, 0.0118427578579079, 0.0102149714397015,\n    0.00861658276939875, 0.00705087547137324, 0.00552240329925101,\n    0.00403797259336304, 0.00260907274610216, 0.0012602859304986,\n    0.000477467764609386 };\n\n  const real_T *fitab;\n  inverse_kinematics_B.b_k_e = r->size[0];\n  r->size[0] = static_cast<int32_T>(varargin_1[0]);\n  invers_emxEnsureCapacity_real_T(r, inverse_kinematics_B.b_k_e);\n  inverse_kinematics_B.d_tmp = static_cast<int32_T>(varargin_1[0]) - 1;\n  if (static_cast<int32_T>(varargin_1[0]) - 1 >= 0) {\n    inverse_kinematics_B.xi[0] = 0.0;\n    inverse_kinematics_B.xi[1] = 0.215241895984875;\n    inverse_kinematics_B.xi[2] = 0.286174591792068;\n    inverse_kinematics_B.xi[3] = 0.335737519214422;\n    inverse_kinematics_B.xi[4] = 0.375121332878378;\n    inverse_kinematics_B.xi[5] = 0.408389134611989;\n    inverse_kinematics_B.xi[6] = 0.43751840220787;\n    inverse_kinematics_B.xi[7] = 0.46363433679088;\n    inverse_kinematics_B.xi[8] = 0.487443966139235;\n    inverse_kinematics_B.xi[9] = 0.50942332960209;\n    inverse_kinematics_B.xi[10] = 0.529909720661557;\n    inverse_kinematics_B.xi[11] = 0.549151702327164;\n    inverse_kinematics_B.xi[12] = 0.567338257053817;\n    inverse_kinematics_B.xi[13] = 0.584616766106378;\n    inverse_kinematics_B.xi[14] = 0.601104617755991;\n    inverse_kinematics_B.xi[15] = 0.61689699000775;\n    inverse_kinematics_B.xi[16] = 0.63207223638606;\n    inverse_kinematics_B.xi[17] = 0.646695714894993;\n    inverse_kinematics_B.xi[18] = 0.660822574244419;\n    inverse_kinematics_B.xi[19] = 0.674499822837293;\n    inverse_kinematics_B.xi[20] = 0.687767892795788;\n    inverse_kinematics_B.xi[21] = 0.700661841106814;\n    inverse_kinematics_B.xi[22] = 0.713212285190975;\n    inverse_kinematics_B.xi[23] = 0.725446140909999;\n    inverse_kinematics_B.xi[24] = 0.737387211434295;\n    inverse_kinematics_B.xi[25] = 0.749056662017815;\n    inverse_kinematics_B.xi[26] = 0.760473406430107;\n    inverse_kinematics_B.xi[27] = 0.771654424224568;\n    inverse_kinematics_B.xi[28] = 0.782615023307232;\n    inverse_kinematics_B.xi[29] = 0.793369058840623;\n    inverse_kinematics_B.xi[30] = 0.80392911698997;\n    inverse_kinematics_B.xi[31] = 0.814306670135215;\n    inverse_kinematics_B.xi[32] = 0.824512208752291;\n    inverse_kinematics_B.xi[33] = 0.834555354086381;\n    inverse_kinematics_B.xi[34] = 0.844444954909153;\n    inverse_kinematics_B.xi[35] = 0.854189171008163;\n    inverse_kinematics_B.xi[36] = 0.863795545553308;\n    inverse_kinematics_B.xi[37] = 0.87327106808886;\n    inverse_kinematics_B.xi[38] = 0.882622229585165;\n    inverse_kinematics_B.xi[39] = 0.891855070732941;\n    inverse_kinematics_B.xi[40] = 0.900975224461221;\n    inverse_kinematics_B.xi[41] = 0.909987953496718;\n    inverse_kinematics_B.xi[42] = 0.91889818364959;\n    inverse_kinematics_B.xi[43] = 0.927710533401999;\n    inverse_kinematics_B.xi[44] = 0.936429340286575;\n    inverse_kinematics_B.xi[45] = 0.945058684468165;\n    inverse_kinematics_B.xi[46] = 0.953602409881086;\n    inverse_kinematics_B.xi[47] = 0.96206414322304;\n    inverse_kinematics_B.xi[48] = 0.970447311064224;\n    inverse_kinematics_B.xi[49] = 0.978755155294224;\n    inverse_kinematics_B.xi[50] = 0.986990747099062;\n    inverse_kinematics_B.xi[51] = 0.99515699963509;\n    inverse_kinematics_B.xi[52] = 1.00325667954467;\n    inverse_kinematics_B.xi[53] = 1.01129241744;\n    inverse_kinematics_B.xi[54] = 1.01926671746548;\n    inverse_kinematics_B.xi[55] = 1.02718196603564;\n    inverse_kinematics_B.xi[56] = 1.03504043983344;\n    inverse_kinematics_B.xi[57] = 1.04284431314415;\n    inverse_kinematics_B.xi[58] = 1.05059566459093;\n    inverse_kinematics_B.xi[59] = 1.05829648333067;\n    inverse_kinematics_B.xi[60] = 1.06594867476212;\n    inverse_kinematics_B.xi[61] = 1.07355406579244;\n    inverse_kinematics_B.xi[62] = 1.0811144097034;\n    inverse_kinematics_B.xi[63] = 1.08863139065398;\n    inverse_kinematics_B.xi[64] = 1.09610662785202;\n    inverse_kinematics_B.xi[65] = 1.10354167942464;\n    inverse_kinematics_B.xi[66] = 1.11093804601357;\n    inverse_kinematics_B.xi[67] = 1.11829717411934;\n    inverse_kinematics_B.xi[68] = 1.12562045921553;\n    inverse_kinematics_B.xi[69] = 1.13290924865253;\n    inverse_kinematics_B.xi[70] = 1.14016484436815;\n    inverse_kinematics_B.xi[71] = 1.14738850542085;\n    inverse_kinematics_B.xi[72] = 1.15458145035993;\n    inverse_kinematics_B.xi[73] = 1.16174485944561;\n    inverse_kinematics_B.xi[74] = 1.16887987673083;\n    inverse_kinematics_B.xi[75] = 1.17598761201545;\n    inverse_kinematics_B.xi[76] = 1.18306914268269;\n    inverse_kinematics_B.xi[77] = 1.19012551542669;\n    inverse_kinematics_B.xi[78] = 1.19715774787944;\n    inverse_kinematics_B.xi[79] = 1.20416683014438;\n    inverse_kinematics_B.xi[80] = 1.2111537262437;\n    inverse_kinematics_B.xi[81] = 1.21811937548548;\n    inverse_kinematics_B.xi[82] = 1.22506469375653;\n    inverse_kinematics_B.xi[83] = 1.23199057474614;\n    inverse_kinematics_B.xi[84] = 1.23889789110569;\n    inverse_kinematics_B.xi[85] = 1.24578749554863;\n    inverse_kinematics_B.xi[86] = 1.2526602218949;\n    inverse_kinematics_B.xi[87] = 1.25951688606371;\n    inverse_kinematics_B.xi[88] = 1.26635828701823;\n    inverse_kinematics_B.xi[89] = 1.27318520766536;\n    inverse_kinematics_B.xi[90] = 1.27999841571382;\n    inverse_kinematics_B.xi[91] = 1.28679866449324;\n    inverse_kinematics_B.xi[92] = 1.29358669373695;\n    inverse_kinematics_B.xi[93] = 1.30036323033084;\n    inverse_kinematics_B.xi[94] = 1.30712898903073;\n    inverse_kinematics_B.xi[95] = 1.31388467315022;\n    inverse_kinematics_B.xi[96] = 1.32063097522106;\n    inverse_kinematics_B.xi[97] = 1.32736857762793;\n    inverse_kinematics_B.xi[98] = 1.33409815321936;\n    inverse_kinematics_B.xi[99] = 1.3408203658964;\n    inverse_kinematics_B.xi[100] = 1.34753587118059;\n    inverse_kinematics_B.xi[101] = 1.35424531676263;\n    inverse_kinematics_B.xi[102] = 1.36094934303328;\n    inverse_kinematics_B.xi[103] = 1.36764858359748;\n    inverse_kinematics_B.xi[104] = 1.37434366577317;\n    inverse_kinematics_B.xi[105] = 1.38103521107586;\n    inverse_kinematics_B.xi[106] = 1.38772383568998;\n    inverse_kinematics_B.xi[107] = 1.39441015092814;\n    inverse_kinematics_B.xi[108] = 1.40109476367925;\n    inverse_kinematics_B.xi[109] = 1.4077782768464;\n    inverse_kinematics_B.xi[110] = 1.41446128977547;\n    inverse_kinematics_B.xi[111] = 1.42114439867531;\n    inverse_kinematics_B.xi[112] = 1.42782819703026;\n    inverse_kinematics_B.xi[113] = 1.43451327600589;\n    inverse_kinematics_B.xi[114] = 1.44120022484872;\n    inverse_kinematics_B.xi[115] = 1.44788963128058;\n    inverse_kinematics_B.xi[116] = 1.45458208188841;\n    inverse_kinematics_B.xi[117] = 1.46127816251028;\n    inverse_kinematics_B.xi[118] = 1.46797845861808;\n    inverse_kinematics_B.xi[119] = 1.47468355569786;\n    inverse_kinematics_B.xi[120] = 1.48139403962819;\n    inverse_kinematics_B.xi[121] = 1.48811049705745;\n    inverse_kinematics_B.xi[122] = 1.49483351578049;\n    inverse_kinematics_B.xi[123] = 1.50156368511546;\n    inverse_kinematics_B.xi[124] = 1.50830159628131;\n    inverse_kinematics_B.xi[125] = 1.51504784277671;\n    inverse_kinematics_B.xi[126] = 1.521803020761;\n    inverse_kinematics_B.xi[127] = 1.52856772943771;\n    inverse_kinematics_B.xi[128] = 1.53534257144151;\n    inverse_kinematics_B.xi[129] = 1.542128153229;\n    inverse_kinematics_B.xi[130] = 1.54892508547417;\n    inverse_kinematics_B.xi[131] = 1.55573398346918;\n    inverse_kinematics_B.xi[132] = 1.56255546753104;\n    inverse_kinematics_B.xi[133] = 1.56939016341512;\n    inverse_kinematics_B.xi[134] = 1.57623870273591;\n    inverse_kinematics_B.xi[135] = 1.58310172339603;\n    inverse_kinematics_B.xi[136] = 1.58997987002419;\n    inverse_kinematics_B.xi[137] = 1.59687379442279;\n    inverse_kinematics_B.xi[138] = 1.60378415602609;\n    inverse_kinematics_B.xi[139] = 1.61071162236983;\n    inverse_kinematics_B.xi[140] = 1.61765686957301;\n    inverse_kinematics_B.xi[141] = 1.62462058283303;\n    inverse_kinematics_B.xi[142] = 1.63160345693487;\n    inverse_kinematics_B.xi[143] = 1.63860619677555;\n    inverse_kinematics_B.xi[144] = 1.64562951790478;\n    inverse_kinematics_B.xi[145] = 1.65267414708306;\n    inverse_kinematics_B.xi[146] = 1.65974082285818;\n    inverse_kinematics_B.xi[147] = 1.66683029616166;\n    inverse_kinematics_B.xi[148] = 1.67394333092612;\n    inverse_kinematics_B.xi[149] = 1.68108070472517;\n    inverse_kinematics_B.xi[150] = 1.68824320943719;\n    inverse_kinematics_B.xi[151] = 1.69543165193456;\n    inverse_kinematics_B.xi[152] = 1.70264685479992;\n    inverse_kinematics_B.xi[153] = 1.7098896570713;\n    inverse_kinematics_B.xi[154] = 1.71716091501782;\n    inverse_kinematics_B.xi[155] = 1.72446150294804;\n    inverse_kinematics_B.xi[156] = 1.73179231405296;\n    inverse_kinematics_B.xi[157] = 1.73915426128591;\n    inverse_kinematics_B.xi[158] = 1.74654827828172;\n    inverse_kinematics_B.xi[159] = 1.75397532031767;\n    inverse_kinematics_B.xi[160] = 1.76143636531891;\n    inverse_kinematics_B.xi[161] = 1.76893241491127;\n    inverse_kinematics_B.xi[162] = 1.77646449552452;\n    inverse_kinematics_B.xi[163] = 1.78403365954944;\n    inverse_kinematics_B.xi[164] = 1.79164098655216;\n    inverse_kinematics_B.xi[165] = 1.79928758454972;\n    inverse_kinematics_B.xi[166] = 1.80697459135082;\n    inverse_kinematics_B.xi[167] = 1.81470317596628;\n    inverse_kinematics_B.xi[168] = 1.82247454009388;\n    inverse_kinematics_B.xi[169] = 1.83028991968276;\n    inverse_kinematics_B.xi[170] = 1.83815058658281;\n    inverse_kinematics_B.xi[171] = 1.84605785028518;\n    inverse_kinematics_B.xi[172] = 1.8540130597602;\n    inverse_kinematics_B.xi[173] = 1.86201760539967;\n    inverse_kinematics_B.xi[174] = 1.87007292107127;\n    inverse_kinematics_B.xi[175] = 1.878180486293;\n    inverse_kinematics_B.xi[176] = 1.88634182853678;\n    inverse_kinematics_B.xi[177] = 1.8945585256707;\n    inverse_kinematics_B.xi[178] = 1.90283220855043;\n    inverse_kinematics_B.xi[179] = 1.91116456377125;\n    inverse_kinematics_B.xi[180] = 1.91955733659319;\n    inverse_kinematics_B.xi[181] = 1.92801233405266;\n    inverse_kinematics_B.xi[182] = 1.93653142827569;\n    inverse_kinematics_B.xi[183] = 1.94511656000868;\n    inverse_kinematics_B.xi[184] = 1.95376974238465;\n    inverse_kinematics_B.xi[185] = 1.96249306494436;\n    inverse_kinematics_B.xi[186] = 1.97128869793366;\n    inverse_kinematics_B.xi[187] = 1.98015889690048;\n    inverse_kinematics_B.xi[188] = 1.98910600761744;\n    inverse_kinematics_B.xi[189] = 1.99813247135842;\n    inverse_kinematics_B.xi[190] = 2.00724083056053;\n    inverse_kinematics_B.xi[191] = 2.0164337349062;\n    inverse_kinematics_B.xi[192] = 2.02571394786385;\n    inverse_kinematics_B.xi[193] = 2.03508435372962;\n    inverse_kinematics_B.xi[194] = 2.04454796521753;\n    inverse_kinematics_B.xi[195] = 2.05410793165065;\n    inverse_kinematics_B.xi[196] = 2.06376754781173;\n    inverse_kinematics_B.xi[197] = 2.07353026351874;\n    inverse_kinematics_B.xi[198] = 2.0833996939983;\n    inverse_kinematics_B.xi[199] = 2.09337963113879;\n    inverse_kinematics_B.xi[200] = 2.10347405571488;\n    inverse_kinematics_B.xi[201] = 2.11368715068665;\n    inverse_kinematics_B.xi[202] = 2.12402331568952;\n    inverse_kinematics_B.xi[203] = 2.13448718284602;\n    inverse_kinematics_B.xi[204] = 2.14508363404789;\n    inverse_kinematics_B.xi[205] = 2.15581781987674;\n    inverse_kinematics_B.xi[206] = 2.16669518035431;\n    inverse_kinematics_B.xi[207] = 2.17772146774029;\n    inverse_kinematics_B.xi[208] = 2.18890277162636;\n    inverse_kinematics_B.xi[209] = 2.20024554661128;\n    inverse_kinematics_B.xi[210] = 2.21175664288416;\n    inverse_kinematics_B.xi[211] = 2.22344334009251;\n    inverse_kinematics_B.xi[212] = 2.23531338492992;\n    inverse_kinematics_B.xi[213] = 2.24737503294739;\n    inverse_kinematics_B.xi[214] = 2.25963709517379;\n    inverse_kinematics_B.xi[215] = 2.27210899022838;\n    inverse_kinematics_B.xi[216] = 2.28480080272449;\n    inverse_kinematics_B.xi[217] = 2.29772334890286;\n    inverse_kinematics_B.xi[218] = 2.31088825060137;\n    inverse_kinematics_B.xi[219] = 2.32430801887113;\n    inverse_kinematics_B.xi[220] = 2.33799614879653;\n    inverse_kinematics_B.xi[221] = 2.35196722737914;\n    inverse_kinematics_B.xi[222] = 2.36623705671729;\n    inverse_kinematics_B.xi[223] = 2.38082279517208;\n    inverse_kinematics_B.xi[224] = 2.39574311978193;\n    inverse_kinematics_B.xi[225] = 2.41101841390112;\n    inverse_kinematics_B.xi[226] = 2.42667098493715;\n    inverse_kinematics_B.xi[227] = 2.44272531820036;\n    inverse_kinematics_B.xi[228] = 2.4592083743347;\n    inverse_kinematics_B.xi[229] = 2.47614993967052;\n    inverse_kinematics_B.xi[230] = 2.49358304127105;\n    inverse_kinematics_B.xi[231] = 2.51154444162669;\n    inverse_kinematics_B.xi[232] = 2.53007523215985;\n    inverse_kinematics_B.xi[233] = 2.54922155032478;\n    inverse_kinematics_B.xi[234] = 2.56903545268184;\n    inverse_kinematics_B.xi[235] = 2.58957598670829;\n    inverse_kinematics_B.xi[236] = 2.61091051848882;\n    inverse_kinematics_B.xi[237] = 2.63311639363158;\n    inverse_kinematics_B.xi[238] = 2.65628303757674;\n    inverse_kinematics_B.xi[239] = 2.68051464328574;\n    inverse_kinematics_B.xi[240] = 2.70593365612306;\n    inverse_kinematics_B.xi[241] = 2.73268535904401;\n    inverse_kinematics_B.xi[242] = 2.76094400527999;\n    inverse_kinematics_B.xi[243] = 2.79092117400193;\n    inverse_kinematics_B.xi[244] = 2.82287739682644;\n    inverse_kinematics_B.xi[245] = 2.85713873087322;\n    inverse_kinematics_B.xi[246] = 2.89412105361341;\n    inverse_kinematics_B.xi[247] = 2.93436686720889;\n    inverse_kinematics_B.xi[248] = 2.97860327988184;\n    inverse_kinematics_B.xi[249] = 3.02783779176959;\n    inverse_kinematics_B.xi[250] = 3.08352613200214;\n    inverse_kinematics_B.xi[251] = 3.147889289518;\n    inverse_kinematics_B.xi[252] = 3.2245750520478;\n    inverse_kinematics_B.xi[253] = 3.32024473383983;\n    inverse_kinematics_B.xi[254] = 3.44927829856143;\n    inverse_kinematics_B.xi[255] = 3.65415288536101;\n    inverse_kinematics_B.xi[256] = 3.91075795952492;\n    fitab = &tmp[0];\n  }\n\n  for (inverse_kinematics_B.b_k_e = 0; inverse_kinematics_B.b_k_e <=\n       inverse_kinematics_B.d_tmp; inverse_kinematics_B.b_k_e++) {\n    int32_T exitg1;\n    do {\n      exitg1 = 0;\n      inverse_genrand_uint32_vector_g(inverse_kinematics_DW.state_c,\n        inverse_kinematics_B.u32);\n      inverse_kinematics_B.i_o = static_cast<int32_T>((inverse_kinematics_B.u32\n        [1] >> 24U) + 1U);\n      inverse_kinematics_B.b_r = ((static_cast<real_T>(inverse_kinematics_B.u32\n        [0] >> 3U) * 1.6777216E+7 + static_cast<real_T>(static_cast<int32_T>\n        (inverse_kinematics_B.u32[1]) & 16777215)) * 2.2204460492503131E-16 -\n        1.0) * inverse_kinematics_B.xi[inverse_kinematics_B.i_o];\n      if (fabs(inverse_kinematics_B.b_r) <=\n          inverse_kinematics_B.xi[inverse_kinematics_B.i_o - 1]) {\n        exitg1 = 1;\n      } else if (inverse_kinematics_B.i_o < 256) {\n        /* ========================= COPYRIGHT NOTICE ============================ */\n        /*  This is a uniform (0,1) pseudorandom number generator based on:        */\n        /*                                                                         */\n        /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\n        /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\n        /*                                                                         */\n        /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\n        /*  All rights reserved.                                                   */\n        /*                                                                         */\n        /*  Redistribution and use in source and binary forms, with or without     */\n        /*  modification, are permitted provided that the following conditions     */\n        /*  are met:                                                               */\n        /*                                                                         */\n        /*    1. Redistributions of source code must retain the above copyright    */\n        /*       notice, this list of conditions and the following disclaimer.     */\n        /*                                                                         */\n        /*    2. Redistributions in binary form must reproduce the above copyright */\n        /*       notice, this list of conditions and the following disclaimer      */\n        /*       in the documentation and/or other materials provided with the     */\n        /*       distribution.                                                     */\n        /*                                                                         */\n        /*    3. The names of its contributors may not be used to endorse or       */\n        /*       promote products derived from this software without specific      */\n        /*       prior written permission.                                         */\n        /*                                                                         */\n        /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\n        /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\n        /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\n        /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\n        /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\n        /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\n        /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\n        /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\n        /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\n        /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\n        /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n        /*                                                                         */\n        /* =============================   END   ================================= */\n        int32_T exitg2;\n        do {\n          exitg2 = 0;\n          inverse_genrand_uint32_vector_g(inverse_kinematics_DW.state_c,\n            inverse_kinematics_B.u32);\n          inverse_kinematics_B.x = (static_cast<real_T>\n            (inverse_kinematics_B.u32[0] >> 5U) * 6.7108864E+7 +\n            static_cast<real_T>(inverse_kinematics_B.u32[1] >> 6U)) *\n            1.1102230246251565E-16;\n          if (inverse_kinematics_B.x == 0.0) {\n            if (!inverse_kinemati_is_valid_state(inverse_kinematics_DW.state_c))\n            {\n              inverse_kinematics_DW.state_c[0] = 5489U;\n              inverse_kinematics_DW.state_c[624] = 624U;\n            }\n          } else {\n            exitg2 = 1;\n          }\n        } while (exitg2 == 0);\n\n        if ((fitab[inverse_kinematics_B.i_o - 1] -\n             fitab[inverse_kinematics_B.i_o]) * inverse_kinematics_B.x +\n            fitab[inverse_kinematics_B.i_o] < exp(-0.5 *\n             inverse_kinematics_B.b_r * inverse_kinematics_B.b_r)) {\n          exitg1 = 1;\n        }\n      } else {\n        do {\n          int32_T exitg2;\n\n          /* ========================= COPYRIGHT NOTICE ============================ */\n          /*  This is a uniform (0,1) pseudorandom number generator based on:        */\n          /*                                                                         */\n          /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\n          /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\n          /*                                                                         */\n          /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\n          /*  All rights reserved.                                                   */\n          /*                                                                         */\n          /*  Redistribution and use in source and binary forms, with or without     */\n          /*  modification, are permitted provided that the following conditions     */\n          /*  are met:                                                               */\n          /*                                                                         */\n          /*    1. Redistributions of source code must retain the above copyright    */\n          /*       notice, this list of conditions and the following disclaimer.     */\n          /*                                                                         */\n          /*    2. Redistributions in binary form must reproduce the above copyright */\n          /*       notice, this list of conditions and the following disclaimer      */\n          /*       in the documentation and/or other materials provided with the     */\n          /*       distribution.                                                     */\n          /*                                                                         */\n          /*    3. The names of its contributors may not be used to endorse or       */\n          /*       promote products derived from this software without specific      */\n          /*       prior written permission.                                         */\n          /*                                                                         */\n          /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\n          /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\n          /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\n          /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\n          /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\n          /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\n          /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\n          /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\n          /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\n          /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\n          /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n          /*                                                                         */\n          /* =============================   END   ================================= */\n          do {\n            exitg2 = 0;\n            inverse_genrand_uint32_vector_g(inverse_kinematics_DW.state_c,\n              inverse_kinematics_B.u32);\n            inverse_kinematics_B.x = (static_cast<real_T>\n              (inverse_kinematics_B.u32[0] >> 5U) * 6.7108864E+7 +\n              static_cast<real_T>(inverse_kinematics_B.u32[1] >> 6U)) *\n              1.1102230246251565E-16;\n            if (inverse_kinematics_B.x == 0.0) {\n              if (!inverse_kinemati_is_valid_state(inverse_kinematics_DW.state_c))\n              {\n                inverse_kinematics_DW.state_c[0] = 5489U;\n                inverse_kinematics_DW.state_c[624] = 624U;\n              }\n            } else {\n              exitg2 = 1;\n            }\n          } while (exitg2 == 0);\n\n          inverse_kinematics_B.x = log(inverse_kinematics_B.x) *\n            0.273661237329758;\n\n          /* ========================= COPYRIGHT NOTICE ============================ */\n          /*  This is a uniform (0,1) pseudorandom number generator based on:        */\n          /*                                                                         */\n          /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\n          /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\n          /*                                                                         */\n          /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\n          /*  All rights reserved.                                                   */\n          /*                                                                         */\n          /*  Redistribution and use in source and binary forms, with or without     */\n          /*  modification, are permitted provided that the following conditions     */\n          /*  are met:                                                               */\n          /*                                                                         */\n          /*    1. Redistributions of source code must retain the above copyright    */\n          /*       notice, this list of conditions and the following disclaimer.     */\n          /*                                                                         */\n          /*    2. Redistributions in binary form must reproduce the above copyright */\n          /*       notice, this list of conditions and the following disclaimer      */\n          /*       in the documentation and/or other materials provided with the     */\n          /*       distribution.                                                     */\n          /*                                                                         */\n          /*    3. The names of its contributors may not be used to endorse or       */\n          /*       promote products derived from this software without specific      */\n          /*       prior written permission.                                         */\n          /*                                                                         */\n          /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\n          /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\n          /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\n          /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\n          /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\n          /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\n          /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\n          /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\n          /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\n          /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\n          /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n          /*                                                                         */\n          /* =============================   END   ================================= */\n          do {\n            exitg2 = 0;\n            inverse_genrand_uint32_vector_g(inverse_kinematics_DW.state_c,\n              inverse_kinematics_B.u32);\n            inverse_kinematics_B.d_u = (static_cast<real_T>\n              (inverse_kinematics_B.u32[0] >> 5U) * 6.7108864E+7 +\n              static_cast<real_T>(inverse_kinematics_B.u32[1] >> 6U)) *\n              1.1102230246251565E-16;\n            if (inverse_kinematics_B.d_u == 0.0) {\n              if (!inverse_kinemati_is_valid_state(inverse_kinematics_DW.state_c))\n              {\n                inverse_kinematics_DW.state_c[0] = 5489U;\n                inverse_kinematics_DW.state_c[624] = 624U;\n              }\n            } else {\n              exitg2 = 1;\n            }\n          } while (exitg2 == 0);\n        } while (!(-2.0 * log(inverse_kinematics_B.d_u) > inverse_kinematics_B.x\n                   * inverse_kinematics_B.x));\n\n        if (inverse_kinematics_B.b_r < 0.0) {\n          inverse_kinematics_B.b_r = inverse_kinematics_B.x - 3.65415288536101;\n        } else {\n          inverse_kinematics_B.b_r = 3.65415288536101 - inverse_kinematics_B.x;\n        }\n\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n\n    r->data[inverse_kinematics_B.b_k_e] = inverse_kinematics_B.b_r;\n  }\n}\n\nstatic void inverse_kinematics_minus(emxArray_real_T_inverse_kinem_T *in1, const\n  emxArray_real_T_inverse_kinem_T *in2)\n{\n  emxArray_real_T_inverse_kinem_T *in1_0;\n  int32_T i;\n  int32_T loop_ub;\n  int32_T stride_0_0;\n  int32_T stride_1_0;\n  inverse_kinemati_emxInit_real_T(&in1_0, 1);\n  i = in1_0->size[0];\n  in1_0->size[0] = in2->size[0] == 1 ? in1->size[0] : in2->size[0];\n  invers_emxEnsureCapacity_real_T(in1_0, i);\n  stride_0_0 = (in1->size[0] != 1);\n  stride_1_0 = (in2->size[0] != 1);\n  loop_ub = in2->size[0] == 1 ? in1->size[0] : in2->size[0];\n  for (i = 0; i < loop_ub; i++) {\n    in1_0->data[i] = in1->data[i * stride_0_0] - in2->data[i * stride_1_0];\n  }\n\n  i = in1->size[0];\n  in1->size[0] = in1_0->size[0];\n  invers_emxEnsureCapacity_real_T(in1, i);\n  loop_ub = in1_0->size[0];\n  if (loop_ub - 1 >= 0) {\n    memcpy(&in1->data[0], &in1_0->data[0], loop_ub * sizeof(real_T));\n  }\n\n  inverse_kinemati_emxFree_real_T(&in1_0);\n}\n\nstatic void inverse_kinematics_plus(emxArray_real_T_inverse_kinem_T *in1, const\n  emxArray_real_T_inverse_kinem_T *in2)\n{\n  emxArray_real_T_inverse_kinem_T *in2_0;\n  int32_T i;\n  int32_T loop_ub;\n  int32_T stride_0_0;\n  int32_T stride_1_0;\n  inverse_kinemati_emxInit_real_T(&in2_0, 1);\n  i = in2_0->size[0];\n  in2_0->size[0] = in1->size[0] == 1 ? in2->size[0] : in1->size[0];\n  invers_emxEnsureCapacity_real_T(in2_0, i);\n  stride_0_0 = (in2->size[0] != 1);\n  stride_1_0 = (in1->size[0] != 1);\n  loop_ub = in1->size[0] == 1 ? in2->size[0] : in1->size[0];\n  for (i = 0; i < loop_ub; i++) {\n    in2_0->data[i] = in2->data[i * stride_0_0] + in1->data[i * stride_1_0];\n  }\n\n  i = in1->size[0];\n  in1->size[0] = in2_0->size[0];\n  invers_emxEnsureCapacity_real_T(in1, i);\n  loop_ub = in2_0->size[0];\n  if (loop_ub - 1 >= 0) {\n    memcpy(&in1->data[0], &in2_0->data[0], loop_ub * sizeof(real_T));\n  }\n\n  inverse_kinemati_emxFree_real_T(&in2_0);\n}\n\nstatic void inverse_kinematics_rand_g(real_T varargin_1,\n  emxArray_real_T_inverse_kinem_T *r)\n{\n  int32_T b_k;\n  int32_T d;\n  uint32_T b_u[2];\n  b_k = r->size[0];\n  r->size[0] = static_cast<int32_T>(varargin_1);\n  invers_emxEnsureCapacity_real_T(r, b_k);\n  d = static_cast<int32_T>(varargin_1) - 1;\n  for (b_k = 0; b_k <= d; b_k++) {\n    real_T b_r;\n\n    /* ========================= COPYRIGHT NOTICE ============================ */\n    /*  This is a uniform (0,1) pseudorandom number generator based on:        */\n    /*                                                                         */\n    /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\n    /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\n    /*                                                                         */\n    /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\n    /*  All rights reserved.                                                   */\n    /*                                                                         */\n    /*  Redistribution and use in source and binary forms, with or without     */\n    /*  modification, are permitted provided that the following conditions     */\n    /*  are met:                                                               */\n    /*                                                                         */\n    /*    1. Redistributions of source code must retain the above copyright    */\n    /*       notice, this list of conditions and the following disclaimer.     */\n    /*                                                                         */\n    /*    2. Redistributions in binary form must reproduce the above copyright */\n    /*       notice, this list of conditions and the following disclaimer      */\n    /*       in the documentation and/or other materials provided with the     */\n    /*       distribution.                                                     */\n    /*                                                                         */\n    /*    3. The names of its contributors may not be used to endorse or       */\n    /*       promote products derived from this software without specific      */\n    /*       prior written permission.                                         */\n    /*                                                                         */\n    /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\n    /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\n    /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\n    /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\n    /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\n    /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\n    /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\n    /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\n    /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\n    /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\n    /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n    /*                                                                         */\n    /* =============================   END   ================================= */\n    int32_T exitg1;\n    do {\n      exitg1 = 0;\n      inverse_genrand_uint32_vector_g(inverse_kinematics_DW.state_c, b_u);\n      b_r = (static_cast<real_T>(b_u[0] >> 5U) * 6.7108864E+7 + static_cast<\n             real_T>(b_u[1] >> 6U)) * 1.1102230246251565E-16;\n      if (b_r == 0.0) {\n        if (!inverse_kinemati_is_valid_state(inverse_kinematics_DW.state_c)) {\n          inverse_kinematics_DW.state_c[0] = 5489U;\n          inverse_kinematics_DW.state_c[624] = 624U;\n        }\n      } else {\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n\n    r->data[b_k] = b_r;\n  }\n}\n\nstatic void inverse_kinema_binary_expand_op(emxArray_real_T_inverse_kinem_T *in1,\n  const emxArray_real_T_inverse_kinem_T *in2, const\n  emxArray_real_T_inverse_kinem_T *in3)\n{\n  emxArray_real_T_inverse_kinem_T *in2_0;\n  int32_T i;\n  int32_T loop_ub;\n  int32_T stride_0_0;\n  int32_T stride_1_0;\n  int32_T stride_2_0;\n  int32_T stride_3_0;\n  inverse_kinemati_emxInit_real_T(&in2_0, 1);\n  i = in2_0->size[0];\n  in2_0->size[0] = ((in2->size[0] == 1 ? in1->size[0] : in2->size[0]) == 1 ?\n                    in3->size[0] : in2->size[0] == 1 ? in1->size[0] : in2->size\n                    [0]) == 1 ? in2->size[0] : (in2->size[0] == 1 ? in1->size[0]\n    : in2->size[0]) == 1 ? in3->size[0] : in2->size[0] == 1 ? in1->size[0] :\n    in2->size[0];\n  invers_emxEnsureCapacity_real_T(in2_0, i);\n  stride_0_0 = (in2->size[0] != 1);\n  stride_1_0 = (in3->size[0] != 1);\n  stride_2_0 = (in1->size[0] != 1);\n  stride_3_0 = (in2->size[0] != 1);\n  loop_ub = ((in2->size[0] == 1 ? in1->size[0] : in2->size[0]) == 1 ? in3->size\n             [0] : in2->size[0] == 1 ? in1->size[0] : in2->size[0]) == 1 ?\n    in2->size[0] : (in2->size[0] == 1 ? in1->size[0] : in2->size[0]) == 1 ?\n    in3->size[0] : in2->size[0] == 1 ? in1->size[0] : in2->size[0];\n  for (i = 0; i < loop_ub; i++) {\n    in2_0->data[i] = (in1->data[i * stride_2_0] - in2->data[i * stride_3_0]) *\n      in3->data[i * stride_1_0] + in2->data[i * stride_0_0];\n  }\n\n  i = in1->size[0];\n  in1->size[0] = in2_0->size[0];\n  invers_emxEnsureCapacity_real_T(in1, i);\n  loop_ub = in2_0->size[0];\n  if (loop_ub - 1 >= 0) {\n    memcpy(&in1->data[0], &in2_0->data[0], loop_ub * sizeof(real_T));\n  }\n\n  inverse_kinemati_emxFree_real_T(&in2_0);\n}\n\nstatic void invers_NLPSolverInterface_solve(h_robotics_core_internal_Erro_T *obj,\n  const real_T seed[4], real_T xSol[4], real_T *solutionInfo_Iterations, real_T *\n  solutionInfo_RRAttempts, real_T *solutionInfo_Error, real_T\n  *solutionInfo_ExitFlag, char_T solutionInfo_Status_data[], int32_T\n  solutionInfo_Status_size[2])\n{\n  c_rigidBodyJoint_inverse_kine_T *obj_1;\n  emxArray_boolean_T_inverse_ki_T *b;\n  emxArray_boolean_T_inverse_ki_T *tmp;\n  emxArray_boolean_T_inverse_ki_T *tmp_0;\n  emxArray_real_T_inverse_kinem_T *lb;\n  emxArray_real_T_inverse_kinem_T *newseed;\n  emxArray_real_T_inverse_kinem_T *rn;\n  emxArray_real_T_inverse_kinem_T *ub;\n  f_robotics_manip_internal_IKE_T *args;\n  v_robotics_manip_internal_Rig_T *obj_0;\n  static const char_T tmp_1[14] = { 'b', 'e', 's', 't', ' ', 'a', 'v', 'a', 'i',\n    'l', 'a', 'b', 'l', 'e' };\n\n  static const char_T tmp_2[7] = { 's', 'u', 'c', 'c', 'e', 's', 's' };\n\n  boolean_T exitg1;\n  obj->MaxNumIterationInternal = obj->MaxNumIteration;\n  obj->MaxTimeInternal = obj->MaxTime;\n  obj->SeedInternal[0] = seed[0];\n  obj->SeedInternal[1] = seed[1];\n  obj->SeedInternal[2] = seed[2];\n  obj->SeedInternal[3] = seed[3];\n  inverse_kinematics_B.tol = obj->SolutionTolerance;\n  inverse_kinematics_tic(&obj->TimeObj.StartTime.tv_sec,\n    &obj->TimeObj.StartTime.tv_nsec);\n  ErrorDampedLevenbergMarquardt_s(obj, xSol, &inverse_kinematics_B.exitFlag,\n    &inverse_kinematics_B.err, &inverse_kinematics_B.iter);\n  *solutionInfo_RRAttempts = 0.0;\n  *solutionInfo_Iterations = inverse_kinematics_B.iter;\n  *solutionInfo_Error = inverse_kinematics_B.err;\n  inverse_kinematics_B.exitFlagPrev = inverse_kinematics_B.exitFlag;\n  inverse_kinemati_emxInit_real_T(&newseed, 1);\n  inverse_kinemati_emxInit_real_T(&ub, 1);\n  inverse_kinemati_emxInit_real_T(&lb, 1);\n  inverse_kinemati_emxInit_real_T(&rn, 1);\n  inverse_kinem_emxInit_boolean_T(&b, 1);\n  inverse_kinem_emxInit_boolean_T(&tmp, 1);\n  inverse_kinem_emxInit_boolean_T(&tmp_0, 1);\n  exitg1 = false;\n  while ((!exitg1) && (obj->RandomRestart && (inverse_kinematics_B.err >\n           inverse_kinematics_B.tol))) {\n    obj->MaxNumIterationInternal -= inverse_kinematics_B.iter;\n    inverse_kinematics_B.err = inverse_kinematics_toc\n      (obj->TimeObj.StartTime.tv_sec, obj->TimeObj.StartTime.tv_nsec);\n    obj->MaxTimeInternal = obj->MaxTime - inverse_kinematics_B.err;\n    if (obj->MaxNumIterationInternal <= 0.0) {\n      inverse_kinematics_B.exitFlag = IterationLimitExceeded;\n    }\n\n    if ((inverse_kinematics_B.exitFlag == IterationLimitExceeded) ||\n        (inverse_kinematics_B.exitFlag == TimeLimitExceeded)) {\n      inverse_kinematics_B.exitFlagPrev = inverse_kinematics_B.exitFlag;\n      exitg1 = true;\n    } else {\n      args = obj->ExtraArgs;\n      obj_0 = args->Robot;\n      inverse_kinematics_B.ix = newseed->size[0];\n      newseed->size[0] = static_cast<int32_T>(obj_0->PositionNumber);\n      invers_emxEnsureCapacity_real_T(newseed, inverse_kinematics_B.ix);\n      inverse_kinematics_B.nx = static_cast<int32_T>(obj_0->PositionNumber);\n      if (inverse_kinematics_B.nx - 1 >= 0) {\n        memset(&newseed->data[0], 0, inverse_kinematics_B.nx * sizeof(real_T));\n      }\n\n      inverse_kinematics_B.err = obj_0->NumBodies;\n      inverse_kinematics_B.c_f = static_cast<int32_T>(inverse_kinematics_B.err)\n        - 1;\n      for (inverse_kinematics_B.b_i = 0; inverse_kinematics_B.b_i <=\n           inverse_kinematics_B.c_f; inverse_kinematics_B.b_i++) {\n        inverse_kinematics_B.err = obj_0->\n          PositionDoFMap[inverse_kinematics_B.b_i];\n        inverse_kinematics_B.iter = obj_0->\n          PositionDoFMap[inverse_kinematics_B.b_i + 6];\n        if (inverse_kinematics_B.err <= inverse_kinematics_B.iter) {\n          obj_1 = obj_0->Bodies[inverse_kinematics_B.b_i]->JointInternal;\n          if (static_cast<int32_T>(obj_1->PositionNumber) == 0) {\n            inverse_kinematics_B.ix = ub->size[0];\n            ub->size[0] = 1;\n            invers_emxEnsureCapacity_real_T(ub, inverse_kinematics_B.ix);\n            ub->data[0] = (rtNaN);\n          } else {\n            boolean_T exitg2;\n            boolean_T guard1 = false;\n            boolean_T guard2 = false;\n            boolean_T guard3 = false;\n            inverse_kinematics_B.nx = obj_1->PositionLimitsInternal->size[0];\n            inverse_kinematics_B.ix = ub->size[0];\n            ub->size[0] = inverse_kinematics_B.nx;\n            invers_emxEnsureCapacity_real_T(ub, inverse_kinematics_B.ix);\n            for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                 inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n              ub->data[inverse_kinematics_B.ix] = obj_1->\n                PositionLimitsInternal->data[inverse_kinematics_B.ix +\n                obj_1->PositionLimitsInternal->size[0]];\n            }\n\n            inverse_kinematics_B.nx = obj_1->PositionLimitsInternal->size[0];\n            inverse_kinematics_B.ix = lb->size[0];\n            lb->size[0] = inverse_kinematics_B.nx;\n            invers_emxEnsureCapacity_real_T(lb, inverse_kinematics_B.ix);\n            for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                 inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n              lb->data[inverse_kinematics_B.ix] = obj_1->\n                PositionLimitsInternal->data[inverse_kinematics_B.ix];\n            }\n\n            inverse_kinematics_B.ix = b->size[0];\n            b->size[0] = lb->size[0];\n            inv_emxEnsureCapacity_boolean_T(b, inverse_kinematics_B.ix);\n            inverse_kinematics_B.nx = lb->size[0];\n            for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                 inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n              b->data[inverse_kinematics_B.ix] = rtIsInf(lb->\n                data[inverse_kinematics_B.ix]);\n            }\n\n            inverse_kinematics_B.ix = tmp->size[0];\n            tmp->size[0] = lb->size[0];\n            inv_emxEnsureCapacity_boolean_T(tmp, inverse_kinematics_B.ix);\n            inverse_kinematics_B.nx = lb->size[0];\n            for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                 inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n              tmp->data[inverse_kinematics_B.ix] = rtIsNaN(lb->\n                data[inverse_kinematics_B.ix]);\n            }\n\n            inverse_kinematics_B.nx = b->size[0];\n            for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                 inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n              b->data[inverse_kinematics_B.ix] = ((!b->\n                data[inverse_kinematics_B.ix]) && (!tmp->\n                data[inverse_kinematics_B.ix]));\n            }\n\n            inverse_kinematics_B.y_c = true;\n            inverse_kinematics_B.ix = 0;\n            exitg2 = false;\n            while ((!exitg2) && (inverse_kinematics_B.ix + 1 <= b->size[0])) {\n              if (!b->data[inverse_kinematics_B.ix]) {\n                inverse_kinematics_B.y_c = false;\n                exitg2 = true;\n              } else {\n                inverse_kinematics_B.ix++;\n              }\n            }\n\n            guard1 = false;\n            guard2 = false;\n            guard3 = false;\n            if (inverse_kinematics_B.y_c) {\n              inverse_kinematics_B.ix = b->size[0];\n              b->size[0] = ub->size[0];\n              inv_emxEnsureCapacity_boolean_T(b, inverse_kinematics_B.ix);\n              inverse_kinematics_B.nx = ub->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                b->data[inverse_kinematics_B.ix] = rtIsInf(ub->\n                  data[inverse_kinematics_B.ix]);\n              }\n\n              inverse_kinematics_B.ix = tmp->size[0];\n              tmp->size[0] = ub->size[0];\n              inv_emxEnsureCapacity_boolean_T(tmp, inverse_kinematics_B.ix);\n              inverse_kinematics_B.nx = ub->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                tmp->data[inverse_kinematics_B.ix] = rtIsNaN(ub->\n                  data[inverse_kinematics_B.ix]);\n              }\n\n              inverse_kinematics_B.nx = b->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                b->data[inverse_kinematics_B.ix] = ((!b->\n                  data[inverse_kinematics_B.ix]) && (!tmp->\n                  data[inverse_kinematics_B.ix]));\n              }\n\n              inverse_kinematics_B.y_c = true;\n              inverse_kinematics_B.ix = 0;\n              exitg2 = false;\n              while ((!exitg2) && (inverse_kinematics_B.ix + 1 <= b->size[0])) {\n                if (!b->data[inverse_kinematics_B.ix]) {\n                  inverse_kinematics_B.y_c = false;\n                  exitg2 = true;\n                } else {\n                  inverse_kinematics_B.ix++;\n                }\n              }\n\n              if (inverse_kinematics_B.y_c) {\n                inverse_kinematics_rand_g(obj_1->PositionNumber, rn);\n                if ((ub->size[0] == lb->size[0]) && ((ub->size[0] == 1 ?\n                      lb->size[0] : ub->size[0]) == rn->size[0]) && ((rn->size[0]\n                      == 1 ? ub->size[0] == 1 ? lb->size[0] : ub->size[0] :\n                      rn->size[0]) == lb->size[0])) {\n                  inverse_kinematics_B.ix = ub->size[0];\n                  ub->size[0] = lb->size[0];\n                  invers_emxEnsureCapacity_real_T(ub, inverse_kinematics_B.ix);\n                  inverse_kinematics_B.nx = lb->size[0];\n                  for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                       inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                    inverse_kinematics_B.lb = lb->data[inverse_kinematics_B.ix];\n                    ub->data[inverse_kinematics_B.ix] = (ub->\n                      data[inverse_kinematics_B.ix] - inverse_kinematics_B.lb) *\n                      rn->data[inverse_kinematics_B.ix] +\n                      inverse_kinematics_B.lb;\n                  }\n                } else {\n                  inverse_kinema_binary_expand_op(ub, lb, rn);\n                }\n              } else {\n                guard3 = true;\n              }\n            } else {\n              guard3 = true;\n            }\n\n            if (guard3) {\n              inverse_kinematics_B.ix = b->size[0];\n              b->size[0] = lb->size[0];\n              inv_emxEnsureCapacity_boolean_T(b, inverse_kinematics_B.ix);\n              inverse_kinematics_B.nx = lb->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                b->data[inverse_kinematics_B.ix] = rtIsInf(lb->\n                  data[inverse_kinematics_B.ix]);\n              }\n\n              inverse_kinematics_B.ix = tmp->size[0];\n              tmp->size[0] = lb->size[0];\n              inv_emxEnsureCapacity_boolean_T(tmp, inverse_kinematics_B.ix);\n              inverse_kinematics_B.nx = lb->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                tmp->data[inverse_kinematics_B.ix] = rtIsNaN(lb->\n                  data[inverse_kinematics_B.ix]);\n              }\n\n              inverse_kinematics_B.nx = b->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                b->data[inverse_kinematics_B.ix] = ((!b->\n                  data[inverse_kinematics_B.ix]) && (!tmp->\n                  data[inverse_kinematics_B.ix]));\n              }\n\n              inverse_kinematics_B.y_c = true;\n              inverse_kinematics_B.ix = 0;\n              exitg2 = false;\n              while ((!exitg2) && (inverse_kinematics_B.ix + 1 <= b->size[0])) {\n                if (!b->data[inverse_kinematics_B.ix]) {\n                  inverse_kinematics_B.y_c = false;\n                  exitg2 = true;\n                } else {\n                  inverse_kinematics_B.ix++;\n                }\n              }\n\n              if (inverse_kinematics_B.y_c) {\n                inverse_kinematics_B.ix = tmp->size[0];\n                tmp->size[0] = ub->size[0];\n                inv_emxEnsureCapacity_boolean_T(tmp, inverse_kinematics_B.ix);\n                inverse_kinematics_B.nx = ub->size[0];\n                for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                     inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                  tmp->data[inverse_kinematics_B.ix] = rtIsInf(ub->\n                    data[inverse_kinematics_B.ix]);\n                }\n\n                inverse_kinematics_B.ix = b->size[0];\n                b->size[0] = ub->size[0];\n                inv_emxEnsureCapacity_boolean_T(b, inverse_kinematics_B.ix);\n                inverse_kinematics_B.nx = ub->size[0];\n                for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                     inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                  b->data[inverse_kinematics_B.ix] = rtIsNaN(ub->\n                    data[inverse_kinematics_B.ix]);\n                }\n\n                inverse_kinematics_B.ix = tmp_0->size[0];\n                tmp_0->size[0] = tmp->size[0];\n                inv_emxEnsureCapacity_boolean_T(tmp_0, inverse_kinematics_B.ix);\n                inverse_kinematics_B.nx = tmp->size[0];\n                for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                     inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                  tmp_0->data[inverse_kinematics_B.ix] = (tmp->\n                    data[inverse_kinematics_B.ix] || b->\n                    data[inverse_kinematics_B.ix]);\n                }\n\n                if (inverse_kinematics_any(tmp_0)) {\n                  inverse_kinematics_B.ub[0] = lb->size[0];\n                  inverse_kinematics_B.ub[1] = 1.0;\n                  inverse_kinematics_randn(inverse_kinematics_B.ub, rn);\n                  inverse_kinematics_B.nx = rn->size[0] - 1;\n                  inverse_kinematics_B.ix = ub->size[0];\n                  ub->size[0] = rn->size[0];\n                  invers_emxEnsureCapacity_real_T(ub, inverse_kinematics_B.ix);\n                  for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <=\n                       inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                    ub->data[inverse_kinematics_B.ix] = fabs(rn->\n                      data[inverse_kinematics_B.ix]);\n                  }\n\n                  if (lb->size[0] == ub->size[0]) {\n                    inverse_kinematics_B.ix = ub->size[0];\n                    ub->size[0] = lb->size[0];\n                    invers_emxEnsureCapacity_real_T(ub, inverse_kinematics_B.ix);\n                    inverse_kinematics_B.nx = lb->size[0];\n                    for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                         inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                      ub->data[inverse_kinematics_B.ix] += lb->\n                        data[inverse_kinematics_B.ix];\n                    }\n                  } else {\n                    inverse_kinematics_plus(ub, lb);\n                  }\n                } else {\n                  guard2 = true;\n                }\n              } else {\n                guard2 = true;\n              }\n            }\n\n            if (guard2) {\n              inverse_kinematics_B.ix = tmp->size[0];\n              tmp->size[0] = lb->size[0];\n              inv_emxEnsureCapacity_boolean_T(tmp, inverse_kinematics_B.ix);\n              inverse_kinematics_B.nx = lb->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                tmp->data[inverse_kinematics_B.ix] = rtIsInf(lb->\n                  data[inverse_kinematics_B.ix]);\n              }\n\n              inverse_kinematics_B.ix = b->size[0];\n              b->size[0] = lb->size[0];\n              inv_emxEnsureCapacity_boolean_T(b, inverse_kinematics_B.ix);\n              inverse_kinematics_B.nx = lb->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                b->data[inverse_kinematics_B.ix] = rtIsNaN(lb->\n                  data[inverse_kinematics_B.ix]);\n              }\n\n              inverse_kinematics_B.ix = tmp_0->size[0];\n              tmp_0->size[0] = tmp->size[0];\n              inv_emxEnsureCapacity_boolean_T(tmp_0, inverse_kinematics_B.ix);\n              inverse_kinematics_B.nx = tmp->size[0];\n              for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                   inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                tmp_0->data[inverse_kinematics_B.ix] = (tmp->\n                  data[inverse_kinematics_B.ix] || b->\n                  data[inverse_kinematics_B.ix]);\n              }\n\n              if (inverse_kinematics_any(tmp_0)) {\n                inverse_kinematics_B.ix = b->size[0];\n                b->size[0] = ub->size[0];\n                inv_emxEnsureCapacity_boolean_T(b, inverse_kinematics_B.ix);\n                inverse_kinematics_B.nx = ub->size[0];\n                for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                     inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                  b->data[inverse_kinematics_B.ix] = rtIsInf(ub->\n                    data[inverse_kinematics_B.ix]);\n                }\n\n                inverse_kinematics_B.ix = tmp->size[0];\n                tmp->size[0] = ub->size[0];\n                inv_emxEnsureCapacity_boolean_T(tmp, inverse_kinematics_B.ix);\n                inverse_kinematics_B.nx = ub->size[0];\n                for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                     inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                  tmp->data[inverse_kinematics_B.ix] = rtIsNaN(ub->\n                    data[inverse_kinematics_B.ix]);\n                }\n\n                inverse_kinematics_B.nx = b->size[0];\n                for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                     inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                  b->data[inverse_kinematics_B.ix] = ((!b->\n                    data[inverse_kinematics_B.ix]) && (!tmp->\n                    data[inverse_kinematics_B.ix]));\n                }\n\n                inverse_kinematics_B.y_c = true;\n                inverse_kinematics_B.ix = 0;\n                exitg2 = false;\n                while ((!exitg2) && (inverse_kinematics_B.ix + 1 <= b->size[0]))\n                {\n                  if (!b->data[inverse_kinematics_B.ix]) {\n                    inverse_kinematics_B.y_c = false;\n                    exitg2 = true;\n                  } else {\n                    inverse_kinematics_B.ix++;\n                  }\n                }\n\n                if (inverse_kinematics_B.y_c) {\n                  inverse_kinematics_B.ub[0] = ub->size[0];\n                  inverse_kinematics_B.ub[1] = 1.0;\n                  inverse_kinematics_randn(inverse_kinematics_B.ub, rn);\n                  inverse_kinematics_B.nx = rn->size[0] - 1;\n                  inverse_kinematics_B.ix = lb->size[0];\n                  lb->size[0] = rn->size[0];\n                  invers_emxEnsureCapacity_real_T(lb, inverse_kinematics_B.ix);\n                  for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <=\n                       inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                    lb->data[inverse_kinematics_B.ix] = fabs(rn->\n                      data[inverse_kinematics_B.ix]);\n                  }\n\n                  if (ub->size[0] == lb->size[0]) {\n                    inverse_kinematics_B.nx = ub->size[0];\n                    for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n                         inverse_kinematics_B.nx; inverse_kinematics_B.ix++) {\n                      ub->data[inverse_kinematics_B.ix] -= lb->\n                        data[inverse_kinematics_B.ix];\n                    }\n                  } else {\n                    inverse_kinematics_minus(ub, lb);\n                  }\n                } else {\n                  guard1 = true;\n                }\n              } else {\n                guard1 = true;\n              }\n            }\n\n            if (guard1) {\n              inverse_kinematics_B.ub[0] = ub->size[0];\n              inverse_kinematics_B.ub[1] = 1.0;\n              inverse_kinematics_randn(inverse_kinematics_B.ub, ub);\n            }\n          }\n\n          if (inverse_kinematics_B.err > inverse_kinematics_B.iter) {\n            inverse_kinematics_B.nx = 0;\n            inverse_kinematics_B.ix = 0;\n          } else {\n            inverse_kinematics_B.nx = static_cast<int32_T>\n              (inverse_kinematics_B.err) - 1;\n            inverse_kinematics_B.ix = static_cast<int32_T>\n              (inverse_kinematics_B.iter);\n          }\n\n          inverse_kinematics_B.unnamed_idx_1 = inverse_kinematics_B.ix -\n            inverse_kinematics_B.nx;\n          for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix <\n               inverse_kinematics_B.unnamed_idx_1; inverse_kinematics_B.ix++) {\n            newseed->data[inverse_kinematics_B.nx + inverse_kinematics_B.ix] =\n              ub->data[inverse_kinematics_B.ix];\n          }\n        }\n      }\n\n      obj->SeedInternal[0] = newseed->data[0];\n      obj->SeedInternal[1] = newseed->data[1];\n      obj->SeedInternal[2] = newseed->data[2];\n      obj->SeedInternal[3] = newseed->data[3];\n      ErrorDampedLevenbergMarquardt_s(obj, inverse_kinematics_B.c_xSol,\n        &inverse_kinematics_B.exitFlag, &inverse_kinematics_B.err,\n        &inverse_kinematics_B.iter);\n      if (inverse_kinematics_B.err < *solutionInfo_Error) {\n        xSol[0] = inverse_kinematics_B.c_xSol[0];\n        xSol[1] = inverse_kinematics_B.c_xSol[1];\n        xSol[2] = inverse_kinematics_B.c_xSol[2];\n        xSol[3] = inverse_kinematics_B.c_xSol[3];\n        *solutionInfo_Error = inverse_kinematics_B.err;\n        inverse_kinematics_B.exitFlagPrev = inverse_kinematics_B.exitFlag;\n      }\n\n      (*solutionInfo_RRAttempts)++;\n      *solutionInfo_Iterations += inverse_kinematics_B.iter;\n    }\n  }\n\n  inverse_kinem_emxFree_boolean_T(&tmp_0);\n  inverse_kinem_emxFree_boolean_T(&tmp);\n  inverse_kinem_emxFree_boolean_T(&b);\n  inverse_kinemati_emxFree_real_T(&rn);\n  inverse_kinemati_emxFree_real_T(&lb);\n  inverse_kinemati_emxFree_real_T(&ub);\n  inverse_kinemati_emxFree_real_T(&newseed);\n  *solutionInfo_ExitFlag = inverse_kinematics_B.exitFlagPrev;\n  if (*solutionInfo_Error < inverse_kinematics_B.tol) {\n    solutionInfo_Status_size[0] = 1;\n    solutionInfo_Status_size[1] = 7;\n    for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix < 7;\n         inverse_kinematics_B.ix++) {\n      solutionInfo_Status_data[inverse_kinematics_B.ix] =\n        tmp_2[inverse_kinematics_B.ix];\n    }\n  } else {\n    solutionInfo_Status_size[0] = 1;\n    solutionInfo_Status_size[1] = 14;\n    for (inverse_kinematics_B.ix = 0; inverse_kinematics_B.ix < 14;\n         inverse_kinematics_B.ix++) {\n      solutionInfo_Status_data[inverse_kinematics_B.ix] =\n        tmp_1[inverse_kinematics_B.ix];\n    }\n  }\n}\n\nstatic void inverse_kinemat_emxInit_int32_T(emxArray_int32_T_inverse_kine_T\n  **pEmxArray, int32_T numDimensions)\n{\n  emxArray_int32_T_inverse_kine_T *emxArray;\n  *pEmxArray = static_cast<emxArray_int32_T_inverse_kine_T *>(malloc(sizeof\n    (emxArray_int32_T_inverse_kine_T)));\n  emxArray = *pEmxArray;\n  emxArray->data = static_cast<int32_T *>(NULL);\n  emxArray->numDimensions = numDimensions;\n  emxArray->size = static_cast<int32_T *>(malloc(sizeof(int32_T) * numDimensions));\n  emxArray->allocatedSize = 0;\n  emxArray->canFreeData = true;\n  for (int32_T i = 0; i < numDimensions; i++) {\n    emxArray->size[i] = 0;\n  }\n}\n\nstatic void inver_emxEnsureCapacity_int32_T(emxArray_int32_T_inverse_kine_T\n  *emxArray, int32_T oldNumel)\n{\n  int32_T i;\n  int32_T newNumel;\n  void *newData;\n  if (oldNumel < 0) {\n    oldNumel = 0;\n  }\n\n  newNumel = 1;\n  for (i = 0; i < emxArray->numDimensions; i++) {\n    newNumel *= emxArray->size[i];\n  }\n\n  if (newNumel > emxArray->allocatedSize) {\n    i = emxArray->allocatedSize;\n    if (i < 16) {\n      i = 16;\n    }\n\n    while (i < newNumel) {\n      if (i > 1073741823) {\n        i = MAX_int32_T;\n      } else {\n        i <<= 1;\n      }\n    }\n\n    newData = calloc(static_cast<uint32_T>(i), sizeof(int32_T));\n    if (emxArray->data != NULL) {\n      memcpy(newData, emxArray->data, sizeof(int32_T) * oldNumel);\n      if (emxArray->canFreeData) {\n        free(emxArray->data);\n      }\n    }\n\n    emxArray->data = static_cast<int32_T *>(newData);\n    emxArray->allocatedSize = i;\n    emxArray->canFreeData = true;\n  }\n}\n\nstatic void inverse_kinemat_emxFree_int32_T(emxArray_int32_T_inverse_kine_T\n  **pEmxArray)\n{\n  if (*pEmxArray != static_cast<emxArray_int32_T_inverse_kine_T *>(NULL)) {\n    if (((*pEmxArray)->data != static_cast<int32_T *>(NULL)) && (*pEmxArray)\n        ->canFreeData) {\n      free((*pEmxArray)->data);\n    }\n\n    free((*pEmxArray)->size);\n    free(*pEmxArray);\n    *pEmxArray = static_cast<emxArray_int32_T_inverse_kine_T *>(NULL);\n  }\n}\n\nstatic void inverse_kinema_emxInit_uint32_T(emxArray_uint32_T_inverse_kin_T\n  **pEmxArray, int32_T numDimensions)\n{\n  emxArray_uint32_T_inverse_kin_T *emxArray;\n  *pEmxArray = static_cast<emxArray_uint32_T_inverse_kin_T *>(malloc(sizeof\n    (emxArray_uint32_T_inverse_kin_T)));\n  emxArray = *pEmxArray;\n  emxArray->data = static_cast<uint32_T *>(NULL);\n  emxArray->numDimensions = numDimensions;\n  emxArray->size = static_cast<int32_T *>(malloc(sizeof(int32_T) * numDimensions));\n  emxArray->allocatedSize = 0;\n  emxArray->canFreeData = true;\n  for (int32_T i = 0; i < numDimensions; i++) {\n    emxArray->size[i] = 0;\n  }\n}\n\nstatic void inve_emxEnsureCapacity_uint32_T(emxArray_uint32_T_inverse_kin_T\n  *emxArray, int32_T oldNumel)\n{\n  int32_T i;\n  int32_T newNumel;\n  void *newData;\n  if (oldNumel < 0) {\n    oldNumel = 0;\n  }\n\n  newNumel = 1;\n  for (i = 0; i < emxArray->numDimensions; i++) {\n    newNumel *= emxArray->size[i];\n  }\n\n  if (newNumel > emxArray->allocatedSize) {\n    i = emxArray->allocatedSize;\n    if (i < 16) {\n      i = 16;\n    }\n\n    while (i < newNumel) {\n      if (i > 1073741823) {\n        i = MAX_int32_T;\n      } else {\n        i <<= 1;\n      }\n    }\n\n    newData = calloc(static_cast<uint32_T>(i), sizeof(uint32_T));\n    if (emxArray->data != NULL) {\n      memcpy(newData, emxArray->data, sizeof(uint32_T) * oldNumel);\n      if (emxArray->canFreeData) {\n        free(emxArray->data);\n      }\n    }\n\n    emxArray->data = static_cast<uint32_T *>(newData);\n    emxArray->allocatedSize = i;\n    emxArray->canFreeData = true;\n  }\n}\n\nstatic void inverse_kinema_emxFree_uint32_T(emxArray_uint32_T_inverse_kin_T\n  **pEmxArray)\n{\n  if (*pEmxArray != static_cast<emxArray_uint32_T_inverse_kin_T *>(NULL)) {\n    if (((*pEmxArray)->data != static_cast<uint32_T *>(NULL)) && (*pEmxArray)\n        ->canFreeData) {\n      free((*pEmxArray)->data);\n    }\n\n    free((*pEmxArray)->size);\n    free(*pEmxArray);\n    *pEmxArray = static_cast<emxArray_uint32_T_inverse_kin_T *>(NULL);\n  }\n}\n\nstatic void inver_inverseKinematics_solve_g(b_inverseKinematics_inverse_k_T *obj,\n  real_T initialGuess[4], real_T *solutionInfo_Iterations, real_T\n  *solutionInfo_NumRandomRestarts, real_T *solutionInfo_PoseErrorNorm, real_T\n  *solutionInfo_ExitFlag, char_T solutionInfo_Status_data[], int32_T\n  solutionInfo_Status_size[2])\n{\n  emxArray_char_T_inverse_kinem_T *endEffectorName;\n  emxArray_int32_T_inverse_kine_T *h;\n  emxArray_real_T_inverse_kinem_T *bodyIndices;\n  emxArray_real_T_inverse_kinem_T *e;\n  emxArray_real_T_inverse_kinem_T *limits;\n  emxArray_real_T_inverse_kinem_T *positionIndices;\n  emxArray_uint32_T_inverse_kin_T *y;\n  t_robotics_manip_internal_Rig_T *body;\n  v_robotics_manip_internal_Rig_T *obj_0;\n  boolean_T exitg1;\n  boolean_T guard1 = false;\n  inverse_kinemati_emxInit_real_T(&limits, 2);\n  obj_0 = obj->RigidBodyTreeInternal;\n  RigidBodyTree_get_JointPosition(obj_0, limits);\n  if (limits->size[0] == 4) {\n    inverse_kinematics_B.ubOK[0] = (initialGuess[0] <= limits->data[limits->\n      size[0]] + 4.4408920985006262E-16);\n    inverse_kinematics_B.ubOK[1] = (initialGuess[1] <= limits->data[1 +\n      limits->size[0]] + 4.4408920985006262E-16);\n    inverse_kinematics_B.ubOK[2] = (initialGuess[2] <= limits->data[2 +\n      limits->size[0]] + 4.4408920985006262E-16);\n    inverse_kinematics_B.ubOK[3] = (initialGuess[3] <= limits->data[3 +\n      limits->size[0]] + 4.4408920985006262E-16);\n  } else {\n    inverse_ki_binary_expand_op_gaq(inverse_kinematics_B.ubOK, initialGuess,\n      limits);\n  }\n\n  if (limits->size[0] == 4) {\n    inverse_kinematics_B.lbOK[0] = (initialGuess[0] >= limits->data[0] -\n      4.4408920985006262E-16);\n    inverse_kinematics_B.lbOK[1] = (initialGuess[1] >= limits->data[1] -\n      4.4408920985006262E-16);\n    inverse_kinematics_B.lbOK[2] = (initialGuess[2] >= limits->data[2] -\n      4.4408920985006262E-16);\n    inverse_kinematics_B.lbOK[3] = (initialGuess[3] >= limits->data[3] -\n      4.4408920985006262E-16);\n  } else {\n    inverse_kin_binary_expand_op_ga(inverse_kinematics_B.lbOK, initialGuess,\n      limits);\n  }\n\n  inverse_kinematics_B.y_m = true;\n  inverse_kinematics_B.b_k = 0;\n  exitg1 = false;\n  while ((!exitg1) && (inverse_kinematics_B.b_k < 4)) {\n    if (!inverse_kinematics_B.ubOK[inverse_kinematics_B.b_k]) {\n      inverse_kinematics_B.y_m = false;\n      exitg1 = true;\n    } else {\n      inverse_kinematics_B.b_k++;\n    }\n  }\n\n  guard1 = false;\n  if (inverse_kinematics_B.y_m) {\n    inverse_kinematics_B.y_m = true;\n    inverse_kinematics_B.b_k = 0;\n    exitg1 = false;\n    while ((!exitg1) && (inverse_kinematics_B.b_k < 4)) {\n      if (!inverse_kinematics_B.lbOK[inverse_kinematics_B.b_k]) {\n        inverse_kinematics_B.y_m = false;\n        exitg1 = true;\n      } else {\n        inverse_kinematics_B.b_k++;\n      }\n    }\n\n    if (inverse_kinematics_B.y_m) {\n    } else {\n      guard1 = true;\n    }\n  } else {\n    guard1 = true;\n  }\n\n  if (guard1) {\n    inverse_kinematics_B.ubOK_a[0] = !inverse_kinematics_B.ubOK[0];\n    inverse_kinematics_B.ubOK_a[1] = !inverse_kinematics_B.ubOK[1];\n    inverse_kinematics_B.ubOK_a[2] = !inverse_kinematics_B.ubOK[2];\n    inverse_kinematics_B.ubOK_a[3] = !inverse_kinematics_B.ubOK[3];\n    inverse_kinematics_eml_find(inverse_kinematics_B.ubOK_a,\n      inverse_kinematics_B.tmp_data, &inverse_kinematics_B.tmp_size);\n    inverse_kinematics_B.indicesUpperBoundViolation_size =\n      inverse_kinematics_B.tmp_size;\n    inverse_kinematics_B.loop_ub_o = inverse_kinematics_B.tmp_size;\n    if (inverse_kinematics_B.loop_ub_o - 1 >= 0) {\n      memcpy(&inverse_kinematics_B.indicesUpperBoundViolation_data[0],\n             &inverse_kinematics_B.tmp_data[0], inverse_kinematics_B.loop_ub_o *\n             sizeof(int32_T));\n    }\n\n    for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k <\n         inverse_kinematics_B.indicesUpperBoundViolation_size;\n         inverse_kinematics_B.b_k++) {\n      inverse_kinematics_B.indicesUpperBoundViolation =\n        inverse_kinematics_B.indicesUpperBoundViolation_data[inverse_kinematics_B.b_k];\n      initialGuess[inverse_kinematics_B.indicesUpperBoundViolation - 1] =\n        limits->data[(inverse_kinematics_B.indicesUpperBoundViolation +\n                      limits->size[0]) - 1];\n    }\n\n    inverse_kinematics_B.ubOK[0] = !inverse_kinematics_B.lbOK[0];\n    inverse_kinematics_B.ubOK[1] = !inverse_kinematics_B.lbOK[1];\n    inverse_kinematics_B.ubOK[2] = !inverse_kinematics_B.lbOK[2];\n    inverse_kinematics_B.ubOK[3] = !inverse_kinematics_B.lbOK[3];\n    inverse_kinematics_eml_find(inverse_kinematics_B.ubOK,\n      inverse_kinematics_B.tmp_data, &inverse_kinematics_B.tmp_size);\n    inverse_kinematics_B.indicesUpperBoundViolation_size =\n      inverse_kinematics_B.tmp_size;\n    inverse_kinematics_B.loop_ub_o = inverse_kinematics_B.tmp_size;\n    if (inverse_kinematics_B.loop_ub_o - 1 >= 0) {\n      memcpy(&inverse_kinematics_B.indicesUpperBoundViolation_data[0],\n             &inverse_kinematics_B.tmp_data[0], inverse_kinematics_B.loop_ub_o *\n             sizeof(int32_T));\n    }\n\n    for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k <\n         inverse_kinematics_B.indicesUpperBoundViolation_size;\n         inverse_kinematics_B.b_k++) {\n      inverse_kinematics_B.indicesUpperBoundViolation =\n        inverse_kinematics_B.indicesUpperBoundViolation_data[inverse_kinematics_B.b_k];\n      initialGuess[inverse_kinematics_B.indicesUpperBoundViolation - 1] =\n        limits->data[inverse_kinematics_B.indicesUpperBoundViolation - 1];\n    }\n  }\n\n  inverse_kinemati_emxInit_char_T(&endEffectorName, 2);\n  invers_NLPSolverInterface_solve(obj->Solver, initialGuess,\n    inverse_kinematics_B.qvSolRaw, solutionInfo_Iterations,\n    solutionInfo_NumRandomRestarts, solutionInfo_PoseErrorNorm,\n    solutionInfo_ExitFlag, solutionInfo_Status_data, solutionInfo_Status_size);\n  obj_0 = obj->RigidBodyTreeInternal;\n  inverse_kinematics_B.nm1d2 = endEffectorName->size[0] * endEffectorName->size\n    [1];\n  endEffectorName->size[0] = 1;\n  endEffectorName->size[1] = obj->Solver->ExtraArgs->BodyName->size[1];\n  invers_emxEnsureCapacity_char_T(endEffectorName, inverse_kinematics_B.nm1d2);\n  inverse_kinematics_B.loop_ub_o = obj->Solver->ExtraArgs->BodyName->size[1] - 1;\n  for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k <=\n       inverse_kinematics_B.loop_ub_o; inverse_kinematics_B.b_k++) {\n    inverse_kinematics_B.nm1d2 = inverse_kinematics_B.b_k;\n    endEffectorName->data[inverse_kinematics_B.nm1d2] = obj->Solver->\n      ExtraArgs->BodyName->data[inverse_kinematics_B.nm1d2];\n  }\n\n  inverse_kinemati_emxInit_real_T(&bodyIndices, 1);\n  inverse_kinematics_B.nm1d2 = bodyIndices->size[0];\n  bodyIndices->size[0] = static_cast<int32_T>(obj_0->NumBodies);\n  invers_emxEnsureCapacity_real_T(bodyIndices, inverse_kinematics_B.nm1d2);\n  inverse_kinematics_B.loop_ub_o = static_cast<int32_T>(obj_0->NumBodies);\n  if (inverse_kinematics_B.loop_ub_o - 1 >= 0) {\n    memset(&bodyIndices->data[0], 0, inverse_kinematics_B.loop_ub_o * sizeof\n           (real_T));\n  }\n\n  inverse_kinematics_B.bid = RigidBodyTree_findBodyIndexByNa(obj_0,\n    endEffectorName);\n  inverse_kinemati_emxFree_char_T(&endEffectorName);\n  if (inverse_kinematics_B.bid == 0.0) {\n    inverse_kinematics_B.nm1d2 = bodyIndices->size[0];\n    bodyIndices->size[0] = 1;\n    invers_emxEnsureCapacity_real_T(bodyIndices, inverse_kinematics_B.nm1d2);\n    bodyIndices->data[0] = 0.0;\n  } else {\n    body = obj_0->Bodies[static_cast<int32_T>(inverse_kinematics_B.bid) - 1];\n    inverse_kinematics_B.bid = 1.0;\n    while (body->ParentIndex != 0.0) {\n      bodyIndices->data[static_cast<int32_T>(inverse_kinematics_B.bid) - 1] =\n        body->Index;\n      body = obj_0->Bodies[static_cast<int32_T>(body->ParentIndex) - 1];\n      inverse_kinematics_B.bid++;\n    }\n\n    if (inverse_kinematics_B.bid - 1.0 < 1.0) {\n      inverse_kinematics_B.indicesUpperBoundViolation_size = -1;\n    } else {\n      inverse_kinematics_B.indicesUpperBoundViolation_size = static_cast<int32_T>\n        (inverse_kinematics_B.bid - 1.0) - 1;\n    }\n\n    inverse_kinematics_B.nm1d2 = bodyIndices->size[0];\n    bodyIndices->size[0] = inverse_kinematics_B.indicesUpperBoundViolation_size\n      + 3;\n    invers_emxEnsureCapacity_real_T(bodyIndices, inverse_kinematics_B.nm1d2);\n    bodyIndices->data[inverse_kinematics_B.indicesUpperBoundViolation_size + 1] =\n      body->Index;\n    bodyIndices->data[inverse_kinematics_B.indicesUpperBoundViolation_size + 2] =\n      0.0;\n  }\n\n  obj_0 = obj->RigidBodyTreeInternal;\n  inverse_kinematics_B.b_k = bodyIndices->size[0] - 1;\n  inverse_kinematics_B.indicesUpperBoundViolation_size = 0;\n  for (inverse_kinematics_B.indicesUpperBoundViolation = 0;\n       inverse_kinematics_B.indicesUpperBoundViolation <=\n       inverse_kinematics_B.b_k; inverse_kinematics_B.indicesUpperBoundViolation\n       ++) {\n    if (bodyIndices->data[inverse_kinematics_B.indicesUpperBoundViolation] !=\n        0.0) {\n      inverse_kinematics_B.indicesUpperBoundViolation_size++;\n    }\n  }\n\n  inverse_kinemat_emxInit_int32_T(&h, 1);\n  inverse_kinematics_B.nm1d2 = h->size[0];\n  h->size[0] = inverse_kinematics_B.indicesUpperBoundViolation_size;\n  inver_emxEnsureCapacity_int32_T(h, inverse_kinematics_B.nm1d2);\n  inverse_kinematics_B.indicesUpperBoundViolation_size = 0;\n  for (inverse_kinematics_B.indicesUpperBoundViolation = 0;\n       inverse_kinematics_B.indicesUpperBoundViolation <=\n       inverse_kinematics_B.b_k; inverse_kinematics_B.indicesUpperBoundViolation\n       ++) {\n    if (bodyIndices->data[inverse_kinematics_B.indicesUpperBoundViolation] !=\n        0.0) {\n      h->data[inverse_kinematics_B.indicesUpperBoundViolation_size] =\n        inverse_kinematics_B.indicesUpperBoundViolation + 1;\n      inverse_kinematics_B.indicesUpperBoundViolation_size++;\n    }\n  }\n\n  inverse_kinematics_B.nm1d2 = limits->size[0] * limits->size[1];\n  limits->size[0] = h->size[0];\n  limits->size[1] = 2;\n  invers_emxEnsureCapacity_real_T(limits, inverse_kinematics_B.nm1d2);\n  inverse_kinematics_B.loop_ub_o = h->size[0];\n  for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k < 2;\n       inverse_kinematics_B.b_k++) {\n    for (inverse_kinematics_B.indicesUpperBoundViolation = 0;\n         inverse_kinematics_B.indicesUpperBoundViolation <\n         inverse_kinematics_B.loop_ub_o;\n         inverse_kinematics_B.indicesUpperBoundViolation++) {\n      limits->data[inverse_kinematics_B.indicesUpperBoundViolation +\n        limits->size[0] * inverse_kinematics_B.b_k] = obj_0->PositionDoFMap[(\n        static_cast<int32_T>(bodyIndices->data[h->\n        data[inverse_kinematics_B.indicesUpperBoundViolation] - 1]) + 6 *\n        inverse_kinematics_B.b_k) - 1];\n    }\n  }\n\n  inverse_kinemat_emxFree_int32_T(&h);\n  inverse_kinemati_emxFree_real_T(&bodyIndices);\n  inverse_kinemati_emxInit_real_T(&positionIndices, 2);\n  inverse_kinematics_B.nm1d2 = positionIndices->size[0] * positionIndices->size\n    [1];\n  positionIndices->size[0] = 1;\n  positionIndices->size[1] = static_cast<int32_T>(obj_0->PositionNumber);\n  invers_emxEnsureCapacity_real_T(positionIndices, inverse_kinematics_B.nm1d2);\n  inverse_kinematics_B.loop_ub_o = static_cast<int32_T>(obj_0->PositionNumber) -\n    1;\n  if (inverse_kinematics_B.loop_ub_o >= 0) {\n    memset(&positionIndices->data[0], 0, (inverse_kinematics_B.loop_ub_o + 1) *\n           sizeof(real_T));\n  }\n\n  inverse_kinematics_B.bid = 0.0;\n  inverse_kinematics_B.indicesUpperBoundViolation_size = limits->size[0] - 1;\n  inverse_kinemati_emxInit_real_T(&e, 2);\n  inverse_kinema_emxInit_uint32_T(&y, 2);\n  for (inverse_kinematics_B.indicesUpperBoundViolation = 0;\n       inverse_kinematics_B.indicesUpperBoundViolation <=\n       inverse_kinematics_B.indicesUpperBoundViolation_size;\n       inverse_kinematics_B.indicesUpperBoundViolation++) {\n    inverse_kinematics_B.numPositions_tmp = limits->\n      data[inverse_kinematics_B.indicesUpperBoundViolation + limits->size[0]] -\n      limits->data[inverse_kinematics_B.indicesUpperBoundViolation];\n    if (inverse_kinematics_B.numPositions_tmp + 1.0 > 0.0) {\n      if (inverse_kinematics_B.numPositions_tmp + 1.0 < 1.0) {\n        y->size[0] = 1;\n        y->size[1] = 0;\n      } else {\n        inverse_kinematics_B.nm1d2 = y->size[0] * y->size[1];\n        y->size[0] = 1;\n        y->size[1] = static_cast<int32_T>((inverse_kinematics_B.numPositions_tmp\n          + 1.0) - 1.0) + 1;\n        inve_emxEnsureCapacity_uint32_T(y, inverse_kinematics_B.nm1d2);\n        inverse_kinematics_B.loop_ub_o = static_cast<int32_T>\n          ((inverse_kinematics_B.numPositions_tmp + 1.0) - 1.0);\n        for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k <=\n             inverse_kinematics_B.loop_ub_o; inverse_kinematics_B.b_k++) {\n          y->data[inverse_kinematics_B.b_k] = inverse_kinematics_B.b_k + 1U;\n        }\n      }\n\n      if (rtIsNaN(limits->data[inverse_kinematics_B.indicesUpperBoundViolation])\n          || rtIsNaN(limits->\n                     data[inverse_kinematics_B.indicesUpperBoundViolation +\n                     limits->size[0]])) {\n        inverse_kinematics_B.nm1d2 = e->size[0] * e->size[1];\n        e->size[0] = 1;\n        e->size[1] = 1;\n        invers_emxEnsureCapacity_real_T(e, inverse_kinematics_B.nm1d2);\n        e->data[0] = (rtNaN);\n      } else if (limits->data[inverse_kinematics_B.indicesUpperBoundViolation +\n                 limits->size[0]] < limits->\n                 data[inverse_kinematics_B.indicesUpperBoundViolation]) {\n        e->size[0] = 1;\n        e->size[1] = 0;\n      } else if ((rtIsInf(limits->\n                          data[inverse_kinematics_B.indicesUpperBoundViolation])\n                  || rtIsInf(limits->\n                             data[inverse_kinematics_B.indicesUpperBoundViolation\n        + limits->size[0]])) && (limits->\n                  data[inverse_kinematics_B.indicesUpperBoundViolation +\n                  limits->size[0]] == limits->\n                  data[inverse_kinematics_B.indicesUpperBoundViolation])) {\n        inverse_kinematics_B.nm1d2 = e->size[0] * e->size[1];\n        e->size[0] = 1;\n        e->size[1] = 1;\n        invers_emxEnsureCapacity_real_T(e, inverse_kinematics_B.nm1d2);\n        e->data[0] = (rtNaN);\n      } else if (floor(limits->\n                       data[inverse_kinematics_B.indicesUpperBoundViolation]) ==\n                 limits->data[inverse_kinematics_B.indicesUpperBoundViolation])\n      {\n        inverse_kinematics_B.nm1d2 = e->size[0] * e->size[1];\n        e->size[0] = 1;\n        e->size[1] = static_cast<int32_T>(inverse_kinematics_B.numPositions_tmp)\n          + 1;\n        invers_emxEnsureCapacity_real_T(e, inverse_kinematics_B.nm1d2);\n        inverse_kinematics_B.loop_ub_o = static_cast<int32_T>(limits->\n          data[inverse_kinematics_B.indicesUpperBoundViolation + limits->size[0]]\n          - limits->data[inverse_kinematics_B.indicesUpperBoundViolation]);\n        for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k <=\n             inverse_kinematics_B.loop_ub_o; inverse_kinematics_B.b_k++) {\n          e->data[inverse_kinematics_B.b_k] = limits->\n            data[inverse_kinematics_B.indicesUpperBoundViolation] + static_cast<\n            real_T>(inverse_kinematics_B.b_k);\n        }\n      } else {\n        inverse_kinematics_B.ndbl = floor(inverse_kinematics_B.numPositions_tmp\n          + 0.5);\n        inverse_kinematics_B.apnd = limits->\n          data[inverse_kinematics_B.indicesUpperBoundViolation] +\n          inverse_kinematics_B.ndbl;\n        inverse_kinematics_B.cdiff = inverse_kinematics_B.apnd - limits->\n          data[inverse_kinematics_B.indicesUpperBoundViolation + limits->size[0]];\n        inverse_kinematics_B.u0 = fabs(limits->\n          data[inverse_kinematics_B.indicesUpperBoundViolation]);\n        inverse_kinematics_B.u1 = fabs(limits->\n          data[inverse_kinematics_B.indicesUpperBoundViolation + limits->size[0]]);\n        if ((inverse_kinematics_B.u0 >= inverse_kinematics_B.u1) || rtIsNaN\n            (inverse_kinematics_B.u1)) {\n          inverse_kinematics_B.u1 = inverse_kinematics_B.u0;\n        }\n\n        if (fabs(inverse_kinematics_B.cdiff) < 4.4408920985006262E-16 *\n            inverse_kinematics_B.u1) {\n          inverse_kinematics_B.ndbl++;\n          inverse_kinematics_B.apnd = limits->\n            data[inverse_kinematics_B.indicesUpperBoundViolation + limits->size\n            [0]];\n        } else if (inverse_kinematics_B.cdiff > 0.0) {\n          inverse_kinematics_B.apnd = (inverse_kinematics_B.ndbl - 1.0) +\n            limits->data[inverse_kinematics_B.indicesUpperBoundViolation];\n        } else {\n          inverse_kinematics_B.ndbl++;\n        }\n\n        if (inverse_kinematics_B.ndbl >= 0.0) {\n          inverse_kinematics_B.loop_ub_o = static_cast<int32_T>\n            (inverse_kinematics_B.ndbl);\n        } else {\n          inverse_kinematics_B.loop_ub_o = 0;\n        }\n\n        inverse_kinematics_B.nm1d2 = e->size[0] * e->size[1];\n        e->size[0] = 1;\n        e->size[1] = inverse_kinematics_B.loop_ub_o;\n        invers_emxEnsureCapacity_real_T(e, inverse_kinematics_B.nm1d2);\n        if (inverse_kinematics_B.loop_ub_o > 0) {\n          e->data[0] = limits->\n            data[inverse_kinematics_B.indicesUpperBoundViolation];\n          if (inverse_kinematics_B.loop_ub_o > 1) {\n            e->data[inverse_kinematics_B.loop_ub_o - 1] =\n              inverse_kinematics_B.apnd;\n            inverse_kinematics_B.nm1d2 = (((inverse_kinematics_B.loop_ub_o - 1 <\n              0) + inverse_kinematics_B.loop_ub_o) - 1) >> 1;\n            inverse_kinematics_B.c_o = inverse_kinematics_B.nm1d2 - 2;\n            for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k <=\n                 inverse_kinematics_B.c_o; inverse_kinematics_B.b_k++) {\n              e->data[inverse_kinematics_B.b_k + 1] = static_cast<real_T>\n                (inverse_kinematics_B.b_k + 1) + limits->\n                data[inverse_kinematics_B.indicesUpperBoundViolation];\n              e->data[(inverse_kinematics_B.loop_ub_o - inverse_kinematics_B.b_k)\n                - 2] = inverse_kinematics_B.apnd - static_cast<real_T>\n                (inverse_kinematics_B.b_k + 1);\n            }\n\n            if (inverse_kinematics_B.nm1d2 << 1 ==\n                inverse_kinematics_B.loop_ub_o - 1) {\n              e->data[inverse_kinematics_B.nm1d2] = (limits->\n                data[inverse_kinematics_B.indicesUpperBoundViolation] +\n                inverse_kinematics_B.apnd) / 2.0;\n            } else {\n              e->data[inverse_kinematics_B.nm1d2] = limits->\n                data[inverse_kinematics_B.indicesUpperBoundViolation] +\n                static_cast<real_T>(inverse_kinematics_B.nm1d2);\n              e->data[inverse_kinematics_B.nm1d2 + 1] =\n                inverse_kinematics_B.apnd - static_cast<real_T>\n                (inverse_kinematics_B.nm1d2);\n            }\n          }\n        }\n      }\n\n      inverse_kinematics_B.loop_ub_o = e->size[1] - 1;\n      for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k <=\n           inverse_kinematics_B.loop_ub_o; inverse_kinematics_B.b_k++) {\n        inverse_kinematics_B.nm1d2 = inverse_kinematics_B.b_k;\n        positionIndices->data[static_cast<int32_T>(inverse_kinematics_B.bid +\n          static_cast<real_T>(y->data[inverse_kinematics_B.nm1d2])) - 1] =\n          e->data[inverse_kinematics_B.nm1d2];\n      }\n\n      inverse_kinematics_B.bid += inverse_kinematics_B.numPositions_tmp + 1.0;\n    }\n  }\n\n  inverse_kinema_emxFree_uint32_T(&y);\n  inverse_kinemati_emxFree_real_T(&e);\n  inverse_kinemati_emxFree_real_T(&limits);\n  if (inverse_kinematics_B.bid < 1.0) {\n    inverse_kinematics_B.indicesUpperBoundViolation = -1;\n  } else {\n    inverse_kinematics_B.indicesUpperBoundViolation = static_cast<int32_T>\n      (inverse_kinematics_B.bid) - 1;\n  }\n\n  for (inverse_kinematics_B.b_k = 0; inverse_kinematics_B.b_k <=\n       inverse_kinematics_B.indicesUpperBoundViolation; inverse_kinematics_B.b_k\n       ++) {\n    inverse_kinematics_B.bid = positionIndices->data[inverse_kinematics_B.b_k];\n    initialGuess[static_cast<int32_T>(inverse_kinematics_B.bid) - 1] =\n      inverse_kinematics_B.qvSolRaw[static_cast<int32_T>\n      (inverse_kinematics_B.bid) - 1];\n  }\n\n  inverse_kinemati_emxFree_real_T(&positionIndices);\n}\n\nstatic void inve_inverseKinematics_stepImpl(b_inverseKinematics_inverse_k_T *obj,\n  const real_T tform[16], const real_T weights[6], const real_T initialGuess[4],\n  real_T QSol[4])\n{\n  f_robotics_manip_internal_IKE_T *args;\n  static const char_T tmp[5] = { 'B', 'o', 'd', 'y', '5' };\n\n  memset(&inverse_kinematics_B.weightMatrix[0], 0, 36U * sizeof(real_T));\n  for (inverse_kinematics_B.b_j_l = 0; inverse_kinematics_B.b_j_l < 6;\n       inverse_kinematics_B.b_j_l++) {\n    inverse_kinematics_B.weightMatrix[inverse_kinematics_B.b_j_l + 6 *\n      inverse_kinematics_B.b_j_l] = weights[inverse_kinematics_B.b_j_l];\n  }\n\n  args = obj->Solver->ExtraArgs;\n  for (inverse_kinematics_B.b_j_l = 0; inverse_kinematics_B.b_j_l < 36;\n       inverse_kinematics_B.b_j_l++) {\n    args->WeightMatrix[inverse_kinematics_B.b_j_l] =\n      inverse_kinematics_B.weightMatrix[inverse_kinematics_B.b_j_l];\n  }\n\n  inverse_kinematics_B.b_j_l = args->BodyName->size[0] * args->BodyName->size[1];\n  args->BodyName->size[0] = 1;\n  args->BodyName->size[1] = 5;\n  invers_emxEnsureCapacity_char_T(args->BodyName, inverse_kinematics_B.b_j_l);\n  for (inverse_kinematics_B.b_j_l = 0; inverse_kinematics_B.b_j_l < 5;\n       inverse_kinematics_B.b_j_l++) {\n    args->BodyName->data[inverse_kinematics_B.b_j_l] =\n      tmp[inverse_kinematics_B.b_j_l];\n  }\n\n  for (inverse_kinematics_B.b_j_l = 0; inverse_kinematics_B.b_j_l < 16;\n       inverse_kinematics_B.b_j_l++) {\n    args->Tform[inverse_kinematics_B.b_j_l] = tform[inverse_kinematics_B.b_j_l];\n  }\n\n  QSol[0] = initialGuess[0];\n  QSol[1] = initialGuess[1];\n  QSol[2] = initialGuess[2];\n  QSol[3] = initialGuess[3];\n  inver_inverseKinematics_solve_g(obj, QSol, &inverse_kinematics_B.expl_temp,\n    &inverse_kinematics_B.expl_temp_i, &inverse_kinematics_B.expl_temp_o,\n    &inverse_kinematics_B.expl_temp_n, inverse_kinematics_B.expl_temp_data,\n    inverse_kinematics_B.expl_temp_size);\n}\n\nstatic void emxFreeStruct_t_robotics_manip_(t_robotics_manip_internal_Rig_T\n  *pStruct)\n{\n  inverse_kinemati_emxFree_char_T(&pStruct->NameInternal);\n}\n\nstatic void emxFreeStruct_l_robotics_manip_(l_robotics_manip_internal_Col_T\n  *pStruct)\n{\n  inverse__emxFree_unnamed_struct(&pStruct->CollisionGeometries);\n}\n\nstatic void emxFreeMatrix_l_robotics_manip_(l_robotics_manip_internal_Col_T\n  pMatrix[13])\n{\n  for (int32_T i = 0; i < 13; i++) {\n    emxFreeStruct_l_robotics_manip_(&pMatrix[i]);\n  }\n}\n\nstatic void emxFreeStruct_c_rigidBodyJoint(c_rigidBodyJoint_inverse_kine_T\n  *pStruct)\n{\n  inverse_kinemati_emxFree_char_T(&pStruct->Type);\n  inverse_kinemati_emxFree_real_T(&pStruct->MotionSubspace);\n  inverse_kinemati_emxFree_char_T(&pStruct->NameInternal);\n  inverse_kinemati_emxFree_real_T(&pStruct->PositionLimitsInternal);\n  inverse_kinemati_emxFree_real_T(&pStruct->HomePositionInternal);\n}\n\nstatic void emxFreeMatrix_c_rigidBodyJoint(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[13])\n{\n  for (int32_T i = 0; i < 13; i++) {\n    emxFreeStruct_c_rigidBodyJoint(&pMatrix[i]);\n  }\n}\n\nstatic void emxFreeMatrix_t_robotics_manip_(t_robotics_manip_internal_Rig_T\n  pMatrix[12])\n{\n  for (int32_T i = 0; i < 12; i++) {\n    emxFreeStruct_t_robotics_manip_(&pMatrix[i]);\n  }\n}\n\nstatic void emxFreeStruct_u_robotics_manip_(u_robotics_manip_internal_Rig_T\n  *pStruct)\n{\n  emxFreeStruct_t_robotics_manip_(&pStruct->Base);\n  emxFreeMatrix_l_robotics_manip_(pStruct->_pobj0);\n  emxFreeMatrix_c_rigidBodyJoint(pStruct->_pobj1);\n  emxFreeMatrix_t_robotics_manip_(pStruct->_pobj2);\n}\n\nstatic void emxFreeStruct_f_robotics_manip_(f_robotics_manip_internal_IKE_T\n  *pStruct)\n{\n  inverse_kinemati_emxFree_real_T(&pStruct->Limits);\n  inverse_kinemati_emxFree_char_T(&pStruct->BodyName);\n  inverse_kinemati_emxFree_real_T(&pStruct->ErrTemp);\n  inverse_kinemati_emxFree_real_T(&pStruct->GradTemp);\n}\n\nstatic void emxFreeMatrix_c_rigidBodyJoint1(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[12])\n{\n  for (int32_T i = 0; i < 12; i++) {\n    emxFreeStruct_c_rigidBodyJoint(&pMatrix[i]);\n  }\n}\n\nstatic void emxFreeMatrix_t_robotics_mani_g(t_robotics_manip_internal_Rig_T\n  pMatrix[6])\n{\n  for (int32_T i = 0; i < 6; i++) {\n    emxFreeStruct_t_robotics_manip_(&pMatrix[i]);\n  }\n}\n\nstatic void emxFreeMatrix_l_robotics_mani_g(l_robotics_manip_internal_Col_T\n  pMatrix[7])\n{\n  for (int32_T i = 0; i < 7; i++) {\n    emxFreeStruct_l_robotics_manip_(&pMatrix[i]);\n  }\n}\n\nstatic void emxFreeMatrix_c_rigidBodyJoint2(c_rigidBodyJoint_inverse_kine_T\n  pMatrix[7])\n{\n  for (int32_T i = 0; i < 7; i++) {\n    emxFreeStruct_c_rigidBodyJoint(&pMatrix[i]);\n  }\n}\n\nstatic void emxFreeStruct_v_robotics_manip_(v_robotics_manip_internal_Rig_T\n  *pStruct)\n{\n  emxFreeStruct_t_robotics_manip_(&pStruct->Base);\n  emxFreeMatrix_t_robotics_mani_g(pStruct->_pobj0);\n  emxFreeMatrix_l_robotics_mani_g(pStruct->_pobj1);\n  emxFreeMatrix_c_rigidBodyJoint2(pStruct->_pobj2);\n}\n\nstatic void emxFreeStruct_b_inverseKinemati(b_inverseKinematics_inverse_k_T\n  *pStruct)\n{\n  inverse_kinemati_emxFree_real_T(&pStruct->Limits);\n  emxFreeStruct_f_robotics_manip_(&pStruct->_pobj0);\n  emxFreeMatrix_c_rigidBodyJoint1(pStruct->_pobj1);\n  emxFreeMatrix_t_robotics_mani_g(pStruct->_pobj2);\n  emxFreeMatrix_l_robotics_manip_(pStruct->_pobj3);\n  emxFreeStruct_v_robotics_manip_(&pStruct->_pobj4);\n}\n\nstatic void emxFreeStruct_robotics_slmanip_(robotics_slmanip_internal_blo_T\n  *pStruct)\n{\n  emxFreeStruct_u_robotics_manip_(&pStruct->TreeInternal);\n  emxFreeStruct_b_inverseKinemati(&pStruct->IKInternal);\n}\n\n/* Model step function */\nvoid inverse_kinematics_step(void)\n{\n  b_inverseKinematics_inverse_k_T *obj;\n  emxArray_int8_T_inverse_kinem_T *b_gradTmp;\n  emxArray_real_T_inverse_kinem_T *tmp;\n\n  /* Outputs for Atomic SubSystem: '<S3>/Subscribe' */\n  /* MATLABSystem: '<S7>/SourceBlock' */\n  inverse_kinematics_B.b_varargout_1 =\n    Sub_inverse_kinematics_482.getLatestMessage\n    (&inverse_kinematics_B.b_varargout_2);\n\n  /* Outputs for Enabled SubSystem: '<Root>/Inverse Kinematics' incorporates:\n   *  EnablePort: '<S1>/Enable'\n   */\n  /* Outputs for Enabled SubSystem: '<S7>/Enabled Subsystem' incorporates:\n   *  EnablePort: '<S8>/Enable'\n   */\n  if (inverse_kinematics_B.b_varargout_1) {\n    /* MATLABSystem: '<S1>/Coordinate Transformation Conversion1' */\n    for (inverse_kinematics_B.b_jcol = 0; inverse_kinematics_B.b_jcol < 16;\n         inverse_kinematics_B.b_jcol++) {\n      inverse_kinematics_B.b_I[inverse_kinematics_B.b_jcol] = 0;\n    }\n\n    inverse_kinematics_B.b_I[0] = 1;\n    inverse_kinematics_B.b_I[5] = 1;\n    inverse_kinematics_B.b_I[10] = 1;\n    inverse_kinematics_B.b_I[15] = 1;\n    for (inverse_kinematics_B.b_jcol = 0; inverse_kinematics_B.b_jcol < 4;\n         inverse_kinematics_B.b_jcol++) {\n      inverse_kinematics_B.iacol_tmp = (inverse_kinematics_B.b_jcol << 2) - 1;\n      inverse_kinematics_B.out[inverse_kinematics_B.iacol_tmp + 1] =\n        inverse_kinematics_B.b_I[inverse_kinematics_B.iacol_tmp + 1];\n      inverse_kinematics_B.out[inverse_kinematics_B.iacol_tmp + 2] =\n        inverse_kinematics_B.b_I[inverse_kinematics_B.iacol_tmp + 2];\n      inverse_kinematics_B.out[inverse_kinematics_B.iacol_tmp + 3] =\n        inverse_kinematics_B.b_I[inverse_kinematics_B.iacol_tmp + 3];\n      inverse_kinematics_B.out[inverse_kinematics_B.iacol_tmp + 4] =\n        inverse_kinematics_B.b_I[inverse_kinematics_B.iacol_tmp + 4];\n    }\n\n    inverse_kinematics_B.out[12] = inverse_kinematics_B.b_varargout_2.X;\n    inverse_kinematics_B.out[13] = inverse_kinematics_B.b_varargout_2.Y;\n    inverse_kinematics_B.out[14] = inverse_kinematics_B.b_varargout_2.Z;\n\n    /* MATLABSystem: '<S4>/MATLAB System' incorporates:\n     *  Constant: '<S1>/Constant1'\n     *  Delay: '<S1>/Delay'\n     *  MATLABSystem: '<S1>/Coordinate Transformation Conversion1'\n     */\n    obj = &inverse_kinematics_DW.obj.IKInternal;\n    if (inverse_kinematics_DW.obj.IKInternal.isInitialized != 1) {\n      inverse_kinematics_DW.obj.IKInternal.isSetupComplete = false;\n      inverse_kinematics_DW.obj.IKInternal.isInitialized = 1;\n      RigidBodyTree_get_JointPosition\n        (inverse_kinematics_DW.obj.IKInternal.RigidBodyTreeInternal,\n         inverse_kinematics_DW.obj.IKInternal.Limits);\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs = &obj->_pobj0;\n      for (inverse_kinematics_B.b_jcol = 0; inverse_kinematics_B.b_jcol < 36;\n           inverse_kinematics_B.b_jcol++) {\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->\n          WeightMatrix[inverse_kinematics_B.b_jcol] = 0.0;\n      }\n\n      inverse_kinemati_emxInit_real_T(&tmp, 1);\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->Robot =\n        inverse_kinematics_DW.obj.IKInternal.RigidBodyTreeInternal;\n      inverse_kinematics_B.loop_ub =\n        inverse_kinematics_DW.obj.IKInternal.Limits->size[0] << 1;\n      inverse_kinematics_B.b_jcol =\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->Limits->size[0] *\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->Limits->size[1];\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->Limits->size[0] =\n        inverse_kinematics_DW.obj.IKInternal.Limits->size[0];\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->Limits->size[1] =\n        2;\n      invers_emxEnsureCapacity_real_T\n        (inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->Limits,\n         inverse_kinematics_B.b_jcol);\n      inverse_kinematics_B.b_jcol = tmp->size[0];\n      tmp->size[0] = inverse_kinematics_B.loop_ub;\n      invers_emxEnsureCapacity_real_T(tmp, inverse_kinematics_B.b_jcol);\n      for (inverse_kinematics_B.iacol_tmp = 0; inverse_kinematics_B.iacol_tmp <\n           inverse_kinematics_B.loop_ub; inverse_kinematics_B.iacol_tmp++) {\n        tmp->data[inverse_kinematics_B.iacol_tmp] =\n          inverse_kinematics_DW.obj.IKInternal.Limits->\n          data[inverse_kinematics_B.iacol_tmp];\n      }\n\n      inverse_kinematics_B.loop_ub = tmp->size[0];\n      for (inverse_kinematics_B.iacol_tmp = 0; inverse_kinematics_B.iacol_tmp <\n           inverse_kinematics_B.loop_ub; inverse_kinematics_B.iacol_tmp++) {\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->Limits->\n          data[inverse_kinematics_B.iacol_tmp] = tmp->\n          data[inverse_kinematics_B.iacol_tmp];\n      }\n\n      inverse_kinemati_emxFree_real_T(&tmp);\n      for (inverse_kinematics_B.b_jcol = 0; inverse_kinematics_B.b_jcol < 16;\n           inverse_kinematics_B.b_jcol++) {\n        inverse_kinematics_B.b_I[inverse_kinematics_B.b_jcol] = 0;\n      }\n\n      inverse_kinematics_B.b_I[0] = 1;\n      inverse_kinematics_B.b_I[5] = 1;\n      inverse_kinematics_B.b_I[10] = 1;\n      inverse_kinematics_B.b_I[15] = 1;\n      for (inverse_kinematics_B.b_jcol = 0; inverse_kinematics_B.b_jcol < 16;\n           inverse_kinematics_B.b_jcol++) {\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->\n          Tform[inverse_kinematics_B.b_jcol] =\n          inverse_kinematics_B.b_I[inverse_kinematics_B.b_jcol];\n      }\n\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->BodyName->size[0] =\n        1;\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->BodyName->size[1] =\n        0;\n      inverse_kinematics_B.b_jcol =\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->ErrTemp->size[0];\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->ErrTemp->size[0] =\n        6;\n      invers_emxEnsureCapacity_real_T\n        (inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->ErrTemp,\n         inverse_kinematics_B.b_jcol);\n      for (inverse_kinematics_B.b_jcol = 0; inverse_kinematics_B.b_jcol < 6;\n           inverse_kinematics_B.b_jcol++) {\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->ErrTemp->\n          data[inverse_kinematics_B.b_jcol] = 0.0;\n      }\n\n      inverse_kinemati_emxInit_int8_T(&b_gradTmp, 1);\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->CostTemp = 0.0;\n      inverse_kinematics_B.b_jcol = b_gradTmp->size[0];\n      b_gradTmp->size[0] = static_cast<int32_T>\n        (inverse_kinematics_DW.obj.IKInternal.RigidBodyTreeInternal->PositionNumber);\n      invers_emxEnsureCapacity_int8_T(b_gradTmp, inverse_kinematics_B.b_jcol);\n      inverse_kinematics_B.loop_ub = static_cast<int32_T>\n        (inverse_kinematics_DW.obj.IKInternal.RigidBodyTreeInternal->PositionNumber);\n      if (inverse_kinematics_B.loop_ub - 1 >= 0) {\n        memset(&b_gradTmp->data[0], 0, inverse_kinematics_B.loop_ub * sizeof\n               (int8_T));\n      }\n\n      inverse_kinematics_B.b_jcol =\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->GradTemp->size[0];\n      inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->GradTemp->size[0] =\n        b_gradTmp->size[0];\n      invers_emxEnsureCapacity_real_T\n        (inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->GradTemp,\n         inverse_kinematics_B.b_jcol);\n      inverse_kinematics_B.loop_ub = b_gradTmp->size[0];\n      inverse_kinemati_emxFree_int8_T(&b_gradTmp);\n      for (inverse_kinematics_B.b_jcol = 0; inverse_kinematics_B.b_jcol <\n           inverse_kinematics_B.loop_ub; inverse_kinematics_B.b_jcol++) {\n        inverse_kinematics_DW.obj.IKInternal.Solver->ExtraArgs->GradTemp->\n          data[inverse_kinematics_B.b_jcol] = 0.0;\n      }\n\n      inverse_kinematics_DW.obj.IKInternal.isSetupComplete = true;\n    }\n\n    inve_inverseKinematics_stepImpl(&inverse_kinematics_DW.obj.IKInternal,\n      inverse_kinematics_B.out, inverse_kinematics_P.Constant1_Value,\n      inverse_kinematics_DW.Delay_DSTATE, inverse_kinematics_B.MATLABSystem_o1);\n\n    /* End of MATLABSystem: '<S4>/MATLAB System' */\n\n    /* Update for Delay: '<S1>/Delay' incorporates:\n     *  MATLABSystem: '<S4>/MATLAB System'\n     */\n    inverse_kinematics_DW.Delay_DSTATE[0] =\n      inverse_kinematics_B.MATLABSystem_o1[0];\n    inverse_kinematics_DW.Delay_DSTATE[1] =\n      inverse_kinematics_B.MATLABSystem_o1[1];\n    inverse_kinematics_DW.Delay_DSTATE[2] =\n      inverse_kinematics_B.MATLABSystem_o1[2];\n    inverse_kinematics_DW.Delay_DSTATE[3] =\n      inverse_kinematics_B.MATLABSystem_o1[3];\n  }\n\n  /* End of MATLABSystem: '<S7>/SourceBlock' */\n  /* End of Outputs for SubSystem: '<S7>/Enabled Subsystem' */\n  /* End of Outputs for SubSystem: '<Root>/Inverse Kinematics' */\n  /* End of Outputs for SubSystem: '<S3>/Subscribe' */\n\n  /* BusAssignment: '<S2>/Bus Assignment' */\n  inverse_kinematics_B.BusAssignment.X = inverse_kinematics_B.MATLABSystem_o1[0];\n  inverse_kinematics_B.BusAssignment.Y = inverse_kinematics_B.MATLABSystem_o1[1];\n  inverse_kinematics_B.BusAssignment.Z = inverse_kinematics_B.MATLABSystem_o1[2];\n  inverse_kinematics_B.BusAssignment.W = inverse_kinematics_B.MATLABSystem_o1[3];\n\n  /* Outputs for Atomic SubSystem: '<S2>/Publish' */\n  /* MATLABSystem: '<S6>/SinkBlock' */\n  Pub_inverse_kinematics_487.publish(&inverse_kinematics_B.BusAssignment);\n\n  /* End of Outputs for SubSystem: '<S2>/Publish' */\n}\n\n/* Model initialize function */\nvoid inverse_kinematics_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  /* block I/O */\n  (void) memset((static_cast<void *>(&inverse_kinematics_B)), 0,\n                sizeof(B_inverse_kinematics_T));\n\n  /* states (dwork) */\n  (void) memset(static_cast<void *>(&inverse_kinematics_DW), 0,\n                sizeof(DW_inverse_kinematics_T));\n\n  {\n    static const char_T tmp[8] = { '/', 'c', 'o', 'm', 'm', 'a', 'n', 'd' };\n\n    static const uint32_T tmp_0[625] = { 5489U, 1301868182U, 2938499221U,\n      2950281878U, 1875628136U, 751856242U, 944701696U, 2243192071U, 694061057U,\n      219885934U, 2066767472U, 3182869408U, 485472502U, 2336857883U, 1071588843U,\n      3418470598U, 951210697U, 3693558366U, 2923482051U, 1793174584U,\n      2982310801U, 1586906132U, 1951078751U, 1808158765U, 1733897588U,\n      431328322U, 4202539044U, 530658942U, 1714810322U, 3025256284U, 3342585396U,\n      1937033938U, 2640572511U, 1654299090U, 3692403553U, 4233871309U,\n      3497650794U, 862629010U, 2943236032U, 2426458545U, 1603307207U,\n      1133453895U, 3099196360U, 2208657629U, 2747653927U, 931059398U, 761573964U,\n      3157853227U, 785880413U, 730313442U, 124945756U, 2937117055U, 3295982469U,\n      1724353043U, 3021675344U, 3884886417U, 4010150098U, 4056961966U,\n      699635835U, 2681338818U, 1339167484U, 720757518U, 2800161476U, 2376097373U,\n      1532957371U, 3902664099U, 1238982754U, 3725394514U, 3449176889U,\n      3570962471U, 4287636090U, 4087307012U, 3603343627U, 202242161U,\n      2995682783U, 1620962684U, 3704723357U, 371613603U, 2814834333U,\n      2111005706U, 624778151U, 2094172212U, 4284947003U, 1211977835U, 991917094U,\n      1570449747U, 2962370480U, 1259410321U, 170182696U, 146300961U, 2836829791U,\n      619452428U, 2723670296U, 1881399711U, 1161269684U, 1675188680U,\n      4132175277U, 780088327U, 3409462821U, 1036518241U, 1834958505U,\n      3048448173U, 161811569U, 618488316U, 44795092U, 3918322701U, 1924681712U,\n      3239478144U, 383254043U, 4042306580U, 2146983041U, 3992780527U,\n      3518029708U, 3545545436U, 3901231469U, 1896136409U, 2028528556U,\n      2339662006U, 501326714U, 2060962201U, 2502746480U, 561575027U, 581893337U,\n      3393774360U, 1778912547U, 3626131687U, 2175155826U, 319853231U, 986875531U,\n      819755096U, 2915734330U, 2688355739U, 3482074849U, 2736559U, 2296975761U,\n      1029741190U, 2876812646U, 690154749U, 579200347U, 4027461746U, 1285330465U,\n      2701024045U, 4117700889U, 759495121U, 3332270341U, 2313004527U,\n      2277067795U, 4131855432U, 2722057515U, 1264804546U, 3848622725U,\n      2211267957U, 4100593547U, 959123777U, 2130745407U, 3194437393U, 486673947U,\n      1377371204U, 17472727U, 352317554U, 3955548058U, 159652094U, 1232063192U,\n      3835177280U, 49423123U, 3083993636U, 733092U, 2120519771U, 2573409834U,\n      1112952433U, 3239502554U, 761045320U, 1087580692U, 2540165110U, 641058802U,\n      1792435497U, 2261799288U, 1579184083U, 627146892U, 2165744623U,\n      2200142389U, 2167590760U, 2381418376U, 1793358889U, 3081659520U,\n      1663384067U, 2009658756U, 2689600308U, 739136266U, 2304581039U,\n      3529067263U, 591360555U, 525209271U, 3131882996U, 294230224U, 2076220115U,\n      3113580446U, 1245621585U, 1386885462U, 3203270426U, 123512128U, 12350217U,\n      354956375U, 4282398238U, 3356876605U, 3888857667U, 157639694U, 2616064085U,\n      1563068963U, 2762125883U, 4045394511U, 4180452559U, 3294769488U,\n      1684529556U, 1002945951U, 3181438866U, 22506664U, 691783457U, 2685221343U,\n      171579916U, 3878728600U, 2475806724U, 2030324028U, 3331164912U,\n      1708711359U, 1970023127U, 2859691344U, 2588476477U, 2748146879U,\n      136111222U, 2967685492U, 909517429U, 2835297809U, 3206906216U, 3186870716U,\n      341264097U, 2542035121U, 3353277068U, 548223577U, 3170936588U, 1678403446U,\n      297435620U, 2337555430U, 466603495U, 1132321815U, 1208589219U, 696392160U,\n      894244439U, 2562678859U, 470224582U, 3306867480U, 201364898U, 2075966438U,\n      1767227936U, 2929737987U, 3674877796U, 2654196643U, 3692734598U,\n      3528895099U, 2796780123U, 3048728353U, 842329300U, 191554730U, 2922459673U,\n      3489020079U, 3979110629U, 1022523848U, 2202932467U, 3583655201U,\n      3565113719U, 587085778U, 4176046313U, 3013713762U, 950944241U, 396426791U,\n      3784844662U, 3477431613U, 3594592395U, 2782043838U, 3392093507U,\n      3106564952U, 2829419931U, 1358665591U, 2206918825U, 3170783123U, 31522386U,\n      2988194168U, 1782249537U, 1105080928U, 843500134U, 1225290080U,\n      1521001832U, 3605886097U, 2802786495U, 2728923319U, 3996284304U,\n      903417639U, 1171249804U, 1020374987U, 2824535874U, 423621996U, 1988534473U,\n      2493544470U, 1008604435U, 1756003503U, 1488867287U, 1386808992U,\n      732088248U, 1780630732U, 2482101014U, 976561178U, 1543448953U, 2602866064U,\n      2021139923U, 1952599828U, 2360242564U, 2117959962U, 2753061860U,\n      2388623612U, 4138193781U, 2962920654U, 2284970429U, 766920861U,\n      3457264692U, 2879611383U, 815055854U, 2332929068U, 1254853997U,\n      3740375268U, 3799380844U, 4091048725U, 2006331129U, 1982546212U,\n      686850534U, 1907447564U, 2682801776U, 2780821066U, 998290361U, 1342433871U,\n      4195430425U, 607905174U, 3902331779U, 2454067926U, 1708133115U,\n      1170874362U, 2008609376U, 3260320415U, 2211196135U, 433538229U,\n      2728786374U, 2189520818U, 262554063U, 1182318347U, 3710237267U,\n      1221022450U, 715966018U, 2417068910U, 2591870721U, 2870691989U,\n      3418190842U, 4238214053U, 1540704231U, 1575580968U, 2095917976U,\n      4078310857U, 2313532447U, 2110690783U, 4056346629U, 4061784526U,\n      1123218514U, 551538993U, 597148360U, 4120175196U, 3581618160U, 3181170517U,\n      422862282U, 3227524138U, 1713114790U, 662317149U, 1230418732U, 928171837U,\n      1324564878U, 1928816105U, 1786535431U, 2878099422U, 3290185549U,\n      539474248U, 1657512683U, 552370646U, 1671741683U, 3655312128U, 1552739510U,\n      2605208763U, 1441755014U, 181878989U, 3124053868U, 1447103986U,\n      3183906156U, 1728556020U, 3502241336U, 3055466967U, 1013272474U,\n      818402132U, 1715099063U, 2900113506U, 397254517U, 4194863039U, 1009068739U,\n      232864647U, 2540223708U, 2608288560U, 2415367765U, 478404847U, 3455100648U,\n      3182600021U, 2115988978U, 434269567U, 4117179324U, 3461774077U, 887256537U,\n      3545801025U, 286388911U, 3451742129U, 1981164769U, 786667016U, 3310123729U,\n      3097811076U, 2224235657U, 2959658883U, 3370969234U, 2514770915U,\n      3345656436U, 2677010851U, 2206236470U, 271648054U, 2342188545U,\n      4292848611U, 3646533909U, 3754009956U, 3803931226U, 4160647125U,\n      1477814055U, 4043852216U, 1876372354U, 3133294443U, 3871104810U,\n      3177020907U, 2074304428U, 3479393793U, 759562891U, 164128153U, 1839069216U,\n      2114162633U, 3989947309U, 3611054956U, 1333547922U, 835429831U, 494987340U,\n      171987910U, 1252001001U, 370809172U, 3508925425U, 2535703112U, 1276855041U,\n      1922855120U, 835673414U, 3030664304U, 613287117U, 171219893U, 3423096126U,\n      3376881639U, 2287770315U, 1658692645U, 1262815245U, 3957234326U,\n      1168096164U, 2968737525U, 2655813712U, 2132313144U, 3976047964U,\n      326516571U, 353088456U, 3679188938U, 3205649712U, 2654036126U, 1249024881U,\n      880166166U, 691800469U, 2229503665U, 1673458056U, 4032208375U, 1851778863U,\n      2563757330U, 376742205U, 1794655231U, 340247333U, 1505873033U, 396524441U,\n      879666767U, 3335579166U, 3260764261U, 3335999539U, 506221798U, 4214658741U,\n      975887814U, 2080536343U, 3360539560U, 571586418U, 138896374U, 4234352651U,\n      2737620262U, 3928362291U, 1516365296U, 38056726U, 3599462320U, 3585007266U,\n      3850961033U, 471667319U, 1536883193U, 2310166751U, 1861637689U,\n      2530999841U, 4139843801U, 2710569485U, 827578615U, 2012334720U,\n      2907369459U, 3029312804U, 2820112398U, 1965028045U, 35518606U, 2478379033U,\n      643747771U, 1924139484U, 4123405127U, 3811735531U, 3429660832U,\n      3285177704U, 1948416081U, 1311525291U, 1183517742U, 1739192232U,\n      3979815115U, 2567840007U, 4116821529U, 213304419U, 4125718577U,\n      1473064925U, 2442436592U, 1893310111U, 4195361916U, 3747569474U,\n      828465101U, 2991227658U, 750582866U, 1205170309U, 1409813056U, 678418130U,\n      1171531016U, 3821236156U, 354504587U, 4202874632U, 3882511497U,\n      1893248677U, 1903078632U, 26340130U, 2069166240U, 3657122492U, 3725758099U,\n      831344905U, 811453383U, 3447711422U, 2434543565U, 4166886888U, 3358210805U,\n      4142984013U, 2988152326U, 3527824853U, 982082992U, 2809155763U, 190157081U,\n      3340214818U, 2365432395U, 2548636180U, 2894533366U, 3474657421U,\n      2372634704U, 2845748389U, 43024175U, 2774226648U, 1987702864U, 3186502468U,\n      453610222U, 4204736567U, 1392892630U, 2471323686U, 2470534280U,\n      3541393095U, 4269885866U, 3909911300U, 759132955U, 1482612480U, 667715263U,\n      1795580598U, 2337923983U, 3390586366U, 581426223U, 1515718634U, 476374295U,\n      705213300U, 363062054U, 2084697697U, 2407503428U, 2292957699U, 2426213835U,\n      2199989172U, 1987356470U, 4026755612U, 2147252133U, 270400031U,\n      1367820199U, 2369854699U, 2844269403U, 79981964U, 624U };\n\n    static const char_T tmp_1[11] = { '/', 'A', 'n', 'g', 'l', 'e', 's', '/',\n      'r', 'e', 'f' };\n\n    /* Start for Atomic SubSystem: '<S3>/Subscribe' */\n    /* Start for MATLABSystem: '<S7>/SourceBlock' */\n    inverse_kinematics_DW.obj_a.matlabCodegenIsDeleted = true;\n    inverse_kinematics_DW.obj_a.isInitialized = 0;\n    inverse_kinematics_DW.obj_a.matlabCodegenIsDeleted = false;\n    inverse_kinematics_DW.objisempty = true;\n    inverse_kinematics_DW.obj_a.isSetupComplete = false;\n    inverse_kinematics_DW.obj_a.isInitialized = 1;\n    for (inverse_kinematics_B.i_l = 0; inverse_kinematics_B.i_l < 8;\n         inverse_kinematics_B.i_l++) {\n      inverse_kinematics_B.b_zeroDelimTopic_b[inverse_kinematics_B.i_l] =\n        tmp[inverse_kinematics_B.i_l];\n    }\n\n    inverse_kinematics_B.b_zeroDelimTopic_b[8] = '\\x00';\n    Sub_inverse_kinematics_482.createSubscriber\n      (&inverse_kinematics_B.b_zeroDelimTopic_b[0], 1);\n    inverse_kinematics_DW.obj_a.isSetupComplete = true;\n\n    /* End of Start for MATLABSystem: '<S7>/SourceBlock' */\n    /* End of Start for SubSystem: '<S3>/Subscribe' */\n\n    /* Start for Enabled SubSystem: '<Root>/Inverse Kinematics' */\n    /* Start for MATLABSystem: '<S1>/Coordinate Transformation Conversion1' */\n    inverse_kinematics_DW.obj_jv.isInitialized = 0;\n    inverse_kinematics_DW.objisempty_an = true;\n    inverse_kinematics_DW.obj_jv.isInitialized = 1;\n\n    /* End of Start for SubSystem: '<Root>/Inverse Kinematics' */\n    emxInitStruct_robotics_slmanip_(&inverse_kinematics_DW.obj);\n\n    /* Start for Enabled SubSystem: '<Root>/Inverse Kinematics' */\n    /* Start for MATLABSystem: '<S4>/MATLAB System' */\n    for (inverse_kinematics_B.i_l = 0; inverse_kinematics_B.i_l < 13;\n         inverse_kinematics_B.i_l++) {\n      inverse_kinematics_DW.obj.TreeInternal._pobj0[inverse_kinematics_B.i_l].\n        _pobj0.matlabCodegenIsDeleted = true;\n    }\n\n    for (inverse_kinematics_B.i_l = 0; inverse_kinematics_B.i_l < 7;\n         inverse_kinematics_B.i_l++) {\n      inverse_kinematics_DW.obj.IKInternal._pobj4._pobj1[inverse_kinematics_B.i_l]\n        ._pobj0.matlabCodegenIsDeleted = true;\n    }\n\n    for (inverse_kinematics_B.i_l = 0; inverse_kinematics_B.i_l < 13;\n         inverse_kinematics_B.i_l++) {\n      inverse_kinematics_DW.obj.IKInternal._pobj3[inverse_kinematics_B.i_l].\n        _pobj0.matlabCodegenIsDeleted = true;\n    }\n\n    inverse_kinematics_DW.obj.IKInternal.matlabCodegenIsDeleted = true;\n    inverse_kinematics_DW.obj.matlabCodegenIsDeleted = true;\n    inverse_kinematics_DW.method_a = 7U;\n    inverse_kinematics_DW.freq_not_empty = true;\n    inverse_kinematics_DW.state = 1144108930U;\n    inverse_kinematics_DW.state_not_empty = true;\n    inverse_kinematics_DW.state_p[0] = 362436069U;\n    inverse_kinematics_DW.state_p[1] = 521288629U;\n    inverse_kinematics_DW.state_not_empty_l = true;\n    memcpy(&inverse_kinematics_DW.state_c[0], &tmp_0[0], 625U * sizeof(uint32_T));\n    inverse_kinematics_DW.method_not_empty_f = true;\n    inverse_kinematics_DW.method = 0U;\n    inverse_kinematics_DW.state_not_empty_c = true;\n    inverse_kinematics_DW.state_pz[0] = 362436069U;\n    inverse_kinematics_DW.state_pz[1] = 521288629U;\n    inverse_kinematics_DW.state_not_empty_b = true;\n    inverse_kinematics_DW.obj.isInitialized = 0;\n    inverse_kinematics_DW.obj.matlabCodegenIsDeleted = false;\n    inverse_kinematics_DW.objisempty_a = true;\n    inverse_kinema_SystemCore_setup(&inverse_kinematics_DW.obj);\n\n    /* End of Start for MATLABSystem: '<S4>/MATLAB System' */\n    /* End of Start for SubSystem: '<Root>/Inverse Kinematics' */\n\n    /* Start for Atomic SubSystem: '<S2>/Publish' */\n    /* Start for MATLABSystem: '<S6>/SinkBlock' */\n    inverse_kinematics_DW.obj_j.matlabCodegenIsDeleted = true;\n    inverse_kinematics_DW.obj_j.isInitialized = 0;\n    inverse_kinematics_DW.obj_j.matlabCodegenIsDeleted = false;\n    inverse_kinematics_DW.objisempty_j = true;\n    inverse_kinematics_DW.obj_j.isSetupComplete = false;\n    inverse_kinematics_DW.obj_j.isInitialized = 1;\n    for (inverse_kinematics_B.i_l = 0; inverse_kinematics_B.i_l < 11;\n         inverse_kinematics_B.i_l++) {\n      inverse_kinematics_B.b_zeroDelimTopic[inverse_kinematics_B.i_l] =\n        tmp_1[inverse_kinematics_B.i_l];\n    }\n\n    inverse_kinematics_B.b_zeroDelimTopic[11] = '\\x00';\n    Pub_inverse_kinematics_487.createPublisher\n      (&inverse_kinematics_B.b_zeroDelimTopic[0], 1);\n    inverse_kinematics_DW.obj_j.isSetupComplete = true;\n\n    /* End of Start for MATLABSystem: '<S6>/SinkBlock' */\n    /* End of Start for SubSystem: '<S2>/Publish' */\n  }\n\n  /* SystemInitialize for Enabled SubSystem: '<Root>/Inverse Kinematics' */\n  /* InitializeConditions for Delay: '<S1>/Delay' */\n  inverse_kinematics_DW.Delay_DSTATE[0] =\n    inverse_kinematics_P.Delay_InitialCondition[0];\n\n  /* SystemInitialize for MATLABSystem: '<S4>/MATLAB System' incorporates:\n   *  Outport: '<S1>/Config'\n   */\n  inverse_kinematics_B.MATLABSystem_o1[0] = inverse_kinematics_P.Config_Y0;\n\n  /* InitializeConditions for Delay: '<S1>/Delay' */\n  inverse_kinematics_DW.Delay_DSTATE[1] =\n    inverse_kinematics_P.Delay_InitialCondition[1];\n\n  /* SystemInitialize for MATLABSystem: '<S4>/MATLAB System' incorporates:\n   *  Outport: '<S1>/Config'\n   */\n  inverse_kinematics_B.MATLABSystem_o1[1] = inverse_kinematics_P.Config_Y0;\n\n  /* InitializeConditions for Delay: '<S1>/Delay' */\n  inverse_kinematics_DW.Delay_DSTATE[2] =\n    inverse_kinematics_P.Delay_InitialCondition[2];\n\n  /* SystemInitialize for MATLABSystem: '<S4>/MATLAB System' incorporates:\n   *  Outport: '<S1>/Config'\n   */\n  inverse_kinematics_B.MATLABSystem_o1[2] = inverse_kinematics_P.Config_Y0;\n\n  /* InitializeConditions for Delay: '<S1>/Delay' */\n  inverse_kinematics_DW.Delay_DSTATE[3] =\n    inverse_kinematics_P.Delay_InitialCondition[3];\n\n  /* SystemInitialize for MATLABSystem: '<S4>/MATLAB System' incorporates:\n   *  Outport: '<S1>/Config'\n   */\n  inverse_kinematics_B.MATLABSystem_o1[3] = inverse_kinematics_P.Config_Y0;\n\n  /* End of SystemInitialize for SubSystem: '<Root>/Inverse Kinematics' */\n}\n\n/* Model terminate function */\nvoid inverse_kinematics_terminate(void)\n{\n  void* geometryInternal;\n  b_inverseKinematics_inverse_k_T *obj;\n  k_robotics_manip_internal_Col_T *obj_0;\n\n  /* Terminate for Atomic SubSystem: '<S3>/Subscribe' */\n  /* Terminate for MATLABSystem: '<S7>/SourceBlock' */\n  if (!inverse_kinematics_DW.obj_a.matlabCodegenIsDeleted) {\n    inverse_kinematics_DW.obj_a.matlabCodegenIsDeleted = true;\n  }\n\n  /* End of Terminate for MATLABSystem: '<S7>/SourceBlock' */\n  /* End of Terminate for SubSystem: '<S3>/Subscribe' */\n\n  /* Terminate for Enabled SubSystem: '<Root>/Inverse Kinematics' */\n  /* Terminate for MATLABSystem: '<S4>/MATLAB System' */\n  if (!inverse_kinematics_DW.obj.matlabCodegenIsDeleted) {\n    inverse_kinematics_DW.obj.matlabCodegenIsDeleted = true;\n  }\n\n  obj = &inverse_kinematics_DW.obj.IKInternal;\n  if (!obj->matlabCodegenIsDeleted) {\n    obj->matlabCodegenIsDeleted = true;\n    if (obj->isInitialized == 1) {\n      obj->isInitialized = 2;\n    }\n  }\n\n  for (int32_T b = 0; b < 13; b++) {\n    obj_0 = &inverse_kinematics_DW.obj.IKInternal._pobj3[b]._pobj0;\n    if (!obj_0->matlabCodegenIsDeleted) {\n      obj_0->matlabCodegenIsDeleted = true;\n      geometryInternal = obj_0->CollisionPrimitive;\n      collisioncodegen_destructGeometry(&geometryInternal);\n    }\n  }\n\n  for (int32_T b = 0; b < 7; b++) {\n    obj_0 = &inverse_kinematics_DW.obj.IKInternal._pobj4._pobj1[b]._pobj0;\n    if (!obj_0->matlabCodegenIsDeleted) {\n      obj_0->matlabCodegenIsDeleted = true;\n      geometryInternal = obj_0->CollisionPrimitive;\n      collisioncodegen_destructGeometry(&geometryInternal);\n    }\n  }\n\n  for (int32_T b = 0; b < 13; b++) {\n    obj_0 = &inverse_kinematics_DW.obj.TreeInternal._pobj0[b]._pobj0;\n    if (!obj_0->matlabCodegenIsDeleted) {\n      obj_0->matlabCodegenIsDeleted = true;\n      geometryInternal = obj_0->CollisionPrimitive;\n      collisioncodegen_destructGeometry(&geometryInternal);\n    }\n  }\n\n  /* End of Terminate for MATLABSystem: '<S4>/MATLAB System' */\n  /* End of Terminate for SubSystem: '<Root>/Inverse Kinematics' */\n  emxFreeStruct_robotics_slmanip_(&inverse_kinematics_DW.obj);\n\n  /* Terminate for Atomic SubSystem: '<S2>/Publish' */\n  /* Terminate for MATLABSystem: '<S6>/SinkBlock' */\n  if (!inverse_kinematics_DW.obj_j.matlabCodegenIsDeleted) {\n    inverse_kinematics_DW.obj_j.matlabCodegenIsDeleted = true;\n  }\n\n  /* End of Terminate for MATLABSystem: '<S6>/SinkBlock' */\n  /* End of Terminate for SubSystem: '<S2>/Publish' */\n}\n"},{"name":"inverse_kinematics.h","type":"header","group":"model","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * inverse_kinematics.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_inverse_kinematics_h_\n#define RTW_HEADER_inverse_kinematics_h_\n#include <string.h>\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#include \"coder_posix_time.h\"\n#include \"collisioncodegen_api.hpp\"\n#include \"slros_initialize.h\"\n#include \"inverse_kinematics_types.h\"\n\nextern \"C\" {\n\n#include \"rtGetNaN.h\"\n\n}\n  extern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\nextern \"C\" {\n\n#include \"rtGetInf.h\"\n\n}\n#include <stddef.h>\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n/* Block signals (default storage) */\nstruct B_inverse_kinematics_T {\n  real_T xi[257];\n  real_T weightMatrix[36];\n  real_T weightMatrix_m[36];\n  real_T a[36];\n  real_T Tj[36];\n  real_T obj[36];\n  real_T out[16];\n  real_T Td[16];\n  real_T T_data[16];\n  real_T T1[16];\n  real_T Tc2p[16];\n  real_T Tj_c[16];\n  real_T T1j[16];\n  real_T b[16];\n  real_T Tj_k[16];\n  real_T obj_c[16];\n  real_T in2[16];\n  real_T c_x[16];\n  real_T poslim_data[12];\n  real_T poslim_data_b[12];\n  real_T poslim_data_p[12];\n  real_T poslim_data_c[12];\n  real_T poslim_data_f[12];\n  real_T R[9];\n  real_T tempR[9];\n  real_T obj_g[9];\n  real_T y[9];\n  real_T V[9];\n  real_T b_U[9];\n  real_T T[9];\n  real_T A[9];\n  real_T A_g[9];\n  real_T e[6];\n  real_T e_m[6];\n  real_T unusedExpr[5];\n  int8_T msubspace_data[36];\n  int8_T msubspace_data_n[36];\n  int8_T msubspace_data_p[36];\n  int8_T msubspace_data_l[36];\n  int8_T msubspace_data_j[36];\n  SL_Bus_inverse_kinematics_geometry_msgs_Quaternion BusAssignment;/* '<S2>/Bus Assignment' */\n  real_T MATLABSystem_o1[4];           /* '<S4>/MATLAB System' */\n  real_T qvSolRaw[4];\n  real_T c_xSol[4];\n  real_T step_data[4];\n  real_T y_d[4];\n  real_T result_data[4];\n  SL_Bus_inverse_kinematics_geometry_msgs_Point b_varargout_2;\n  real_T v[3];\n  real_T v_g[3];\n  real_T vspecial_data[3];\n  real_T v_l[3];\n  real_T s[3];\n  real_T e_d[3];\n  real_T work[3];\n  char_T switch_expression[18];\n  char_T b_d[18];\n  int8_T b_I[16];\n  int32_T indicesUpperBoundViolation_data[4];\n  int32_T tmp_data[4];\n  creal_T v_lx;\n  creal_T u;\n  creal_T u_o;\n  creal_T dc;\n  real_T ub[2];\n  char_T expl_temp_data[14];\n  char_T b_zeroDelimTopic[12];\n  char_T b_zeroDelimTopic_b[9];\n  int8_T b_I_n[9];\n  char_T b_b[9];\n  int8_T b_I_l[9];\n  char_T partial_match_data[9];\n  char_T b_vstr[9];\n  char_T b_h[9];\n  char_T b_bn[9];\n  char_T b_da[9];\n  int8_T b_I_e[9];\n  char_T b_bj[9];\n  char_T b_j[8];\n  char_T b_f[8];\n  char_T vstr[8];\n  char_T b_a[8];\n  char_T b_ju[8];\n  char_T b_jz[8];\n  char_T b_o[8];\n  real_T expl_temp;\n  real_T expl_temp_i;\n  real_T expl_temp_o;\n  real_T expl_temp_n;\n  real_T bid;\n  real_T ndbl;\n  real_T apnd;\n  real_T cdiff;\n  real_T u0;\n  real_T u1;\n  real_T numPositions_tmp;\n  real_T tol;\n  real_T err;\n  real_T iter;\n  real_T lb;\n  real_T cc;\n  real_T cost;\n  real_T d;\n  real_T scale;\n  real_T absxk;\n  real_T t;\n  real_T xprev_idx_0;\n  real_T xprev_idx_1;\n  real_T xprev_idx_2;\n  real_T xprev_idx_3;\n  real_T bid1;\n  real_T bid2;\n  real_T sth;\n  real_T tempR_tmp;\n  real_T tempR_tmp_m;\n  real_T tempR_tmp_c;\n  real_T bid1_tmp;\n  real_T i;\n  real_T b_r;\n  real_T x;\n  real_T d_u;\n  real_T params_ErrorChangeTolerance;\n  real_T params_DampingBias;\n  real_T bid_m;\n  real_T b_m;\n  real_T pid;\n  real_T b_index;\n  real_T obj_idx_0;\n  real_T obj_idx_1;\n  real_T obj_idx_2;\n  real_T a_j;\n  real_T q;\n  real_T nrm;\n  real_T rt;\n  real_T ztest;\n  real_T smm1;\n  real_T emm1;\n  real_T sqds;\n  real_T b_h5;\n  real_T a__3;\n  real_T d_sn;\n  real_T roe;\n  real_T absa;\n  real_T absb;\n  real_T scale_c;\n  real_T ads;\n  real_T bds;\n  real_T smax;\n  real_T s_c;\n  real_T c;\n  real_T b_p;\n  real_T s_p;\n  uint32_T u32[2];\n  void* defaultCollisionObj_GeometryInt;\n  int32_T expl_temp_size[2];\n  int32_T T_size[2];\n  int8_T iv[6];\n  int8_T iv1[6];\n  int8_T iv2[6];\n  int8_T iv3[6];\n  int8_T iv4[6];\n  char_T b_af[5];\n  char_T b_e[5];\n  char_T c_vstr[5];\n  char_T b_ax[5];\n  int8_T b_ipiv[4];\n  int32_T b_jcol;\n  int32_T loop_ub;\n  int32_T iacol_tmp;\n  int32_T b_j_l;\n  int32_T nm1d2;\n  int32_T c_o;\n  int32_T b_k;\n  int32_T loop_ub_o;\n  int32_T indicesUpperBoundViolation;\n  int32_T tmp_size;\n  int32_T indicesUpperBoundViolation_size;\n  int32_T c_f;\n  int32_T b_i;\n  int32_T ix;\n  int32_T nx;\n  int32_T unnamed_idx_1;\n  int32_T b_i_i;\n  int32_T m;\n  int32_T coffset;\n  int32_T boffset;\n  int32_T aoffset;\n  int32_T kend;\n  int32_T b_k_f;\n  int32_T J;\n  int32_T step_size;\n  int32_T jointSign;\n  int32_T c_g;\n  int32_T f;\n  int32_T g;\n  int32_T i_c;\n  int32_T loop_ub_o3;\n  int32_T Jac;\n  int32_T result_data_tmp;\n  int32_T minPathLength;\n  int32_T b_i_l;\n  int32_T e_mv;\n  int32_T h;\n  int32_T j;\n  int32_T loop_ub_m;\n  int32_T i_cn;\n  int32_T loop_ub_f;\n  int32_T loop_ub_tmp;\n  int32_T newNumel;\n  int32_T i_p;\n  int32_T b_k_e;\n  int32_T i_o;\n  int32_T d_tmp;\n  int32_T b_j_h;\n  int32_T b_kk;\n  int32_T i_l;\n  int32_T ret;\n  int32_T b_kstr;\n  int32_T loop_ub_h;\n  int32_T iobj_3;\n  int32_T obj_tmp;\n  int32_T b_kstr_m;\n  int32_T loop_ub_mc;\n  int32_T i1;\n  int32_T nmatched;\n  int32_T minnanb;\n  int32_T loop_ub_h3;\n  int32_T partial_match_size_idx_1;\n  int32_T b_kstr_c;\n  int32_T loop_ub_k;\n  int32_T i2;\n  int32_T newNumel_p;\n  int32_T i_px;\n  int32_T b_k_p;\n  int32_T i3;\n  int32_T y_tmp;\n  int32_T T_tmp;\n  int32_T T_tmp_a;\n  int32_T q_j;\n  int32_T qp1;\n  int32_T qq;\n  int32_T qjj;\n  int32_T m_e;\n  int32_T b_ol;\n  int32_T qq_tmp;\n  int32_T i4;\n  int32_T aux_0_1;\n  int32_T stride_0_0;\n  int32_T stride_0_1;\n  int32_T in2_tmp;\n  int32_T jj;\n  int32_T c_b;\n  int32_T c_a;\n  int32_T a_g;\n  int32_T kAcol;\n  int32_T jA;\n  int32_T j_e;\n  int32_T c_fi;\n  int32_T ijA;\n  int32_T b_kstr_h;\n  int32_T loop_ub_e;\n  int32_T i5;\n  int32_T b_kstr_ch;\n  int32_T loop_ub_a;\n  int32_T i6;\n  int32_T d_d;\n  int32_T b_i_a;\n  int32_T newNumel_pb;\n  int32_T i_m;\n  int32_T b_i_o;\n  int32_T loop_ub_n;\n  int32_T i7;\n  int32_T i8;\n  int32_T i_lu;\n  int32_T n;\n  int32_T b_j_p;\n  int32_T b_i_p;\n  int32_T b_k_ft;\n  int32_T coffset_tmp;\n  int32_T i_i;\n  int32_T b_kstr_o;\n  int32_T i9;\n  uint32_T mti;\n  uint32_T y_k;\n  boolean_T ubOK[4];\n  boolean_T lbOK[4];\n  boolean_T ubOK_a[4];\n  boolean_T x_i[4];\n  c_robotics_core_internal_NLPS_T exitFlag;\n  c_robotics_core_internal_NLPS_T exitFlagPrev;\n  int8_T y_tmp_i[3];\n  int8_T y_tmp_o;\n  boolean_T b_varargout_1;\n  boolean_T y_m;\n  boolean_T y_c;\n  boolean_T flag;\n  boolean_T nextBodyIsParent;\n  boolean_T b_bool;\n  boolean_T params_UseErrorDamping;\n  boolean_T b_bool_f;\n  boolean_T b_bool_h;\n  boolean_T matched;\n  boolean_T b_bool_m;\n  boolean_T b_bool_a;\n  boolean_T e_k;\n  boolean_T x_p;\n  boolean_T rEQ0;\n  boolean_T apply_transform;\n  boolean_T b_bool_b;\n  boolean_T b_bool_c;\n  boolean_T d_n;\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_inverse_kinematics_T {\n  robotics_slmanip_internal_blo_T obj; /* '<S4>/MATLAB System' */\n  ros_slroscpp_internal_block_P_T obj_j;/* '<S6>/SinkBlock' */\n  ros_slroscpp_internal_block_S_T obj_a;/* '<S7>/SourceBlock' */\n  real_T Delay_DSTATE[4];              /* '<S1>/Delay' */\n  real_T freq;                         /* '<S4>/MATLAB System' */\n  uint32_T state;                      /* '<S4>/MATLAB System' */\n  uint32_T state_p[2];                 /* '<S4>/MATLAB System' */\n  uint32_T state_c[625];               /* '<S4>/MATLAB System' */\n  uint32_T method;                     /* '<S4>/MATLAB System' */\n  uint32_T method_a;                   /* '<S4>/MATLAB System' */\n  uint32_T state_pz[2];                /* '<S4>/MATLAB System' */\n  robotics_slcore_internal_bloc_T obj_jv;\n                              /* '<S1>/Coordinate Transformation Conversion1' */\n  boolean_T objisempty;                /* '<S7>/SourceBlock' */\n  boolean_T objisempty_j;              /* '<S6>/SinkBlock' */\n  boolean_T objisempty_a;              /* '<S4>/MATLAB System' */\n  boolean_T state_not_empty;           /* '<S4>/MATLAB System' */\n  boolean_T state_not_empty_b;         /* '<S4>/MATLAB System' */\n  boolean_T state_not_empty_c;         /* '<S4>/MATLAB System' */\n  boolean_T method_not_empty;          /* '<S4>/MATLAB System' */\n  boolean_T freq_not_empty;            /* '<S4>/MATLAB System' */\n  boolean_T method_not_empty_f;        /* '<S4>/MATLAB System' */\n  boolean_T state_not_empty_l;         /* '<S4>/MATLAB System' */\n  boolean_T objisempty_an;    /* '<S1>/Coordinate Transformation Conversion1' */\n};\n\n/* Parameters (default storage) */\nstruct P_inverse_kinematics_T_ {\n  SL_Bus_inverse_kinematics_geometry_msgs_Quaternion Constant_Value;/* Computed Parameter: Constant_Value\n                                                                     * Referenced by: '<S5>/Constant'\n                                                                     */\n  SL_Bus_inverse_kinematics_geometry_msgs_Point Out1_Y0;/* Computed Parameter: Out1_Y0\n                                                         * Referenced by: '<S8>/Out1'\n                                                         */\n  SL_Bus_inverse_kinematics_geometry_msgs_Point Constant_Value_b;/* Computed Parameter: Constant_Value_b\n                                                                  * Referenced by: '<S7>/Constant'\n                                                                  */\n  real_T Config_Y0;                    /* Computed Parameter: Config_Y0\n                                        * Referenced by: '<S1>/Config'\n                                        */\n  real_T Constant1_Value[6];           /* Expression: [0 0 0 1 1 1]\n                                        * Referenced by: '<S1>/Constant1'\n                                        */\n  real_T Delay_InitialCondition[4];    /* Expression: ([0 -10 0 90]*pi/180)'\n                                        * Referenced by: '<S1>/Delay'\n                                        */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_inverse_kinematics_T {\n  const char_T *errorStatus;\n};\n\n/* Block parameters (default storage) */\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern P_inverse_kinematics_T inverse_kinematics_P;\n\n#ifdef __cplusplus\n\n}\n#endif\n\n/* Block signals (default storage) */\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern struct B_inverse_kinematics_T inverse_kinematics_B;\n\n#ifdef __cplusplus\n\n}\n#endif\n\n/* Block states (default storage) */\nextern struct DW_inverse_kinematics_T inverse_kinematics_DW;\n\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  /* Model entry point functions */\n  extern void inverse_kinematics_initialize(void);\n  extern void inverse_kinematics_step(void);\n  extern void inverse_kinematics_terminate(void);\n\n#ifdef __cplusplus\n\n}\n#endif\n\n/* Real-time Model object */\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern RT_MODEL_inverse_kinematics_T *const inverse_kinematics_M;\n\n#ifdef __cplusplus\n\n}\n#endif\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'inverse_kinematics'\n * '<S1>'   : 'inverse_kinematics/Inverse Kinematics'\n * '<S2>'   : 'inverse_kinematics/Publisher'\n * '<S3>'   : 'inverse_kinematics/Subscriber'\n * '<S4>'   : 'inverse_kinematics/Inverse Kinematics/Inverse Kinematics'\n * '<S5>'   : 'inverse_kinematics/Publisher/Blank Message1'\n * '<S6>'   : 'inverse_kinematics/Publisher/Publish'\n * '<S7>'   : 'inverse_kinematics/Subscriber/Subscribe'\n * '<S8>'   : 'inverse_kinematics/Subscriber/Subscribe/Enabled Subsystem'\n */\n#endif                                 /* RTW_HEADER_inverse_kinematics_h_ */\n"},{"name":"inverse_kinematics_private.h","type":"header","group":"model","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * inverse_kinematics_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_inverse_kinematics_private_h_\n#define RTW_HEADER_inverse_kinematics_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"inverse_kinematics.h\"\n\nextern real_T rt_hypotd_snf(real_T u0, real_T u1);\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\nextern int32_T div_s32(int32_T numerator, int32_T denominator);\n\n#endif                            /* RTW_HEADER_inverse_kinematics_private_h_ */\n"},{"name":"inverse_kinematics_types.h","type":"header","group":"model","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * inverse_kinematics_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_inverse_kinematics_types_h_\n#define RTW_HEADER_inverse_kinematics_types_h_\n#include \"rtwtypes.h\"\n\n/* Model Code Variants */\n#ifndef DEFINED_TYPEDEF_FOR_SL_Bus_inverse_kinematics_geometry_msgs_Quaternion_\n#define DEFINED_TYPEDEF_FOR_SL_Bus_inverse_kinematics_geometry_msgs_Quaternion_\n\nstruct SL_Bus_inverse_kinematics_geometry_msgs_Quaternion\n{\n  real_T X;\n  real_T Y;\n  real_T Z;\n  real_T W;\n};\n\n#endif\n\n#ifndef DEFINED_TYPEDEF_FOR_SL_Bus_inverse_kinematics_geometry_msgs_Point_\n#define DEFINED_TYPEDEF_FOR_SL_Bus_inverse_kinematics_geometry_msgs_Point_\n\nstruct SL_Bus_inverse_kinematics_geometry_msgs_Point\n{\n  real_T X;\n  real_T Y;\n  real_T Z;\n};\n\n#endif\n\n#ifndef DEFINED_TYPEDEF_FOR_ikblock_info_bus_\n#define DEFINED_TYPEDEF_FOR_ikblock_info_bus_\n\nstruct ikblock_info_bus\n{\n  real_T Iterations;\n  real_T PoseErrorNorm;\n  uint16_T ExitFlag;\n  uint8_T Status;\n};\n\n#endif\n\n#ifndef DEFINED_TYPEDEF_FOR_struct_j29BDD3GtugYMsepf4x9iH_\n#define DEFINED_TYPEDEF_FOR_struct_j29BDD3GtugYMsepf4x9iH_\n\nstruct struct_j29BDD3GtugYMsepf4x9iH\n{\n  boolean_T EnforceJointLimits;\n  boolean_T AllowRandomRestart;\n  real_T MaxIterations;\n  real_T MaxTime;\n  real_T GradientTolerance;\n  real_T SolutionTolerance;\n  real_T StepTolerance;\n  real_T ErrorChangeTolerance;\n  boolean_T UseErrorDamping;\n  real_T DampingBias;\n};\n\n#endif\n\n#ifndef struct_robotics_slcore_internal_bloc_T\n#define struct_robotics_slcore_internal_bloc_T\n\nstruct robotics_slcore_internal_bloc_T\n{\n  int32_T isInitialized;\n};\n\n#endif                              /* struct_robotics_slcore_internal_bloc_T */\n\n#ifndef struct_sdAmwXbnJnEmimT0NaJRtAD_inver_T\n#define struct_sdAmwXbnJnEmimT0NaJRtAD_inver_T\n\nstruct sdAmwXbnJnEmimT0NaJRtAD_inver_T\n{\n  real_T tv_sec;\n  real_T tv_nsec;\n};\n\n#endif                              /* struct_sdAmwXbnJnEmimT0NaJRtAD_inver_T */\n\n/* Custom Type definition for MATLABSystem: '<S4>/MATLAB System' */\n#include \"coder_posix_time.h\"\n#ifndef struct_k_robotics_manip_internal_Col_T\n#define struct_k_robotics_manip_internal_Col_T\n\nstruct k_robotics_manip_internal_Col_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  void* CollisionPrimitive;\n};\n\n#endif                              /* struct_k_robotics_manip_internal_Col_T */\n\n#ifndef struct_f_robotics_manip_internal_Fas_T\n#define struct_f_robotics_manip_internal_Fas_T\n\nstruct f_robotics_manip_internal_Fas_T\n{\n  int32_T __dummy;\n};\n\n#endif                              /* struct_f_robotics_manip_internal_Fas_T */\n\n#ifndef struct_f_robotics_core_internal_Syst_T\n#define struct_f_robotics_core_internal_Syst_T\n\nstruct f_robotics_core_internal_Syst_T\n{\n  sdAmwXbnJnEmimT0NaJRtAD_inver_T StartTime;\n};\n\n#endif                              /* struct_f_robotics_core_internal_Syst_T */\n\n#ifndef struct_ros_slroscpp_internal_block_P_T\n#define struct_ros_slroscpp_internal_block_P_T\n\nstruct ros_slroscpp_internal_block_P_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n};\n\n#endif                              /* struct_ros_slroscpp_internal_block_P_T */\n\n#ifndef struct_ros_slroscpp_internal_block_S_T\n#define struct_ros_slroscpp_internal_block_S_T\n\nstruct ros_slroscpp_internal_block_S_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n};\n\n#endif                              /* struct_ros_slroscpp_internal_block_S_T */\n\n#ifndef struct_emxArray_char_T_inverse_kinem_T\n#define struct_emxArray_char_T_inverse_kinem_T\n\nstruct emxArray_char_T_inverse_kinem_T\n{\n  char_T *data;\n  int32_T *size;\n  int32_T allocatedSize;\n  int32_T numDimensions;\n  boolean_T canFreeData;\n};\n\n#endif                              /* struct_emxArray_char_T_inverse_kinem_T */\n\n#ifndef struct_emxArray_real_T_inverse_kinem_T\n#define struct_emxArray_real_T_inverse_kinem_T\n\nstruct emxArray_real_T_inverse_kinem_T\n{\n  real_T *data;\n  int32_T *size;\n  int32_T allocatedSize;\n  int32_T numDimensions;\n  boolean_T canFreeData;\n};\n\n#endif                              /* struct_emxArray_real_T_inverse_kinem_T */\n\n#ifndef struct_emxArray_unnamed_struct_inver_T\n#define struct_emxArray_unnamed_struct_inver_T\n\nstruct emxArray_unnamed_struct_inver_T\n{\n  k_robotics_manip_internal_Col_T **data;\n  int32_T *size;\n  int32_T allocatedSize;\n  int32_T numDimensions;\n  boolean_T canFreeData;\n};\n\n#endif                              /* struct_emxArray_unnamed_struct_inver_T */\n\n#ifndef struct_c_rigidBodyJoint_inverse_kine_T\n#define struct_c_rigidBodyJoint_inverse_kine_T\n\nstruct c_rigidBodyJoint_inverse_kine_T\n{\n  emxArray_char_T_inverse_kinem_T *Type;\n  real_T VelocityNumber;\n  real_T PositionNumber;\n  emxArray_real_T_inverse_kinem_T *MotionSubspace;\n  boolean_T InTree;\n  real_T JointToParentTransform[16];\n  real_T ChildToJointTransform[16];\n  emxArray_char_T_inverse_kinem_T *NameInternal;\n  emxArray_real_T_inverse_kinem_T *PositionLimitsInternal;\n  emxArray_real_T_inverse_kinem_T *HomePositionInternal;\n  real_T JointAxisInternal[3];\n};\n\n#endif                              /* struct_c_rigidBodyJoint_inverse_kine_T */\n\n#ifndef struct_emxArray_int8_T_inverse_kinem_T\n#define struct_emxArray_int8_T_inverse_kinem_T\n\nstruct emxArray_int8_T_inverse_kinem_T\n{\n  int8_T *data;\n  int32_T *size;\n  int32_T allocatedSize;\n  int32_T numDimensions;\n  boolean_T canFreeData;\n};\n\n#endif                              /* struct_emxArray_int8_T_inverse_kinem_T */\n\n#ifndef struct_emxArray_boolean_T_inverse_ki_T\n#define struct_emxArray_boolean_T_inverse_ki_T\n\nstruct emxArray_boolean_T_inverse_ki_T\n{\n  boolean_T *data;\n  int32_T *size;\n  int32_T allocatedSize;\n  int32_T numDimensions;\n  boolean_T canFreeData;\n};\n\n#endif                              /* struct_emxArray_boolean_T_inverse_ki_T */\n\n#ifndef struct_emxArray_int32_T_inverse_kine_T\n#define struct_emxArray_int32_T_inverse_kine_T\n\nstruct emxArray_int32_T_inverse_kine_T\n{\n  int32_T *data;\n  int32_T *size;\n  int32_T allocatedSize;\n  int32_T numDimensions;\n  boolean_T canFreeData;\n};\n\n#endif                              /* struct_emxArray_int32_T_inverse_kine_T */\n\n#ifndef struct_emxArray_uint32_T_inverse_kin_T\n#define struct_emxArray_uint32_T_inverse_kin_T\n\nstruct emxArray_uint32_T_inverse_kin_T\n{\n  uint32_T *data;\n  int32_T *size;\n  int32_T allocatedSize;\n  int32_T numDimensions;\n  boolean_T canFreeData;\n};\n\n#endif                              /* struct_emxArray_uint32_T_inverse_kin_T */\n\n#ifndef struct_l_robotics_manip_internal_Col_T\n#define struct_l_robotics_manip_internal_Col_T\n\nstruct l_robotics_manip_internal_Col_T\n{\n  emxArray_unnamed_struct_inver_T *CollisionGeometries;\n  real_T MaxElements;\n  real_T Size;\n  k_robotics_manip_internal_Col_T _pobj0;\n};\n\n#endif                              /* struct_l_robotics_manip_internal_Col_T */\n\n#ifndef struct_t_robotics_manip_internal_Rig_T\n#define struct_t_robotics_manip_internal_Rig_T\n\nstruct t_robotics_manip_internal_Rig_T\n{\n  real_T Index;\n  emxArray_char_T_inverse_kinem_T *NameInternal;\n  c_rigidBodyJoint_inverse_kine_T *JointInternal;\n  real_T ParentIndex;\n  real_T MassInternal;\n  real_T CenterOfMassInternal[3];\n  real_T InertiaInternal[9];\n  real_T SpatialInertia[36];\n  l_robotics_manip_internal_Col_T *CollisionsInternal;\n};\n\n#endif                              /* struct_t_robotics_manip_internal_Rig_T */\n\n#ifndef struct_v_robotics_manip_internal_Rig_T\n#define struct_v_robotics_manip_internal_Rig_T\n\nstruct v_robotics_manip_internal_Rig_T\n{\n  real_T NumBodies;\n  t_robotics_manip_internal_Rig_T Base;\n  f_robotics_manip_internal_Fas_T FastVisualizationHelper;\n  t_robotics_manip_internal_Rig_T *Bodies[6];\n  real_T NumNonFixedBodies;\n  real_T PositionNumber;\n  real_T VelocityNumber;\n  real_T PositionDoFMap[12];\n  real_T VelocityDoFMap[12];\n  t_robotics_manip_internal_Rig_T _pobj0[6];\n  l_robotics_manip_internal_Col_T _pobj1[7];\n  c_rigidBodyJoint_inverse_kine_T _pobj2[7];\n};\n\n#endif                              /* struct_v_robotics_manip_internal_Rig_T */\n\n#ifndef struct_u_robotics_manip_internal_Rig_T\n#define struct_u_robotics_manip_internal_Rig_T\n\nstruct u_robotics_manip_internal_Rig_T\n{\n  real_T NumBodies;\n  t_robotics_manip_internal_Rig_T Base;\n  real_T Gravity[3];\n  t_robotics_manip_internal_Rig_T *Bodies[6];\n  l_robotics_manip_internal_Col_T _pobj0[13];\n  c_rigidBodyJoint_inverse_kine_T _pobj1[13];\n  t_robotics_manip_internal_Rig_T _pobj2[12];\n};\n\n#endif                              /* struct_u_robotics_manip_internal_Rig_T */\n\n#ifndef struct_f_robotics_manip_internal_IKE_T\n#define struct_f_robotics_manip_internal_IKE_T\n\nstruct f_robotics_manip_internal_IKE_T\n{\n  v_robotics_manip_internal_Rig_T *Robot;\n  real_T WeightMatrix[36];\n  emxArray_real_T_inverse_kinem_T *Limits;\n  emxArray_char_T_inverse_kinem_T *BodyName;\n  real_T Tform[16];\n  emxArray_real_T_inverse_kinem_T *ErrTemp;\n  real_T CostTemp;\n  emxArray_real_T_inverse_kinem_T *GradTemp;\n};\n\n#endif                              /* struct_f_robotics_manip_internal_IKE_T */\n\n#ifndef struct_h_robotics_core_internal_Erro_T\n#define struct_h_robotics_core_internal_Erro_T\n\nstruct h_robotics_core_internal_Erro_T\n{\n  char_T Name[18];\n  boolean_T ConstraintsOn;\n  real_T SolutionTolerance;\n  boolean_T RandomRestart;\n  f_robotics_manip_internal_IKE_T *ExtraArgs;\n  real_T MaxNumIteration;\n  real_T MaxTime;\n  real_T SeedInternal[4];\n  real_T MaxTimeInternal;\n  real_T MaxNumIterationInternal;\n  real_T StepTolerance;\n  f_robotics_core_internal_Syst_T TimeObj;\n  real_T GradientTolerance;\n  real_T ErrorChangeTolerance;\n  real_T DampingBias;\n  boolean_T UseErrorDamping;\n  f_robotics_core_internal_Syst_T TimeObjInternal;\n};\n\n#endif                              /* struct_h_robotics_core_internal_Erro_T */\n\n#ifndef struct_b_inverseKinematics_inverse_k_T\n#define struct_b_inverseKinematics_inverse_k_T\n\nstruct b_inverseKinematics_inverse_k_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  h_robotics_core_internal_Erro_T *Solver;\n  emxArray_real_T_inverse_kinem_T *Limits;\n  v_robotics_manip_internal_Rig_T *RigidBodyTreeInternal;\n  f_robotics_manip_internal_IKE_T _pobj0;\n  c_rigidBodyJoint_inverse_kine_T _pobj1[12];\n  t_robotics_manip_internal_Rig_T _pobj2[6];\n  l_robotics_manip_internal_Col_T _pobj3[13];\n  v_robotics_manip_internal_Rig_T _pobj4;\n  h_robotics_core_internal_Erro_T _pobj5;\n};\n\n#endif                              /* struct_b_inverseKinematics_inverse_k_T */\n\n#ifndef struct_robotics_slmanip_internal_blo_T\n#define struct_robotics_slmanip_internal_blo_T\n\nstruct robotics_slmanip_internal_blo_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  u_robotics_manip_internal_Rig_T TreeInternal;\n  b_inverseKinematics_inverse_k_T IKInternal;\n};\n\n#endif                              /* struct_robotics_slmanip_internal_blo_T */\n\n#ifndef typedef_c_robotics_core_internal_NLPS_T\n#define typedef_c_robotics_core_internal_NLPS_T\n\ntypedef int32_T c_robotics_core_internal_NLPS_T;\n\n#endif                             /* typedef_c_robotics_core_internal_NLPS_T */\n\n#ifndef robotics_core_internal_NLPSolverExitFlags_constants\n#define robotics_core_internal_NLPSolverExitFlags_constants\n\n/* enum robotics_core_internal_NLPSolverExitFlags */\nconst c_robotics_core_internal_NLPS_T LocalMinimumFound = 1;\nconst c_robotics_core_internal_NLPS_T IterationLimitExceeded = 2;\nconst c_robotics_core_internal_NLPS_T TimeLimitExceeded = 3;\nconst c_robotics_core_internal_NLPS_T StepSizeBelowMinimum = 4;\nconst c_robotics_core_internal_NLPS_T ChangeInErrorBelowMinimum = 5;\nconst c_robotics_core_internal_NLPS_T SearchDirectionInvalid = 6;\nconst c_robotics_core_internal_NLPS_T HessianNotPositiveSemidefinite = 7;\nconst c_robotics_core_internal_NLPS_T TrustRegionRadiusBelowMinimum = 8;\n\n#endif                 /* robotics_core_internal_NLPSolverExitFlags_constants */\n\n/* Parameters (default storage) */\ntypedef struct P_inverse_kinematics_T_ P_inverse_kinematics_T;\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_inverse_kinematics_T RT_MODEL_inverse_kinematics_T;\n\n#endif                              /* RTW_HEADER_inverse_kinematics_types_h_ */\n"},{"name":"inverse_kinematics_data.cpp","type":"source","group":"data","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * inverse_kinematics_data.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"inverse_kinematics.h\"\n\n/* Block parameters (default storage) */\nP_inverse_kinematics_T inverse_kinematics_P = {\n  /* Computed Parameter: Constant_Value\n   * Referenced by: '<S5>/Constant'\n   */\n  {\n    0.0,                               /* X */\n    0.0,                               /* Y */\n    0.0,                               /* Z */\n    0.0                                /* W */\n  },\n\n  /* Computed Parameter: Out1_Y0\n   * Referenced by: '<S8>/Out1'\n   */\n  {\n    0.0,                               /* X */\n    0.0,                               /* Y */\n    0.0                                /* Z */\n  },\n\n  /* Computed Parameter: Constant_Value_b\n   * Referenced by: '<S7>/Constant'\n   */\n  {\n    0.0,                               /* X */\n    0.0,                               /* Y */\n    0.0                                /* Z */\n  },\n\n  /* Computed Parameter: Config_Y0\n   * Referenced by: '<S1>/Config'\n   */\n  0.0,\n\n  /* Expression: [0 0 0 1 1 1]\n   * Referenced by: '<S1>/Constant1'\n   */\n  { 0.0, 0.0, 0.0, 1.0, 1.0, 1.0 },\n\n  /* Expression: ([0 -10 0 90]*pi/180)'\n   * Referenced by: '<S1>/Delay'\n   */\n  { 0.0, -0.17453292519943295, 0.0, 1.5707963267948966 }\n};\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long int long_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint32_T chunks[2];\n} int64m_T;\n\ntypedef struct {\n  int64m_T re;\n  int64m_T im;\n} cint64m_T;\n\ntypedef struct {\n  uint32_T chunks[2];\n} uint64m_T;\n\ntypedef struct {\n  uint64m_T re;\n  uint64m_T im;\n} cuint64m_T;\n\ntypedef struct {\n  uint32_T chunks[3];\n} int96m_T;\n\ntypedef struct {\n  int96m_T re;\n  int96m_T im;\n} cint96m_T;\n\ntypedef struct {\n  uint32_T chunks[3];\n} uint96m_T;\n\ntypedef struct {\n  uint96m_T re;\n  uint96m_T im;\n} cuint96m_T;\n\ntypedef struct {\n  uint32_T chunks[4];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint32_T chunks[4];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint32_T chunks[5];\n} int160m_T;\n\ntypedef struct {\n  int160m_T re;\n  int160m_T im;\n} cint160m_T;\n\ntypedef struct {\n  uint32_T chunks[5];\n} uint160m_T;\n\ntypedef struct {\n  uint160m_T re;\n  uint160m_T im;\n} cuint160m_T;\n\ntypedef struct {\n  uint32_T chunks[6];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint32_T chunks[6];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint32_T chunks[7];\n} int224m_T;\n\ntypedef struct {\n  int224m_T re;\n  int224m_T im;\n} cint224m_T;\n\ntypedef struct {\n  uint32_T chunks[7];\n} uint224m_T;\n\ntypedef struct {\n  uint224m_T re;\n  uint224m_T im;\n} cuint224m_T;\n\ntypedef struct {\n  uint32_T chunks[8];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint32_T chunks[8];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\" {\n\n#include \"rtGetInf.h\"\n\n}\n#include <stddef.h>\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n#define NumBitsPerChar                 8U\n\nextern \"C\" {\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\" {\n\n#include \"rtGetNaN.h\"\n\n}\n#include <stddef.h>\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n#define NumBitsPerChar                 8U\n\nextern \"C\" {\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_defines.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_defines_h_\n#define RTW_HEADER_rt_defines_h_\n\n/*===========*\n * Constants *\n *===========*/\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n/*\n * UNUSED_PARAMETER(x)\n *   Used to specify that a function parameter (argument) is required but not\n *   accessed by the function body.\n */\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\n#else\n\n/*\n * This is the semi-ANSI standard way of indicating that an\n * unused function parameter is required.\n */\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\nextern \"C\" {\n\n#include \"rtGetNaN.h\"\n\n}\n  extern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\" {\n\n#include \"rt_nonfinite.h\"\n\n}\n#define NumBitsPerChar                 8U\n\nextern \"C\" {\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n  extern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.fltVal = value;\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                               0x7FF00000 &&\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                                (tmpVal.bitVal.words.wordL != 0) ));\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.fltVal = value;\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                               0x7FF00000 &&\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                                (tmpVal.bitVal.words.wordL != 0) ));\n          break;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\" {\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"inverse_kinematics\".\n *\n * Model version              : 4.7\n * Simulink Coder version : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Target selection: ert.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Generic->Unspecified (assume 32-bit Generic)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * rtmodel.h\n *\n * Code generation for Simulink model \"inverse_kinematics\".\n *\n * Simulink Coder version                : 9.7 (R2022a) 13-Nov-2021\n * C++ source code generated on : Sun Oct  2 23:17:33 2022\n *\n * Note that the generated code is not dependent on this header file.\n * The file is used in cojuction with the automatic build procedure.\n * It is included by the sample main executable harness\n * MATLAB/rtw/c/src/common/rt_main.c.\n *\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"inverse_kinematics.h\"\n\n/* Macros generated for backwards compatibility  */\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((void*) 0)\n#endif\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\n#define _MW_CUSTOM_RTOS_HEADER_H_\n#define MW_BASERATE_PRIORITY           40\n#define MW_BASERATE_PERIOD             0.01\n#define MW_NUMBER_SUBRATES             0\n#define MW_NUMBER_APERIODIC_TASKS      0\n#define MW_IS_CONCURRENT               0\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\n\nextern void exitFcn(int sig);\nextern void *terminateTask(void *arg);\nextern void *baseRateTask(void *arg);\nextern void *subrateTask(void *arg);\nextern pthread_t schedulerThread;\nextern pthread_t baseRateThread;\nextern pthread_t subRateThread[];\nextern sem_t stopSem;\nextern sem_t baserateTaskSem;\nextern sem_t subrateTaskSem[];\nextern int taskId[];\nextern int subratePriority[];\n\n#endif\n\n#define MW_MAX_TASKNAME                16\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 0\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE Robot Operating System (ROS)\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS ros.codertarget.internal.getExtmodeDeviceAddress(hCS)\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_TCPIP_RUNINBACKGROUND 1\n#define MW_EXTMODE_CONFIGURATION TCP/IP\n#define MW_RTOS Linux\n#define MW_RTOSBASERATETASKPRIORITY 40\n#define MW_DETECTTASKOVERRUNS 0.000000\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_PACKAGING_MAINTAINERNAME ROS User\n#define MW_PACKAGING_MAINTAINEREMAIL rosuser@test.com\n#define MW_PACKAGING_LICENSE BSD\n#define MW_PACKAGING_VERSION 1.0.0\n#define MW_BOARDPARAMETERS_DEVICEADDRESS 127.0.0.1\n#define MW_BOARDPARAMETERS_USERNAME alessandrini\n#define MW_RUNTIME_BUILDACTION 0\n#define MW_ROS_INSTALL /opt/ros/noetic\n#define MW_ROS_CATKINWS /home/alessandrini/Documents/Robot/eden_ws\n#define MW_ROS_REMOTEBUILD 1\n#define MW_ROS_GENERATEROSCONTROL 0\n#define MW_ROS_ROSTIMESTEPPING 0\n#define MW_ROS_ROSTIMENOTIFICATION 0\n#define MW_ROS_STEPNOTIFY /step_notify\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"ccd_ccd.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/shared/robotics/externalDependency/libccd/src","tag":"","groupDisplay":"Other files","code":"/***\n * Copyright (C) 2019 The MathWorks, Inc.\n * MathWorks-specific modifications have been made to the original source. \n */\n\n/***\n * libccd\n * ---------------------------------\n * Copyright (c)2012 Daniel Fiser <danfis@danfis.cz>\n *\n *\n *  This file is part of libccd.\n *\n *  Distributed under the OSI-approved BSD License (the \"License\");\n *  see accompanying file BDS-LICENSE for details or see\n *  <http://www.opensource.org/licenses/bsd-license.php>.\n *\n *  This software is distributed WITHOUT ANY WARRANTY; without even the\n *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *  See the License for more information.\n */\n\n\n#include <stdio.h>\n#include <float.h>\n\n#ifdef BUILDING_LIBCCD_IN_TMW\n#include <ccd/ccd_ccd.h>\n#include <ccd/ccd_vec3.h>\n#include <ccd/ccd_polytope.h>\n#else\n#include <ccd_ccd.h>\n#include <ccd_vec3.h>\n#include <ccd_polytope.h>\n#endif\n\n#include \"ccd_alloc.h\"\n#include \"ccd_dbg.h\"\n\n\n/** Performs GJK algorithm. Returns 0 if intersection was found and simplex\n *  is filled with resulting polytope. */\nint __ccdGJK(const void *obj1, const void *obj2,\n                    const ccd_t *ccd, ccd_simplex_t *simplex);\n\n/** Performs GJK+EPA algorithm. Returns 0 if intersection was found and\n *  pt is filled with resulting polytope and nearest with pointer to\n *  nearest element (vertex, edge, face) of polytope to origin. */\nstatic int __ccdGJKEPA(const void *obj1, const void *obj2,\n                       const ccd_t *ccd,\n                       ccd_pt_t *pt, ccd_pt_el_t **nearest);\n\n\n/** Returns true if simplex contains origin.\n *  This function also alteres simplex and dir according to further\n *  processing of GJK algorithm. */\nstatic int doSimplex(ccd_simplex_t *simplex, ccd_vec3_t *dir);\nstatic int doSimplex2(ccd_simplex_t *simplex, ccd_vec3_t *dir);\nstatic int doSimplex3(ccd_simplex_t *simplex, ccd_vec3_t *dir);\nstatic int doSimplex4(ccd_simplex_t *simplex, ccd_vec3_t *dir);\n\n/** d = a x b x c */\n_ccd_inline void tripleCross(const ccd_vec3_t *a, const ccd_vec3_t *b,\n                             const ccd_vec3_t *c, ccd_vec3_t *d);\n\n\n/** Transforms simplex to polytope. It is assumed that simplex has 4\n *  vertices. */\nstatic int simplexToPolytope4(const void *obj1, const void *obj2,\n                              const ccd_t *ccd,\n                              ccd_simplex_t *simplex,\n                              ccd_pt_t *pt, ccd_pt_el_t **nearest);\n\n/** Transforms simplex to polytope, three vertices required */\nstatic int simplexToPolytope3(const void *obj1, const void *obj2,\n                              const ccd_t *ccd,\n                              const ccd_simplex_t *simplex,\n                              ccd_pt_t *pt, ccd_pt_el_t **nearest);\n\n/** Transforms simplex to polytope, two vertices required */\nstatic int simplexToPolytope2(const void *obj1, const void *obj2,\n                              const ccd_t *ccd,\n                              const ccd_simplex_t *simplex,\n                              ccd_pt_t *pt, ccd_pt_el_t **nearest);\n\n/** Expands polytope using new vertex v.\n *  Return 0 on success, -2 on memory allocation failure.*/\nstatic int expandPolytope(ccd_pt_t *pt, ccd_pt_el_t *el,\n                          const ccd_support_t *newv);\n\n/** Finds next support point (at stores it in out argument).\n *  Returns 0 on success, -1 otherwise */\nstatic int nextSupport(const void *obj1, const void *obj2, const ccd_t *ccd,\n                       const ccd_pt_el_t *el,\n                       ccd_support_t *out);\n\n\n\nvoid ccdFirstDirDefault(const void *o1, const void *o2, ccd_vec3_t *dir)\n{\n    (void)o1; (void)o2; //C4100 in MSVC and -Wunused-value in Clang\n    ccdVec3Set(dir, CCD_ONE, CCD_ZERO, CCD_ZERO);\n}\n\nvoid __ccdSupport(const void *obj1, const void *obj2,\n                  const ccd_vec3_t *_dir, const ccd_t *ccd,\n                  ccd_support_t *supp)\n{\n    ccd_vec3_t dir;\n\n    ccdVec3Copy(&dir, _dir);\n\n    ccd->support1(obj1, &dir, &supp->v1);\n\n    ccdVec3Scale(&dir, -CCD_ONE);\n    ccd->support2(obj2, &dir, &supp->v2);\n\n    ccdVec3Sub2(&supp->v, &supp->v1, &supp->v2);\n}\n\nint ccdGJKIntersect(const void *obj1, const void *obj2, const ccd_t *ccd)\n{\n    ccd_simplex_t simplex;\n    return __ccdGJK(obj1, obj2, ccd, &simplex) == 0;\n}\n\nint ccdGJKSeparate(const void *obj1, const void *obj2, const ccd_t *ccd,\n                   ccd_vec3_t *sep)\n{\n    ccd_pt_t polytope;\n    ccd_pt_el_t *nearest;\n    int ret;\n\n    ccdPtInit(&polytope);\n\n    ret = __ccdGJKEPA(obj1, obj2, ccd, &polytope, &nearest);\n\n    // set separation vector\n    if (nearest)\n        ccdVec3Copy(sep, &nearest->witness);\n\n    ccdPtDestroy(&polytope);\n\n    return ret;\n}\n\n\nstatic int penEPAPosCmp(const void *a, const void *b)\n{\n    ccd_pt_vertex_t *v1, *v2;\n    v1 = *(ccd_pt_vertex_t **)a;\n    v2 = *(ccd_pt_vertex_t **)b;\n\n    if (ccdEq(v1->dist, v2->dist)){\n        return 0;\n    }else if (v1->dist < v2->dist){\n        return -1;\n    }else{\n        return 1;\n    }\n}\n\nstatic int penEPAPos(const ccd_pt_t *pt, const ccd_pt_el_t *nearest,\n                     ccd_vec3_t *pos)\n{\n    (void)nearest;//C4100 in MSVC and -Wunused-value in Clang\n    ccd_pt_vertex_t *v;\n    ccd_pt_vertex_t **vs;\n    size_t i, len;\n    ccd_real_t scale;\n\n    // compute median\n    len = 0;\n    ccdListForEachEntry(&pt->vertices, v, ccd_pt_vertex_t, list){\n        len++;\n    }\n\n    vs = CCD_ALLOC_ARR(ccd_pt_vertex_t *, len);\n    if (vs == NULL)\n        return -1;\n\n    i = 0;\n    ccdListForEachEntry(&pt->vertices, v, ccd_pt_vertex_t, list){\n        vs[i++] = v;\n    }\n\n    qsort(vs, len, sizeof(ccd_pt_vertex_t *), penEPAPosCmp);\n\n    ccdVec3Set(pos, CCD_ZERO, CCD_ZERO, CCD_ZERO);\n    scale = CCD_ZERO;\n    if (len % 2 == 1)\n        len++;\n\n    for (i = 0; i < len / 2; i++){\n        ccdVec3Add(pos, &vs[i]->v.v1);\n        ccdVec3Add(pos, &vs[i]->v.v2);\n        scale += CCD_REAL(2.);\n    }\n    ccdVec3Scale(pos, CCD_ONE / scale);\n\n    free(vs);\n\n    return 0;\n}\n\nint ccdGJKPenetration(const void *obj1, const void *obj2, const ccd_t *ccd,\n                      ccd_real_t *depth, ccd_vec3_t *dir, ccd_vec3_t *pos)\n{\n    ccd_pt_t polytope;\n    ccd_pt_el_t *nearest;\n    int ret;\n\n    ccdPtInit(&polytope);\n\n    ret = __ccdGJKEPA(obj1, obj2, ccd, &polytope, &nearest);\n\n    // set separation vector\n    if (ret == 0 && nearest){\n        // compute depth of penetration\n        *depth = CCD_SQRT(nearest->dist);\n\n        // store normalized direction vector\n        ccdVec3Copy(dir, &nearest->witness);\n        ccdVec3Normalize(dir);\n\n        // compute position\n        if (penEPAPos(&polytope, nearest, pos) != 0){\n            ccdPtDestroy(&polytope);\n            return -2;\n        }\n    }\n\n    ccdPtDestroy(&polytope);\n\n    return ret;\n}\n\n\nint __ccdGJK(const void *obj1, const void *obj2,\n                    const ccd_t *ccd, ccd_simplex_t *simplex)\n{\n    unsigned long iterations;\n    ccd_vec3_t dir; // direction vector\n    ccd_support_t last; // last support point\n    int do_simplex_res;\n\n    // initialize simplex struct\n    ccdSimplexInit(simplex);\n\n    // get first direction\n    ccd->first_dir(obj1, obj2, &dir);\n    // get first support point\n    __ccdSupport(obj1, obj2, &dir, ccd, &last);\n    // and add this point to simplex as last one\n    ccdSimplexAdd(simplex, &last);\n\n    // set up direction vector to as (O - last) which is exactly -last\n    ccdVec3Copy(&dir, &last.v);\n    ccdVec3Scale(&dir, -CCD_ONE);\n\n    // start iterations\n    for (iterations = 0UL; iterations < ccd->max_iterations; ++iterations) {\n        // obtain support point\n        __ccdSupport(obj1, obj2, &dir, ccd, &last);\n\n        // check if farthest point in Minkowski difference in direction dir\n        // isn't somewhere before origin (the test on negative dot product)\n        // - because if it is, objects are not intersecting at all.\n        if (ccdVec3Dot(&last.v, &dir) < CCD_ZERO){\n            return -1; // intersection not found\n        }\n\n        // add last support vector to simplex\n        ccdSimplexAdd(simplex, &last);\n\n        // if doSimplex returns 1 if objects intersect, -1 if objects don't\n        // intersect and 0 if algorithm should continue\n        do_simplex_res = doSimplex(simplex, &dir);\n        if (do_simplex_res == 1){\n            return 0; // intersection found\n        }else if (do_simplex_res == -1){\n            return -1; // intersection not found\n        }\n\n        if (ccdIsZero(ccdVec3Len2(&dir))){\n            return -1; // intersection not found\n        }\n    }\n\n    // intersection wasn't found\n    return -1;\n}\n\nstatic int __ccdGJKEPA(const void *obj1, const void *obj2,\n                       const ccd_t *ccd,\n                       ccd_pt_t *polytope, ccd_pt_el_t **nearest)\n{\n    ccd_simplex_t simplex;\n    ccd_support_t supp; // support point\n    int ret, size;\n\n    *nearest = NULL;\n\n    // run GJK and obtain terminal simplex\n    ret = __ccdGJK(obj1, obj2, ccd, &simplex);\n    if (ret != 0)\n        return -1;\n\n    // transform simplex to polytope - simplex won't be used anymore\n    size = ccdSimplexSize(&simplex);\n    if (size == 4){\n        ret = simplexToPolytope4(obj1, obj2, ccd, &simplex, polytope, nearest);\n    }else if (size == 3){\n        ret = simplexToPolytope3(obj1, obj2, ccd, &simplex, polytope, nearest);\n    }else{ // size == 2\n        ret = simplexToPolytope2(obj1, obj2, ccd, &simplex, polytope, nearest);\n    }\n\n    if (ret == -1){\n        // touching contact\n        return 0;\n    }else if (ret == -2){\n        // failed memory allocation\n        return -2;\n    }\n\n\n    while (1){\n        // get triangle nearest to origin\n        *nearest = ccdPtNearest(polytope);\n\n        // get next support point\n        if (nextSupport(obj1, obj2, ccd, *nearest, &supp) != 0)\n            break;\n\n        // expand nearest triangle using new point - supp\n        if (expandPolytope(polytope, *nearest, &supp) != 0)\n            return -2;\n    }\n\n    return 0;\n}\n\n\n\nstatic int doSimplex2(ccd_simplex_t *simplex, ccd_vec3_t *dir)\n{\n    const ccd_support_t *A, *B;\n    ccd_vec3_t AB, AO, tmp;\n    ccd_real_t dot;\n\n    // get last added as A\n    A = ccdSimplexLast(simplex);\n    // get the other point\n    B = ccdSimplexPoint(simplex, 0);\n    // compute AB oriented segment\n    ccdVec3Sub2(&AB, &B->v, &A->v);\n    // compute AO vector\n    ccdVec3Copy(&AO, &A->v);\n    ccdVec3Scale(&AO, -CCD_ONE);\n\n    // dot product AB . AO\n    dot = ccdVec3Dot(&AB, &AO);\n\n    // check if origin doesn't lie on AB segment\n    ccdVec3Cross(&tmp, &AB, &AO);\n    if (ccdIsZero(ccdVec3Len2(&tmp)) && dot > CCD_ZERO){\n        return 1;\n    }\n\n    // check if origin is in area where AB segment is\n    if (ccdIsZero(dot) || dot < CCD_ZERO){\n        // origin is in outside are of A\n        ccdSimplexSet(simplex, 0, A);\n        ccdSimplexSetSize(simplex, 1);\n        ccdVec3Copy(dir, &AO);\n    }else{\n        // origin is in area where AB segment is\n\n        // keep simplex untouched and set direction to\n        // AB x AO x AB\n        tripleCross(&AB, &AO, &AB, dir);\n    }\n\n    return 0;\n}\n\nstatic int doSimplex3(ccd_simplex_t *simplex, ccd_vec3_t *dir)\n{\n    const ccd_support_t *A, *B, *C;\n    ccd_vec3_t AO, AB, AC, ABC, tmp;\n    ccd_real_t dot, dist;\n\n    // get last added as A\n    A = ccdSimplexLast(simplex);\n    // get the other points\n    B = ccdSimplexPoint(simplex, 1);\n    C = ccdSimplexPoint(simplex, 0);\n\n    // check touching contact\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &B->v, &C->v, NULL);\n\n    // MathWorks specific comment:\n    // So here is the issue: when libccd compiled with single precision, ccdIsZero uses FLT_EPSILON as the tolerance threshold (around 1.19E-7), and\n    // the variable 'dist' here is actually dist squared. So if the absolute value of the actual distance is smaller than 0.001, this 'dist' variable\n    // will fall below the tolerance threshold, as a result, the simplex will be recognized as containing the origin and the two objects will be\n    // considered touching each other. I feel here ccdIsZero(CCD_SQRT(dist)) might be more appropriate, but the author might have more considerations\n    // on numerical stability, and this pattern has been used throughout the libccd source code, so I tend to not change it.\n    // Compiling libccd with double precission will bring the minimal detectable separation distance down to below 1E-6, at the cost of slower speed\n    if (ccdIsZero(dist)){\n        return 1;\n    }\n\n    // check if triangle is really triangle (has area > 0)\n    // if not simplex can't be expanded and thus no itersection is found\n    if (ccdVec3Eq(&A->v, &B->v) || ccdVec3Eq(&A->v, &C->v)){\n        return -1;\n    }\n\n    // compute AO vector\n    ccdVec3Copy(&AO, &A->v);\n    ccdVec3Scale(&AO, -CCD_ONE);\n\n    // compute AB and AC segments and ABC vector (perpendircular to triangle)\n    ccdVec3Sub2(&AB, &B->v, &A->v);\n    ccdVec3Sub2(&AC, &C->v, &A->v);\n    ccdVec3Cross(&ABC, &AB, &AC);\n\n    ccdVec3Cross(&tmp, &ABC, &AC);\n    dot = ccdVec3Dot(&tmp, &AO);\n    if (ccdIsZero(dot) || dot > CCD_ZERO){\n        dot = ccdVec3Dot(&AC, &AO);\n        if (ccdIsZero(dot) || dot > CCD_ZERO){\n            // C is already in place\n            ccdSimplexSet(simplex, 1, A);\n            ccdSimplexSetSize(simplex, 2);\n            tripleCross(&AC, &AO, &AC, dir);\n        }else{\nccd_do_simplex3_45:\n            dot = ccdVec3Dot(&AB, &AO);\n            if (ccdIsZero(dot) || dot > CCD_ZERO){\n                ccdSimplexSet(simplex, 0, B);\n                ccdSimplexSet(simplex, 1, A);\n                ccdSimplexSetSize(simplex, 2);\n                tripleCross(&AB, &AO, &AB, dir);\n            }else{\n                ccdSimplexSet(simplex, 0, A);\n                ccdSimplexSetSize(simplex, 1);\n                ccdVec3Copy(dir, &AO);\n            }\n        }\n    }else{\n        ccdVec3Cross(&tmp, &AB, &ABC);\n        dot = ccdVec3Dot(&tmp, &AO);\n        if (ccdIsZero(dot) || dot > CCD_ZERO){\n            goto ccd_do_simplex3_45;\n        }else{\n            dot = ccdVec3Dot(&ABC, &AO);\n            if (ccdIsZero(dot) || dot > CCD_ZERO){\n                ccdVec3Copy(dir, &ABC);\n            }else{\n                ccd_support_t Ctmp;\n                ccdSupportCopy(&Ctmp, C);\n                ccdSimplexSet(simplex, 0, B);\n                ccdSimplexSet(simplex, 1, &Ctmp);\n\n                ccdVec3Copy(dir, &ABC);\n                ccdVec3Scale(dir, -CCD_ONE);\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int doSimplex4(ccd_simplex_t *simplex, ccd_vec3_t *dir)\n{\n    const ccd_support_t *A, *B, *C, *D;\n    ccd_vec3_t AO, AB, AC, AD, ABC, ACD, ADB;\n    int B_on_ACD, C_on_ADB, D_on_ABC;\n    int AB_O, AC_O, AD_O;\n    ccd_real_t dist;\n\n    // get last added as A\n    A = ccdSimplexLast(simplex);\n    // get the other points\n    B = ccdSimplexPoint(simplex, 2);\n    C = ccdSimplexPoint(simplex, 1);\n    D = ccdSimplexPoint(simplex, 0);\n\n    // check if tetrahedron is really tetrahedron (has volume > 0)\n    // if it is not simplex can't be expanded and thus no intersection is\n    // found\n    dist = ccdVec3PointTriDist2(&A->v, &B->v, &C->v, &D->v, NULL);\n    if (ccdIsZero(dist)){\n        return -1;\n    }\n\n    // check if origin lies on some of tetrahedron's face - if so objects\n    // intersect\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &B->v, &C->v, NULL);\n    if (ccdIsZero(dist))\n        return 1;\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &C->v, &D->v, NULL);\n    if (ccdIsZero(dist))\n        return 1;\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &A->v, &B->v, &D->v, NULL);\n    if (ccdIsZero(dist))\n        return 1;\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &B->v, &C->v, &D->v, NULL);\n    if (ccdIsZero(dist))\n        return 1;\n\n    // compute AO, AB, AC, AD segments and ABC, ACD, ADB normal vectors\n    ccdVec3Copy(&AO, &A->v);\n    ccdVec3Scale(&AO, -CCD_ONE);\n    ccdVec3Sub2(&AB, &B->v, &A->v);\n    ccdVec3Sub2(&AC, &C->v, &A->v);\n    ccdVec3Sub2(&AD, &D->v, &A->v);\n    ccdVec3Cross(&ABC, &AB, &AC);\n    ccdVec3Cross(&ACD, &AC, &AD);\n    ccdVec3Cross(&ADB, &AD, &AB);\n\n    // side (positive or negative) of B, C, D relative to planes ACD, ADB\n    // and ABC respectively\n    B_on_ACD = ccdSign(ccdVec3Dot(&ACD, &AB));\n    C_on_ADB = ccdSign(ccdVec3Dot(&ADB, &AC));\n    D_on_ABC = ccdSign(ccdVec3Dot(&ABC, &AD));\n\n    // whether origin is on same side of ACD, ADB, ABC as B, C, D\n    // respectively\n    AB_O = ccdSign(ccdVec3Dot(&ACD, &AO)) == B_on_ACD;\n    AC_O = ccdSign(ccdVec3Dot(&ADB, &AO)) == C_on_ADB;\n    AD_O = ccdSign(ccdVec3Dot(&ABC, &AO)) == D_on_ABC;\n\n    if (AB_O && AC_O && AD_O){\n        // origin is in tetrahedron\n        return 1;\n\n    // rearrange simplex to triangle and call doSimplex3()\n    }else if (!AB_O){\n        // B is farthest from the origin among all of the tetrahedron's\n        // points, so remove it from the list and go on with the triangle\n        // case\n\n        // D and C are in place\n        ccdSimplexSet(simplex, 2, A);\n        ccdSimplexSetSize(simplex, 3);\n    }else if (!AC_O){\n        // C is farthest\n        ccdSimplexSet(simplex, 1, D);\n        ccdSimplexSet(simplex, 0, B);\n        ccdSimplexSet(simplex, 2, A);\n        ccdSimplexSetSize(simplex, 3);\n    }else{ // (!AD_O)\n        ccdSimplexSet(simplex, 0, C);\n        ccdSimplexSet(simplex, 1, B);\n        ccdSimplexSet(simplex, 2, A);\n        ccdSimplexSetSize(simplex, 3);\n    }\n\n    return doSimplex3(simplex, dir);\n}\n\nstatic int doSimplex(ccd_simplex_t *simplex, ccd_vec3_t *dir)\n{\n    if (ccdSimplexSize(simplex) == 2){\n        // simplex contains segment only one segment\n        return doSimplex2(simplex, dir);\n    }else if (ccdSimplexSize(simplex) == 3){\n        // simplex contains triangle\n        return doSimplex3(simplex, dir);\n    }else{ // ccdSimplexSize(simplex) == 4\n        // tetrahedron - this is the only shape which can encapsule origin\n        // so doSimplex4() also contains test on it\n        return doSimplex4(simplex, dir);\n    }\n}\n\n\n_ccd_inline void tripleCross(const ccd_vec3_t *a, const ccd_vec3_t *b,\n                             const ccd_vec3_t *c, ccd_vec3_t *d)\n{\n    ccd_vec3_t e;\n    ccdVec3Cross(&e, a, b);\n    ccdVec3Cross(d, &e, c);\n}\n\n\n\n/** Transforms simplex to polytope. It is assumed that simplex has 4\n *  vertices! */\nstatic int simplexToPolytope4(const void *obj1, const void *obj2,\n                              const ccd_t *ccd,\n                              ccd_simplex_t *simplex,\n                              ccd_pt_t *pt, ccd_pt_el_t **nearest)\n{\n    const ccd_support_t *a, *b, *c, *d;\n    int use_polytope3;\n    ccd_real_t dist;\n    ccd_pt_vertex_t *v[4];\n    ccd_pt_edge_t *e[6];\n    int i;\n\n    a = ccdSimplexPoint(simplex, 0);\n    b = ccdSimplexPoint(simplex, 1);\n    c = ccdSimplexPoint(simplex, 2);\n    d = ccdSimplexPoint(simplex, 3);\n\n    // check if origin lies on some of tetrahedron's face - if so use\n    // simplexToPolytope3()\n    use_polytope3 = 0;\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &b->v, &c->v, NULL);\n    if (ccdIsZero(dist)){\n        use_polytope3 = 1;\n    }\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &c->v, &d->v, NULL);\n    if (ccdIsZero(dist)){\n        use_polytope3 = 1;\n        ccdSimplexSet(simplex, 1, c);\n        ccdSimplexSet(simplex, 2, d);\n    }\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &a->v, &b->v, &d->v, NULL);\n    if (ccdIsZero(dist)){\n        use_polytope3 = 1;\n        ccdSimplexSet(simplex, 2, d);\n    }\n    dist = ccdVec3PointTriDist2(ccd_vec3_origin, &b->v, &c->v, &d->v, NULL);\n    if (ccdIsZero(dist)){\n        use_polytope3 = 1;\n        ccdSimplexSet(simplex, 0, b);\n        ccdSimplexSet(simplex, 1, c);\n        ccdSimplexSet(simplex, 2, d);\n    }\n\n    if (use_polytope3){\n        ccdSimplexSetSize(simplex, 3);\n        return simplexToPolytope3(obj1, obj2, ccd, simplex, pt, nearest);\n    }\n\n    // no touching contact - simply create tetrahedron\n    for (i = 0; i < 4; i++){\n        v[i] = ccdPtAddVertex(pt, ccdSimplexPoint(simplex, i));\n    }\n    \n    e[0] = ccdPtAddEdge(pt, v[0], v[1]);\n    e[1] = ccdPtAddEdge(pt, v[1], v[2]);\n    e[2] = ccdPtAddEdge(pt, v[2], v[0]);\n    e[3] = ccdPtAddEdge(pt, v[3], v[0]);\n    e[4] = ccdPtAddEdge(pt, v[3], v[1]);\n    e[5] = ccdPtAddEdge(pt, v[3], v[2]);\n\n    // ccdPtAdd*() functions return NULL either if the memory allocation\n    // failed of if any of the input pointers are NULL, so the bad\n    // allocation can be checked by the last calls of ccdPtAddFace()\n    // because the rest of the bad allocations eventually \"bubble up\" here\n    if (ccdPtAddFace(pt, e[0], e[1], e[2]) == NULL\n            || ccdPtAddFace(pt, e[3], e[4], e[0]) == NULL\n            || ccdPtAddFace(pt, e[4], e[5], e[1]) == NULL\n            || ccdPtAddFace(pt, e[5], e[3], e[2]) == NULL){\n        return -2;\n    }\n\n    return 0;\n}\n\n/** Transforms simplex to polytope, three vertices required */\nstatic int simplexToPolytope3(const void *obj1, const void *obj2,\n                              const ccd_t *ccd,\n                              const ccd_simplex_t *simplex,\n                              ccd_pt_t *pt, ccd_pt_el_t **nearest)\n{\n    const ccd_support_t *a, *b, *c;\n    ccd_support_t d, d2;\n    ccd_vec3_t ab, ac, dir;\n    ccd_pt_vertex_t *v[5];\n    ccd_pt_edge_t *e[9];\n    ccd_real_t dist, dist2;\n\n    *nearest = NULL;\n\n    a = ccdSimplexPoint(simplex, 0);\n    b = ccdSimplexPoint(simplex, 1);\n    c = ccdSimplexPoint(simplex, 2);\n\n    // If only one triangle left from previous GJK run origin lies on this\n    // triangle. So it is necessary to expand triangle into two\n    // tetrahedrons connected with base (which is exactly abc triangle).\n\n    // get next support point in direction of normal of triangle\n    ccdVec3Sub2(&ab, &b->v, &a->v);\n    ccdVec3Sub2(&ac, &c->v, &a->v);\n    ccdVec3Cross(&dir, &ab, &ac);\n    __ccdSupport(obj1, obj2, &dir, ccd, &d);\n    dist = ccdVec3PointTriDist2(&d.v, &a->v, &b->v, &c->v, NULL);\n\n    // and second one take in opposite direction\n    ccdVec3Scale(&dir, -CCD_ONE);\n    __ccdSupport(obj1, obj2, &dir, ccd, &d2);\n    dist2 = ccdVec3PointTriDist2(&d2.v, &a->v, &b->v, &c->v, NULL);\n\n    // check if face isn't already on edge of minkowski sum and thus we\n    // have touching contact\n    if (ccdIsZero(dist) || ccdIsZero(dist2)){\n        v[0] = ccdPtAddVertex(pt, a);\n        v[1] = ccdPtAddVertex(pt, b);\n        v[2] = ccdPtAddVertex(pt, c);\n        e[0] = ccdPtAddEdge(pt, v[0], v[1]);\n        e[1] = ccdPtAddEdge(pt, v[1], v[2]);\n        e[2] = ccdPtAddEdge(pt, v[2], v[0]);\n        *nearest = (ccd_pt_el_t *)ccdPtAddFace(pt, e[0], e[1], e[2]);\n        if (*nearest == NULL)\n            return -2;\n\n        return -1;\n    }\n\n    // form polyhedron\n    v[0] = ccdPtAddVertex(pt, a);\n    v[1] = ccdPtAddVertex(pt, b);\n    v[2] = ccdPtAddVertex(pt, c);\n    v[3] = ccdPtAddVertex(pt, &d);\n    v[4] = ccdPtAddVertex(pt, &d2);\n\n    e[0] = ccdPtAddEdge(pt, v[0], v[1]);\n    e[1] = ccdPtAddEdge(pt, v[1], v[2]);\n    e[2] = ccdPtAddEdge(pt, v[2], v[0]);\n\n    e[3] = ccdPtAddEdge(pt, v[3], v[0]);\n    e[4] = ccdPtAddEdge(pt, v[3], v[1]);\n    e[5] = ccdPtAddEdge(pt, v[3], v[2]);\n\n    e[6] = ccdPtAddEdge(pt, v[4], v[0]);\n    e[7] = ccdPtAddEdge(pt, v[4], v[1]);\n    e[8] = ccdPtAddEdge(pt, v[4], v[2]);\n\n    if (ccdPtAddFace(pt, e[3], e[4], e[0]) == NULL\n            || ccdPtAddFace(pt, e[4], e[5], e[1]) == NULL\n            || ccdPtAddFace(pt, e[5], e[3], e[2]) == NULL\n\n            || ccdPtAddFace(pt, e[6], e[7], e[0]) == NULL\n            || ccdPtAddFace(pt, e[7], e[8], e[1]) == NULL\n            || ccdPtAddFace(pt, e[8], e[6], e[2]) == NULL){\n        return -2;\n    }\n\n    return 0;\n}\n\n/** Transforms simplex to polytope, two vertices required */\nstatic int simplexToPolytope2(const void *obj1, const void *obj2,\n                              const ccd_t *ccd,\n                              const ccd_simplex_t *simplex,\n                              ccd_pt_t *pt, ccd_pt_el_t **nearest)\n{\n    const ccd_support_t *a, *b;\n    ccd_vec3_t ab, ac, dir;\n    ccd_support_t supp[4];\n    ccd_pt_vertex_t *v[6];\n    ccd_pt_edge_t *e[12];\n    size_t i;\n    int found;\n\n    a = ccdSimplexPoint(simplex, 0);\n    b = ccdSimplexPoint(simplex, 1);\n\n    // This situation is a bit tricky. If only one segment comes from\n    // previous run of GJK - it means that either this segment is on\n    // minkowski edge (and thus we have touch contact) or it it isn't and\n    // therefore segment is somewhere *inside* minkowski sum and it *must*\n    // be possible to fully enclose this segment with polyhedron formed by\n    // at least 8 triangle faces.\n\n    // get first support point (any)\n    found = 0;\n    for (i = 0; i < ccd_points_on_sphere_len; i++){\n        __ccdSupport(obj1, obj2, &ccd_points_on_sphere[i], ccd, &supp[0]);\n        if (!ccdVec3Eq(&a->v, &supp[0].v) && !ccdVec3Eq(&b->v, &supp[0].v)){\n            found = 1;\n            break;\n        }\n    }\n    if (!found)\n        goto simplexToPolytope2_touching_contact;\n\n    // get second support point in opposite direction than supp[0]\n    ccdVec3Copy(&dir, &supp[0].v);\n    ccdVec3Scale(&dir, -CCD_ONE);\n    __ccdSupport(obj1, obj2, &dir, ccd, &supp[1]);\n    if (ccdVec3Eq(&a->v, &supp[1].v) || ccdVec3Eq(&b->v, &supp[1].v))\n        goto simplexToPolytope2_touching_contact;\n\n    // next will be in direction of normal of triangle a,supp[0],supp[1]\n    ccdVec3Sub2(&ab, &supp[0].v, &a->v);\n    ccdVec3Sub2(&ac, &supp[1].v, &a->v);\n    ccdVec3Cross(&dir, &ab, &ac);\n    __ccdSupport(obj1, obj2, &dir, ccd, &supp[2]);\n    if (ccdVec3Eq(&a->v, &supp[2].v) || ccdVec3Eq(&b->v, &supp[2].v))\n        goto simplexToPolytope2_touching_contact;\n\n    // and last one will be in opposite direction\n    ccdVec3Scale(&dir, -CCD_ONE);\n    __ccdSupport(obj1, obj2, &dir, ccd, &supp[3]);\n    if (ccdVec3Eq(&a->v, &supp[3].v) || ccdVec3Eq(&b->v, &supp[3].v))\n        goto simplexToPolytope2_touching_contact;\n\n    goto simplexToPolytope2_not_touching_contact;\nsimplexToPolytope2_touching_contact:\n    v[0] = ccdPtAddVertex(pt, a);\n    v[1] = ccdPtAddVertex(pt, b);\n    *nearest = (ccd_pt_el_t *)ccdPtAddEdge(pt, v[0], v[1]);\n    if (*nearest == NULL)\n        return -2;\n\n    return -1;\n\nsimplexToPolytope2_not_touching_contact:\n    // form polyhedron\n    v[0] = ccdPtAddVertex(pt, a);\n    v[1] = ccdPtAddVertex(pt, &supp[0]);\n    v[2] = ccdPtAddVertex(pt, b);\n    v[3] = ccdPtAddVertex(pt, &supp[1]);\n    v[4] = ccdPtAddVertex(pt, &supp[2]);\n    v[5] = ccdPtAddVertex(pt, &supp[3]);\n\n    e[0] = ccdPtAddEdge(pt, v[0], v[1]);\n    e[1] = ccdPtAddEdge(pt, v[1], v[2]);\n    e[2] = ccdPtAddEdge(pt, v[2], v[3]);\n    e[3] = ccdPtAddEdge(pt, v[3], v[0]);\n\n    e[4] = ccdPtAddEdge(pt, v[4], v[0]);\n    e[5] = ccdPtAddEdge(pt, v[4], v[1]);\n    e[6] = ccdPtAddEdge(pt, v[4], v[2]);\n    e[7] = ccdPtAddEdge(pt, v[4], v[3]);\n\n    e[8]  = ccdPtAddEdge(pt, v[5], v[0]);\n    e[9]  = ccdPtAddEdge(pt, v[5], v[1]);\n    e[10] = ccdPtAddEdge(pt, v[5], v[2]);\n    e[11] = ccdPtAddEdge(pt, v[5], v[3]);\n\n    if (ccdPtAddFace(pt, e[4], e[5], e[0]) == NULL\n            || ccdPtAddFace(pt, e[5], e[6], e[1]) == NULL\n            || ccdPtAddFace(pt, e[6], e[7], e[2]) == NULL\n            || ccdPtAddFace(pt, e[7], e[4], e[3]) == NULL\n\n            || ccdPtAddFace(pt, e[8],  e[9],  e[0]) == NULL\n            || ccdPtAddFace(pt, e[9],  e[10], e[1]) == NULL\n            || ccdPtAddFace(pt, e[10], e[11], e[2]) == NULL\n            || ccdPtAddFace(pt, e[11], e[8],  e[3]) == NULL){\n        return -2;\n    }\n\n    return 0;\n}\n\n/** Expands polytope's tri by new vertex v. Triangle tri is replaced by\n *  three triangles each with one vertex in v. */\nstatic int expandPolytope(ccd_pt_t *pt, ccd_pt_el_t *el,\n                          const ccd_support_t *newv)\n{\n    ccd_pt_vertex_t *v[5];\n    ccd_pt_edge_t *e[8];\n    ccd_pt_face_t *f[2];\n\n\n    // element can be either segment or triangle\n    if (el->type == CCD_PT_EDGE){\n        // In this case, segment should be replaced by new point.\n        // Simpliest case is when segment stands alone and in this case\n        // this segment is replaced by two other segments both connected to\n        // newv.\n        // Segment can be also connected to max two faces and in that case\n        // each face must be replaced by two other faces. To do this\n        // correctly it is necessary to have correctly ordered edges and\n        // vertices which is exactly what is done in following code.\n        //\n\n        ccdPtEdgeVertices((const ccd_pt_edge_t *)el, &v[0], &v[2]);\n\n        ccdPtEdgeFaces((ccd_pt_edge_t *)el, &f[0], &f[1]);\n\n        if (f[0]){\n            ccdPtFaceEdges(f[0], &e[0], &e[1], &e[2]);\n            if (e[0] == (ccd_pt_edge_t *)el){\n                e[0] = e[2];\n            }else if (e[1] == (ccd_pt_edge_t *)el){\n                e[1] = e[2];\n            }\n            ccdPtEdgeVertices(e[0], &v[1], &v[3]);\n            if (v[1] != v[0] && v[3] != v[0]){\n                e[2] = e[0];\n                e[0] = e[1];\n                e[1] = e[2];\n                if (v[1] == v[2])\n                    v[1] = v[3];\n            }else{\n                if (v[1] == v[0])\n                    v[1] = v[3];\n            }\n\n            if (f[1]){\n                ccdPtFaceEdges(f[1], &e[2], &e[3], &e[4]);\n                if (e[2] == (ccd_pt_edge_t *)el){\n                    e[2] = e[4];\n                }else if (e[3] == (ccd_pt_edge_t *)el){\n                    e[3] = e[4];\n                }\n                ccdPtEdgeVertices(e[2], &v[3], &v[4]);\n                if (v[3] != v[2] && v[4] != v[2]){\n                    e[4] = e[2];\n                    e[2] = e[3];\n                    e[3] = e[4];\n                    if (v[3] == v[0])\n                        v[3] = v[4];\n                }else{\n                    if (v[3] == v[2])\n                        v[3] = v[4];\n                }\n            }\n\n\n            v[4] = ccdPtAddVertex(pt, newv);\n\n            ccdPtDelFace(pt, f[0]);\n            if (f[1]){\n                ccdPtDelFace(pt, f[1]);\n                ccdPtDelEdge(pt, (ccd_pt_edge_t *)el);\n            }\n\n            e[4] = ccdPtAddEdge(pt, v[4], v[2]);\n            e[5] = ccdPtAddEdge(pt, v[4], v[0]);\n            e[6] = ccdPtAddEdge(pt, v[4], v[1]);\n            if (f[1])\n                e[7] = ccdPtAddEdge(pt, v[4], v[3]);\n\n\n            if (ccdPtAddFace(pt, e[1], e[4], e[6]) == NULL\n                    || ccdPtAddFace(pt, e[0], e[6], e[5]) == NULL){\n                return -2;\n            }\n\n            if (f[1]){\n                if (ccdPtAddFace(pt, e[3], e[5], e[7]) == NULL\n                        || ccdPtAddFace(pt, e[4], e[7], e[2]) == NULL){\n                    return -2;\n                }\n            }else{\n                if (ccdPtAddFace(pt, e[4], e[5], (ccd_pt_edge_t *)el) == NULL)\n                    return -2;\n            }\n        }\n    }else{ // el->type == CCD_PT_FACE\n        // replace triangle by tetrahedron without base (base would be the\n        // triangle that will be removed)\n\n        // get triplet of surrounding edges and vertices of triangle face\n        ccdPtFaceEdges((const ccd_pt_face_t *)el, &e[0], &e[1], &e[2]);\n        ccdPtEdgeVertices(e[0], &v[0], &v[1]);\n        ccdPtEdgeVertices(e[1], &v[2], &v[3]);\n\n        // following code sorts edges to have e[0] between vertices 0-1,\n        // e[1] between 1-2 and e[2] between 2-0\n        if (v[2] != v[1] && v[3] != v[1]){\n            // swap e[1] and e[2] \n            e[3] = e[1];\n            e[1] = e[2];\n            e[2] = e[3];\n        }\n        if (v[3] != v[0] && v[3] != v[1])\n            v[2] = v[3];\n\n        // remove triangle face\n        ccdPtDelFace(pt, (ccd_pt_face_t *)el);\n\n        // expand triangle to tetrahedron\n        v[3] = ccdPtAddVertex(pt, newv);\n        e[3] = ccdPtAddEdge(pt, v[3], v[0]);\n        e[4] = ccdPtAddEdge(pt, v[3], v[1]);\n        e[5] = ccdPtAddEdge(pt, v[3], v[2]);\n\n        if (ccdPtAddFace(pt, e[3], e[4], e[0]) == NULL\n                || ccdPtAddFace(pt, e[4], e[5], e[1]) == NULL\n                || ccdPtAddFace(pt, e[5], e[3], e[2]) == NULL){\n            return -2;\n        }\n    }\n\n    return 0;\n}\n\n/** Finds next support point (and stores it in out argument).\n *  Returns 0 on success, -1 otherwise */\nstatic int nextSupport(const void *obj1, const void *obj2, const ccd_t *ccd,\n                       const ccd_pt_el_t *el,\n                       ccd_support_t *out)\n{\n    ccd_vec3_t *a, *b, *c;\n    ccd_real_t dist;\n\n    if (el->type == CCD_PT_VERTEX)\n        return -1;\n\n    // touch contact\n    if (ccdIsZero(el->dist))\n        return -1;\n\n    __ccdSupport(obj1, obj2, &el->witness, ccd, out);\n\n    // Compute dist of support point along element witness point direction\n    // so we can determine whether we expanded a polytope surrounding the\n    // origin a bit.\n    dist = ccdVec3Dot(&out->v, &el->witness);\n\n    if (dist - el->dist < ccd->epa_tolerance)\n        return -1;\n\n    if (el->type == CCD_PT_EDGE){\n        // fetch end points of edge\n        ccdPtEdgeVec3((ccd_pt_edge_t *)el, &a, &b);\n\n        // get distance from segment\n        dist = ccdVec3PointSegmentDist2(&out->v, a, b, NULL);\n    }else{ // el->type == CCD_PT_FACE\n        // fetch vertices of triangle face\n        ccdPtFaceVec3((ccd_pt_face_t *)el, &a, &b, &c);\n\n        // check if new point can significantly expand polytope\n        dist = ccdVec3PointTriDist2(&out->v, a, b, c, NULL);\n    }\n\n    if (dist < ccd->epa_tolerance)\n        return -1;\n\n    return 0;\n}\n"},{"name":"ccd_mpr.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/shared/robotics/externalDependency/libccd/src","tag":"","groupDisplay":"Other files","code":"/***\n * Copyright (C) 2019 The MathWorks, Inc.\n * MathWorks-specific modifications have been made to the original source. \n */\n\n/***\n * libccd\n * ---------------------------------\n * Copyright (c)2010,2011 Daniel Fiser <danfis@danfis.cz>\n *\n *\n *  This file is part of libccd.\n *\n *  Distributed under the OSI-approved BSD License (the \"License\");\n *  see accompanying file BDS-LICENSE for details or see\n *  <http://www.opensource.org/licenses/bsd-license.php>.\n *\n *  This software is distributed WITHOUT ANY WARRANTY; without even the\n *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *  See the License for more information.\n */\n\n\n#include <stdlib.h>\n\n#ifdef BUILDING_LIBCCD_IN_TMW\n#include <ccd/ccd_ccd.h>\n#include <ccd/ccd_simplex.h>\n#else\n#include <ccd_ccd.h>\n#include <ccd_simplex.h>\n#endif\n\n#include \"ccd_dbg.h\"\n\n/** Finds origin (center) of Minkowski difference (actually it can be any\n *  interior point of Minkowski difference. */\n_ccd_inline void findOrigin(const void *obj1, const void *obj2, const ccd_t *ccd,\n                            ccd_support_t *center);\n\n/** Discovers initial portal - that is tetrahedron that intersects with\n *  origin ray (ray from center of Minkowski diff to (0,0,0).\n *\n *  Returns -1 if already recognized that origin is outside Minkowski\n *  portal.\n *  Returns 1 if origin lies on v1 of simplex (only v0 and v1 are present\n *  in simplex).\n *  Returns 2 if origin lies on v0-v1 segment.\n *  Returns 0 if portal was built.\n */\nstatic int discoverPortal(const void *obj1, const void *obj2,\n                          const ccd_t *ccd, ccd_simplex_t *portal);\n\n\n/** Expands portal towards origin and determine if objects intersect.\n *  Already established portal must be given as argument.\n *  If intersection is found 0 is returned, -1 otherwise */\nstatic int refinePortal(const void *obj1, const void *obj2,\n                        const ccd_t *ccd, ccd_simplex_t *portal);\n\n/** Finds penetration info by expanding provided portal. */\nstatic void findPenetr(const void *obj1, const void *obj2, const ccd_t *ccd,\n                       ccd_simplex_t *portal,\n                       ccd_real_t *depth, ccd_vec3_t *dir, ccd_vec3_t *pos);\n\n/** Finds penetration info if origin lies on portal's v1 */\nstatic void findPenetrTouch(const void *obj1, const void *obj2, const ccd_t *ccd,\n                            ccd_simplex_t *portal,\n                            ccd_real_t *depth, ccd_vec3_t *dir, ccd_vec3_t *pos);\n\n/** Find penetration info if origin lies on portal's segment v0-v1 */\nstatic void findPenetrSegment(const void *obj1, const void *obj2, const ccd_t *ccd,\n                              ccd_simplex_t *portal,\n                              ccd_real_t *depth, ccd_vec3_t *dir, ccd_vec3_t *pos);\n\n/** Finds position vector from fully established portal */\nstatic void findPos(const void *obj1, const void *obj2, const ccd_t *ccd,\n                    const ccd_simplex_t *portal, ccd_vec3_t *pos);\n\n/** Extends portal with new support point.\n *  Portal must have face v1-v2-v3 arranged to face outside portal. */\n_ccd_inline void expandPortal(ccd_simplex_t *portal,\n                              const ccd_support_t *v4);\n\n/** Fill dir with direction outside portal. Portal's v1-v2-v3 face must be\n *  arranged in correct order! */\n_ccd_inline void portalDir(const ccd_simplex_t *portal, ccd_vec3_t *dir);\n\n/** Returns true if portal encapsules origin (0,0,0), dir is direction of\n *  v1-v2-v3 face. */\n_ccd_inline int portalEncapsulesOrigin(const ccd_simplex_t *portal,\n                                       const ccd_vec3_t *dir);\n\n/** Returns true if portal with new point v4 would reach specified\n *  tolerance (i.e. returns true if portal can _not_ significantly expand\n *  within Minkowski difference).\n *\n *  v4 is candidate for new point in portal, dir is direction in which v4\n *  was obtained. */\n_ccd_inline int portalReachTolerance(const ccd_simplex_t *portal,\n                                     const ccd_support_t *v4,\n                                     const ccd_vec3_t *dir,\n                                     const ccd_t *ccd);\n\n/** Returns true if portal expanded by new point v4 could possibly contain\n *  origin, dir is direction in which v4 was obtained. */\n_ccd_inline int portalCanEncapsuleOrigin(const ccd_simplex_t *portal,   \n                                         const ccd_support_t *v4,\n                                         const ccd_vec3_t *dir);\n\n\nint ccdMPRIntersect(const void *obj1, const void *obj2, const ccd_t *ccd)\n{\n    ccd_simplex_t portal;\n    int res;\n\n    // Phase 1: Portal discovery - find portal that intersects with origin\n    // ray (ray from center of Minkowski diff to origin of coordinates)\n    res = discoverPortal(obj1, obj2, ccd, &portal);\n    if (res < 0)\n        return 0;\n    if (res > 0)\n        return 1;\n\n    // Phase 2: Portal refinement\n    res = refinePortal(obj1, obj2, ccd, &portal);\n    return (res == 0 ? 1 : 0);\n}\n\nint ccdMPRPenetration(const void *obj1, const void *obj2, const ccd_t *ccd,\n                      ccd_real_t *depth, ccd_vec3_t *dir, ccd_vec3_t *pos)\n{\n    ccd_simplex_t portal;\n    int res;\n\n    // Phase 1: Portal discovery\n    res = discoverPortal(obj1, obj2, ccd, &portal);\n    if (res < 0){\n        // Origin isn't inside portal - no collision.\n        return -1;\n\n    }else if (res == 1){\n        // Touching contact on portal's v1.\n        findPenetrTouch(obj1, obj2, ccd, &portal, depth, dir, pos);\n\n    }else if (res == 2){\n        // Origin lies on v0-v1 segment.\n        findPenetrSegment(obj1, obj2, ccd, &portal, depth, dir, pos);\n\n    }else if (res == 0){\n        // Phase 2: Portal refinement\n        res = refinePortal(obj1, obj2, ccd, &portal);\n        if (res < 0)\n            return -1;\n\n        // Phase 3. Penetration info\n        findPenetr(obj1, obj2, ccd, &portal, depth, dir, pos);\n    }\n\n    return 0;\n}\n\n\n\n_ccd_inline void findOrigin(const void *obj1, const void *obj2, const ccd_t *ccd,\n                            ccd_support_t *center)\n{\n    ccd->center1(obj1, &center->v1);\n    ccd->center2(obj2, &center->v2);\n    ccdVec3Sub2(&center->v, &center->v1, &center->v2);\n}\n\nstatic int discoverPortal(const void *obj1, const void *obj2,\n                          const ccd_t *ccd, ccd_simplex_t *portal)\n{\n    ccd_vec3_t dir, va, vb;\n    ccd_real_t dot;\n    int cont;\n\n    // vertex 0 is center of portal\n    findOrigin(obj1, obj2, ccd, ccdSimplexPointW(portal, 0));\n    ccdSimplexSetSize(portal, 1);\n\n    if (ccdVec3Eq(&ccdSimplexPoint(portal, 0)->v, ccd_vec3_origin)){\n        // Portal's center lies on origin (0,0,0) => we know that objects\n        // intersect but we would need to know penetration info.\n        // So move center little bit...\n        ccdVec3Set(&va, CCD_EPS * CCD_REAL(10.), CCD_ZERO, CCD_ZERO);\n        ccdVec3Add(&ccdSimplexPointW(portal, 0)->v, &va);\n    }\n\n\n    // vertex 1 = support in direction of origin\n    ccdVec3Copy(&dir, &ccdSimplexPoint(portal, 0)->v);\n    ccdVec3Scale(&dir, CCD_REAL(-1.));\n    ccdVec3Normalize(&dir);\n    __ccdSupport(obj1, obj2, &dir, ccd, ccdSimplexPointW(portal, 1));\n    ccdSimplexSetSize(portal, 2);\n\n    // test if origin isn't outside of v1\n    dot = ccdVec3Dot(&ccdSimplexPoint(portal, 1)->v, &dir);\n    if (ccdIsZero(dot) || dot < CCD_ZERO)\n        return -1;\n\n\n    // vertex 2\n    ccdVec3Cross(&dir, &ccdSimplexPoint(portal, 0)->v,\n                       &ccdSimplexPoint(portal, 1)->v);\n    if (ccdIsZero(ccdVec3Len2(&dir))){\n        if (ccdVec3Eq(&ccdSimplexPoint(portal, 1)->v, ccd_vec3_origin)){\n            // origin lies on v1\n            return 1;\n        }else{\n            // origin lies on v0-v1 segment\n            return 2;\n        }\n    }\n\n    ccdVec3Normalize(&dir);\n    __ccdSupport(obj1, obj2, &dir, ccd, ccdSimplexPointW(portal, 2));\n    dot = ccdVec3Dot(&ccdSimplexPoint(portal, 2)->v, &dir);\n    if (ccdIsZero(dot) || dot < CCD_ZERO)\n        return -1;\n\n    ccdSimplexSetSize(portal, 3);\n\n    // vertex 3 direction\n    ccdVec3Sub2(&va, &ccdSimplexPoint(portal, 1)->v,\n                     &ccdSimplexPoint(portal, 0)->v);\n    ccdVec3Sub2(&vb, &ccdSimplexPoint(portal, 2)->v,\n                     &ccdSimplexPoint(portal, 0)->v);\n    ccdVec3Cross(&dir, &va, &vb);\n    ccdVec3Normalize(&dir);\n\n    // it is better to form portal faces to be oriented \"outside\" origin\n    dot = ccdVec3Dot(&dir, &ccdSimplexPoint(portal, 0)->v);\n    if (dot > CCD_ZERO){\n        ccdSimplexSwap(portal, 1, 2);\n        ccdVec3Scale(&dir, CCD_REAL(-1.));\n    }\n\n    while (ccdSimplexSize(portal) < 4){\n        __ccdSupport(obj1, obj2, &dir, ccd, ccdSimplexPointW(portal, 3));\n        dot = ccdVec3Dot(&ccdSimplexPoint(portal, 3)->v, &dir);\n        if (ccdIsZero(dot) || dot < CCD_ZERO)\n            return -1;\n\n        cont = 0;\n\n        // test if origin is outside (v1, v0, v3) - set v2 as v3 and\n        // continue\n        ccdVec3Cross(&va, &ccdSimplexPoint(portal, 1)->v,\n                          &ccdSimplexPoint(portal, 3)->v);\n        dot = ccdVec3Dot(&va, &ccdSimplexPoint(portal, 0)->v);\n        if (dot < CCD_ZERO && !ccdIsZero(dot)){\n            ccdSimplexSet(portal, 2, ccdSimplexPoint(portal, 3));\n            cont = 1;\n        }\n\n        if (!cont){\n            // test if origin is outside (v3, v0, v2) - set v1 as v3 and\n            // continue\n            ccdVec3Cross(&va, &ccdSimplexPoint(portal, 3)->v,\n                              &ccdSimplexPoint(portal, 2)->v);\n            dot = ccdVec3Dot(&va, &ccdSimplexPoint(portal, 0)->v);\n            if (dot < CCD_ZERO && !ccdIsZero(dot)){\n                ccdSimplexSet(portal, 1, ccdSimplexPoint(portal, 3));\n                cont = 1;\n            }\n        }\n\n        if (cont){\n            ccdVec3Sub2(&va, &ccdSimplexPoint(portal, 1)->v,\n                             &ccdSimplexPoint(portal, 0)->v);\n            ccdVec3Sub2(&vb, &ccdSimplexPoint(portal, 2)->v,\n                             &ccdSimplexPoint(portal, 0)->v);\n            ccdVec3Cross(&dir, &va, &vb);\n            ccdVec3Normalize(&dir);\n        }else{\n            ccdSimplexSetSize(portal, 4);\n        }\n    }\n\n    return 0;\n}\n\nstatic int refinePortal(const void *obj1, const void *obj2,\n                        const ccd_t *ccd, ccd_simplex_t *portal)\n{\n    ccd_vec3_t dir;\n    ccd_support_t v4;\n\n    while (1){\n        // compute direction outside the portal (from v0 throught v1,v2,v3\n        // face)\n        portalDir(portal, &dir);\n\n        // test if origin is inside the portal\n        if (portalEncapsulesOrigin(portal, &dir))\n            return 0;\n\n        // get next support point\n        __ccdSupport(obj1, obj2, &dir, ccd, &v4);\n\n        // test if v4 can expand portal to contain origin and if portal\n        // expanding doesn't reach given tolerance\n        if (!portalCanEncapsuleOrigin(portal, &v4, &dir)\n                || portalReachTolerance(portal, &v4, &dir, ccd)){\n            return -1;\n        }\n\n        // v1-v2-v3 triangle must be rearranged to face outside Minkowski\n        // difference (direction from v0).\n        expandPortal(portal, &v4);\n    }\n\n    return -1;\n}\n\n\nstatic void findPenetr(const void *obj1, const void *obj2, const ccd_t *ccd,\n                       ccd_simplex_t *portal,\n                       ccd_real_t *depth, ccd_vec3_t *pdir, ccd_vec3_t *pos)\n{\n    ccd_vec3_t dir;\n    ccd_support_t v4;\n    unsigned long iterations;\n\n    iterations = 0UL;\n    while (1){\n        // compute portal direction and obtain next support point\n        portalDir(portal, &dir);\n        __ccdSupport(obj1, obj2, &dir, ccd, &v4);\n\n        // reached tolerance -> find penetration info\n        if (portalReachTolerance(portal, &v4, &dir, ccd)\n                || iterations > ccd->max_iterations){\n            *depth = ccdVec3PointTriDist2(ccd_vec3_origin,\n                                          &ccdSimplexPoint(portal, 1)->v,\n                                          &ccdSimplexPoint(portal, 2)->v,\n                                          &ccdSimplexPoint(portal, 3)->v,\n                                          pdir);\n            *depth = CCD_SQRT(*depth);\n            if (ccdIsZero(*depth)){\n                // If depth is zero, then we have a touching contact.\n                // So following findPenetrTouch(), we assign zero to\n                // the direction vector (it can actually be anything\n                // according to the decription of ccdMPRPenetration\n                // function).\n                ccdVec3Copy(pdir, ccd_vec3_origin);\n            }else{\n                ccdVec3Normalize(pdir);\n            }\n\n            // barycentric coordinates:\n            findPos(obj1, obj2, ccd, portal, pos);\n\n            return;\n        }\n\n        expandPortal(portal, &v4);\n\n        iterations++;\n    }\n}\n\nstatic void findPenetrTouch(const void *obj1, const void *obj2, const ccd_t *ccd,\n                            ccd_simplex_t *portal,\n                            ccd_real_t *depth, ccd_vec3_t *dir, ccd_vec3_t *pos)\n{\n    // Touching contact on portal's v1 - so depth is zero and direction\n    // is unimportant and pos can be guessed\n    (void)obj1;(void)obj2;(void)ccd; //C4100 in MSVC and -Wunused-value in Clang\n    *depth = CCD_REAL(0.);\n    ccdVec3Copy(dir, ccd_vec3_origin);\n\n    ccdVec3Copy(pos, &ccdSimplexPoint(portal, 1)->v1);\n    ccdVec3Add(pos, &ccdSimplexPoint(portal, 1)->v2);\n    ccdVec3Scale(pos, 0.5);\n}\n\nstatic void findPenetrSegment(const void *obj1, const void *obj2, const ccd_t *ccd,\n                              ccd_simplex_t *portal,\n                              ccd_real_t *depth, ccd_vec3_t *dir, ccd_vec3_t *pos)\n{\n    /*\n    ccd_vec3_t vec;\n    ccd_real_t k;\n    */\n\n    // Origin lies on v0-v1 segment.\n    // Depth is distance to v1, direction also and position must be\n    // computed\n\n    (void)obj2;(void)obj1;(void)ccd; //C4100 in MSVC and -Wunused-value in Clang\n    ccdVec3Copy(pos, &ccdSimplexPoint(portal, 1)->v1);\n    ccdVec3Add(pos, &ccdSimplexPoint(portal, 1)->v2);\n    ccdVec3Scale(pos, CCD_REAL(0.5));\n\n    /*\n    ccdVec3Sub2(&vec, &ccdSimplexPoint(portal, 1)->v,\n                      &ccdSimplexPoint(portal, 0)->v);\n    k  = CCD_SQRT(ccdVec3Len2(&ccdSimplexPoint(portal, 0)->v));\n    k /= CCD_SQRT(ccdVec3Len2(&vec));\n    ccdVec3Scale(&vec, -k);\n    ccdVec3Add(pos, &vec);\n    */\n\n    ccdVec3Copy(dir, &ccdSimplexPoint(portal, 1)->v);\n    *depth = CCD_SQRT(ccdVec3Len2(dir));\n    ccdVec3Normalize(dir);\n}\n\n\nstatic void findPos(const void *obj1, const void *obj2, const ccd_t *ccd,\n                    const ccd_simplex_t *portal, ccd_vec3_t *pos)\n{\n    (void)obj1; (void)obj2; (void)ccd; //C4100 in MSVC and -Wunused-value in Clang\n    ccd_vec3_t dir;\n    int i;\n    ccd_real_t b[4], sum, inv;\n    ccd_vec3_t vec, p1, p2;\n\n    portalDir(portal, &dir);\n\n    // use barycentric coordinates of tetrahedron to find origin\n    ccdVec3Cross(&vec, &ccdSimplexPoint(portal, 1)->v,\n                       &ccdSimplexPoint(portal, 2)->v);\n    b[0] = ccdVec3Dot(&vec, &ccdSimplexPoint(portal, 3)->v);\n\n    ccdVec3Cross(&vec, &ccdSimplexPoint(portal, 3)->v,\n                       &ccdSimplexPoint(portal, 2)->v);\n    b[1] = ccdVec3Dot(&vec, &ccdSimplexPoint(portal, 0)->v);\n\n    ccdVec3Cross(&vec, &ccdSimplexPoint(portal, 0)->v,\n                       &ccdSimplexPoint(portal, 1)->v);\n    b[2] = ccdVec3Dot(&vec, &ccdSimplexPoint(portal, 3)->v);\n\n    ccdVec3Cross(&vec, &ccdSimplexPoint(portal, 2)->v,\n                       &ccdSimplexPoint(portal, 1)->v);\n    b[3] = ccdVec3Dot(&vec, &ccdSimplexPoint(portal, 0)->v);\n\n\tsum = b[0] + b[1] + b[2] + b[3];\n\n    if (ccdIsZero(sum) || sum < CCD_ZERO){\n\t\tb[0] = CCD_REAL(0.);\n\n        ccdVec3Cross(&vec, &ccdSimplexPoint(portal, 2)->v,\n                           &ccdSimplexPoint(portal, 3)->v);\n        b[1] = ccdVec3Dot(&vec, &dir);\n        ccdVec3Cross(&vec, &ccdSimplexPoint(portal, 3)->v,\n                           &ccdSimplexPoint(portal, 1)->v);\n        b[2] = ccdVec3Dot(&vec, &dir);\n        ccdVec3Cross(&vec, &ccdSimplexPoint(portal, 1)->v,\n                           &ccdSimplexPoint(portal, 2)->v);\n        b[3] = ccdVec3Dot(&vec, &dir);\n\n\t\tsum = b[1] + b[2] + b[3];\n\t}\n\n\tinv = CCD_REAL(1.) / sum;\n\n    ccdVec3Copy(&p1, ccd_vec3_origin);\n    ccdVec3Copy(&p2, ccd_vec3_origin);\n    for (i = 0; i < 4; i++){\n        ccdVec3Copy(&vec, &ccdSimplexPoint(portal, i)->v1);\n        ccdVec3Scale(&vec, b[i]);\n        ccdVec3Add(&p1, &vec);\n\n        ccdVec3Copy(&vec, &ccdSimplexPoint(portal, i)->v2);\n        ccdVec3Scale(&vec, b[i]);\n        ccdVec3Add(&p2, &vec);\n    }\n    ccdVec3Scale(&p1, inv);\n    ccdVec3Scale(&p2, inv);\n\n    ccdVec3Copy(pos, &p1);\n    ccdVec3Add(pos, &p2);\n    ccdVec3Scale(pos, 0.5);\n}\n\n_ccd_inline void expandPortal(ccd_simplex_t *portal,\n                              const ccd_support_t *v4)\n{\n    ccd_real_t dot;\n    ccd_vec3_t v4v0;\n\n    ccdVec3Cross(&v4v0, &v4->v, &ccdSimplexPoint(portal, 0)->v);\n    dot = ccdVec3Dot(&ccdSimplexPoint(portal, 1)->v, &v4v0);\n    if (dot > CCD_ZERO){\n        dot = ccdVec3Dot(&ccdSimplexPoint(portal, 2)->v, &v4v0);\n        if (dot > CCD_ZERO){\n            ccdSimplexSet(portal, 1, v4);\n        }else{\n            ccdSimplexSet(portal, 3, v4);\n        }\n    }else{\n        dot = ccdVec3Dot(&ccdSimplexPoint(portal, 3)->v, &v4v0);\n        if (dot > CCD_ZERO){\n            ccdSimplexSet(portal, 2, v4);\n        }else{\n            ccdSimplexSet(portal, 1, v4);\n        }\n    }\n}\n\n_ccd_inline void portalDir(const ccd_simplex_t *portal, ccd_vec3_t *dir)\n{\n    ccd_vec3_t v2v1, v3v1;\n\n    ccdVec3Sub2(&v2v1, &ccdSimplexPoint(portal, 2)->v,\n                       &ccdSimplexPoint(portal, 1)->v);\n    ccdVec3Sub2(&v3v1, &ccdSimplexPoint(portal, 3)->v,\n                       &ccdSimplexPoint(portal, 1)->v);\n    ccdVec3Cross(dir, &v2v1, &v3v1);\n    ccdVec3Normalize(dir);\n}\n\n_ccd_inline int portalEncapsulesOrigin(const ccd_simplex_t *portal,\n                                       const ccd_vec3_t *dir)\n{\n    ccd_real_t dot;\n    dot = ccdVec3Dot(dir, &ccdSimplexPoint(portal, 1)->v);\n    return ccdIsZero(dot) || dot > CCD_ZERO;\n}\n\n_ccd_inline int portalReachTolerance(const ccd_simplex_t *portal,\n                                     const ccd_support_t *v4,\n                                     const ccd_vec3_t *dir,\n                                     const ccd_t *ccd)\n{\n    (void)portal;//C4100 in MSVC and -Wunused-value in Clang\n    ccd_real_t dv1, dv2, dv3, dv4;\n    ccd_real_t dot1, dot2, dot3;\n\n    // find the smallest dot product of dir and {v1-v4, v2-v4, v3-v4}\n\n    dv1 = ccdVec3Dot(&ccdSimplexPoint(portal, 1)->v, dir);\n    dv2 = ccdVec3Dot(&ccdSimplexPoint(portal, 2)->v, dir);\n    dv3 = ccdVec3Dot(&ccdSimplexPoint(portal, 3)->v, dir);\n    dv4 = ccdVec3Dot(&v4->v, dir);\n\n    dot1 = dv4 - dv1;\n    dot2 = dv4 - dv2;\n    dot3 = dv4 - dv3;\n\n    dot1 = CCD_FMIN(dot1, dot2);\n    dot1 = CCD_FMIN(dot1, dot3);\n\n    return ccdEq(dot1, ccd->mpr_tolerance) || dot1 < ccd->mpr_tolerance;\n}\n\n_ccd_inline int portalCanEncapsuleOrigin(const ccd_simplex_t *portal,   \n                                         const ccd_support_t *v4,\n                                         const ccd_vec3_t *dir)\n{\n    (void)portal;//C4100 in MSVC and -Wunused-value in Clang\n    ccd_real_t dot;\n    dot = ccdVec3Dot(&v4->v, dir);\n    return ccdIsZero(dot) || dot > CCD_ZERO;\n}\n"},{"name":"ccd_polytope.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/shared/robotics/externalDependency/libccd/src","tag":"","groupDisplay":"Other files","code":"/***\n * Copyright (C) 2019 The MathWorks, Inc.\n * MathWorks-specific modifications have been made to the original source. \n */\n\n/***\n * libccd\n * ---------------------------------\n * Copyright (c)2010 Daniel Fiser <danfis@danfis.cz>\n *\n *\n *  This file is part of libccd.\n *\n *  Distributed under the OSI-approved BSD License (the \"License\");\n *  see accompanying file BDS-LICENSE for details or see\n *  <http://www.opensource.org/licenses/bsd-license.php>.\n *\n *  This software is distributed WITHOUT ANY WARRANTY; without even the\n *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *  See the License for more information.\n */\n\n\n#include <stdio.h>\n#include <float.h>\n\n#ifdef BUILDING_LIBCCD_IN_TMW\n#include <ccd/ccd_polytope.h>\n#else\n#include <ccd_polytope.h>\n#endif\n\n#include \"ccd_alloc.h\"\n\n_ccd_inline void _ccdPtNearestUpdate(ccd_pt_t *pt, ccd_pt_el_t *el)\n{\n    if (ccdEq(pt->nearest_dist, el->dist)){\n        if (el->type < pt->nearest_type){\n            pt->nearest = el;\n            pt->nearest_dist = el->dist;\n            pt->nearest_type = el->type;\n        }\n    }else if (el->dist < pt->nearest_dist){\n        pt->nearest = el;\n        pt->nearest_dist = el->dist;\n        pt->nearest_type = el->type;\n    }\n}\n\nstatic void _ccdPtNearestRenew(ccd_pt_t *pt)\n{\n    ccd_pt_vertex_t *v;\n    ccd_pt_edge_t *e;\n    ccd_pt_face_t *f;\n\n    pt->nearest_dist = CCD_REAL_MAX;\n    pt->nearest_type = 3;\n    pt->nearest = NULL;\n\n    ccdListForEachEntry(&pt->vertices, v, ccd_pt_vertex_t, list){\n        _ccdPtNearestUpdate(pt, (ccd_pt_el_t *)v);\n    }\n\n    ccdListForEachEntry(&pt->edges, e, ccd_pt_edge_t, list){\n        _ccdPtNearestUpdate(pt, (ccd_pt_el_t *)e);\n    }\n\n    ccdListForEachEntry(&pt->faces, f, ccd_pt_face_t, list){\n        _ccdPtNearestUpdate(pt, (ccd_pt_el_t *)f);\n    }\n}\n\n\n\nvoid ccdPtInit(ccd_pt_t *pt)\n{\n    ccdListInit(&pt->vertices);\n    ccdListInit(&pt->edges);\n    ccdListInit(&pt->faces);\n\n    pt->nearest = NULL;\n    pt->nearest_dist = CCD_REAL_MAX;\n    pt->nearest_type = 3;\n}\n\nvoid ccdPtDestroy(ccd_pt_t *pt)\n{\n    ccd_pt_face_t *f, *f2;\n    ccd_pt_edge_t *e, *e2;\n    ccd_pt_vertex_t *v, *v2;\n\n    // first delete all faces\n    ccdListForEachEntrySafe(&pt->faces, f, ccd_pt_face_t, f2, ccd_pt_face_t, list){\n        ccdPtDelFace(pt, f);\n    }\n\n    // delete all edges\n    ccdListForEachEntrySafe(&pt->edges, e, ccd_pt_edge_t, e2, ccd_pt_edge_t, list){\n        ccdPtDelEdge(pt, e);\n    }\n\n    // delete all vertices\n    ccdListForEachEntrySafe(&pt->vertices, v, ccd_pt_vertex_t, v2, ccd_pt_vertex_t, list){\n        ccdPtDelVertex(pt, v);\n    }\n}\n\n\nccd_pt_vertex_t *ccdPtAddVertex(ccd_pt_t *pt, const ccd_support_t *v)\n{\n    ccd_pt_vertex_t *vert;\n\n    vert = CCD_ALLOC(ccd_pt_vertex_t);\n    if (vert == NULL)\n        return NULL;\n\n    vert->type = CCD_PT_VERTEX;\n    ccdSupportCopy(&vert->v, v);\n\n    vert->dist = ccdVec3Len2(&vert->v.v);\n    ccdVec3Copy(&vert->witness, &vert->v.v);\n\n    ccdListInit(&vert->edges);\n\n    // add vertex to list\n    ccdListAppend(&pt->vertices, &vert->list);\n\n    // update position in .nearest array\n    _ccdPtNearestUpdate(pt, (ccd_pt_el_t *)vert);\n\n    return vert;\n}\n\nccd_pt_edge_t *ccdPtAddEdge(ccd_pt_t *pt, ccd_pt_vertex_t *v1,\n                                          ccd_pt_vertex_t *v2)\n{\n    const ccd_vec3_t *a, *b;\n    ccd_pt_edge_t *edge;\n\n    if (v1 == NULL || v2 == NULL)\n        return NULL;\n\n    edge = CCD_ALLOC(ccd_pt_edge_t);\n    if (edge == NULL)\n        return NULL;\n\n    edge->type = CCD_PT_EDGE;\n    edge->vertex[0] = v1;\n    edge->vertex[1] = v2;\n    edge->faces[0] = edge->faces[1] = NULL;\n\n    a = &edge->vertex[0]->v.v;\n    b = &edge->vertex[1]->v.v;\n    edge->dist = ccdVec3PointSegmentDist2(ccd_vec3_origin, a, b, &edge->witness);\n\n    ccdListAppend(&edge->vertex[0]->edges, &edge->vertex_list[0]);\n    ccdListAppend(&edge->vertex[1]->edges, &edge->vertex_list[1]);\n\n    ccdListAppend(&pt->edges, &edge->list);\n\n    // update position in .nearest array\n    _ccdPtNearestUpdate(pt, (ccd_pt_el_t *)edge);\n\n    return edge;\n}\n\nccd_pt_face_t *ccdPtAddFace(ccd_pt_t *pt, ccd_pt_edge_t *e1,\n                                          ccd_pt_edge_t *e2,\n                                          ccd_pt_edge_t *e3)\n{\n    const ccd_vec3_t *a, *b, *c;\n    ccd_pt_face_t *face;\n    ccd_pt_edge_t *e;\n    size_t i;\n\n    if (e1 == NULL || e2 == NULL || e3 == NULL)\n        return NULL;\n\n    face = CCD_ALLOC(ccd_pt_face_t);\n    if (face == NULL)\n        return NULL;\n\n    face->type = CCD_PT_FACE;\n    face->edge[0] = e1;\n    face->edge[1] = e2;\n    face->edge[2] = e3;\n\n    // obtain triplet of vertices\n    a = &face->edge[0]->vertex[0]->v.v;\n    b = &face->edge[0]->vertex[1]->v.v;\n    e = face->edge[1];\n    if (e->vertex[0] != face->edge[0]->vertex[0]\n            && e->vertex[0] != face->edge[0]->vertex[1]){\n        c = &e->vertex[0]->v.v;\n    }else{\n        c = &e->vertex[1]->v.v;\n    }\n    face->dist = ccdVec3PointTriDist2(ccd_vec3_origin, a, b, c, &face->witness);\n\n\n    for (i = 0; i < 3; i++){\n        if (face->edge[i]->faces[0] == NULL){\n            face->edge[i]->faces[0] = face;\n        }else{\n            face->edge[i]->faces[1] = face;\n        }\n    }\n\n    ccdListAppend(&pt->faces, &face->list);\n\n    // update position in .nearest array\n    _ccdPtNearestUpdate(pt, (ccd_pt_el_t *)face);\n\n    return face;\n}\n\n\nvoid ccdPtRecomputeDistances(ccd_pt_t *pt)\n{\n    ccd_pt_vertex_t *v;\n    ccd_pt_edge_t *e;\n    ccd_pt_face_t *f;\n    const ccd_vec3_t *a, *b, *c;\n    ccd_real_t dist;\n\n    ccdListForEachEntry(&pt->vertices, v, ccd_pt_vertex_t, list){\n        dist = ccdVec3Len2(&v->v.v);\n        v->dist = dist;\n        ccdVec3Copy(&v->witness, &v->v.v);\n    }\n\n    ccdListForEachEntry(&pt->edges, e, ccd_pt_edge_t, list){\n        a = &e->vertex[0]->v.v;\n        b = &e->vertex[1]->v.v;\n        dist = ccdVec3PointSegmentDist2(ccd_vec3_origin, a, b, &e->witness);\n        e->dist = dist;\n    }\n\n    ccdListForEachEntry(&pt->faces, f, ccd_pt_face_t, list){\n        // obtain triplet of vertices\n        a = &f->edge[0]->vertex[0]->v.v;\n        b = &f->edge[0]->vertex[1]->v.v;\n        e = f->edge[1];\n        if (e->vertex[0] != f->edge[0]->vertex[0]\n                && e->vertex[0] != f->edge[0]->vertex[1]){\n            c = &e->vertex[0]->v.v;\n        }else{\n            c = &e->vertex[1]->v.v;\n        }\n\n        dist = ccdVec3PointTriDist2(ccd_vec3_origin, a, b, c, &f->witness);\n        f->dist = dist;\n    }\n}\n\nccd_pt_el_t *ccdPtNearest(ccd_pt_t *pt)\n{\n    if (!pt->nearest){\n        _ccdPtNearestRenew(pt);\n    }\n    return pt->nearest;\n}\n\n\nvoid ccdPtDumpSVT(ccd_pt_t *pt, const char *fn)\n{\n    FILE *fout;\n\n    fout = fopen(fn, \"a\");\n    if (fout == NULL)\n        return;\n\n    ccdPtDumpSVT2(pt, fout);\n\n    fclose(fout);\n}\n\nvoid ccdPtDumpSVT2(ccd_pt_t *pt, FILE *fout)\n{\n    ccd_pt_vertex_t *v, *a, *b, *c;\n    ccd_pt_edge_t *e;\n    ccd_pt_face_t *f;\n    int i;\n\n    fprintf(fout, \"-----\\n\");\n\n    fprintf(fout, \"Points:\\n\");\n    i = 0;\n    ccdListForEachEntry(&pt->vertices, v, ccd_pt_vertex_t, list){\n        v->id = i++;\n        fprintf(fout, \"%lf %lf %lf\\n\",\n                ccdVec3X(&v->v.v), ccdVec3Y(&v->v.v), ccdVec3Z(&v->v.v));\n    }\n\n    fprintf(fout, \"Edges:\\n\");\n    ccdListForEachEntry(&pt->edges, e, ccd_pt_edge_t, list){\n        fprintf(fout, \"%d %d\\n\", e->vertex[0]->id, e->vertex[1]->id);\n    }\n\n    fprintf(fout, \"Faces:\\n\");\n    ccdListForEachEntry(&pt->faces, f, ccd_pt_face_t, list){\n        a = f->edge[0]->vertex[0];\n        b = f->edge[0]->vertex[1];\n        c = f->edge[1]->vertex[0];\n        if (c == a || c == b){\n            c = f->edge[1]->vertex[1];\n        }\n        fprintf(fout, \"%d %d %d\\n\", a->id, b->id, c->id);\n    }\n}\n"},{"name":"ccd_vec3.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/shared/robotics/externalDependency/libccd/src","tag":"","groupDisplay":"Other files","code":"/***\n * Copyright (C) 2019 The MathWorks, Inc.\n * MathWorks-specific modifications have been made to the original source. \n */\n\n/***\n * libccd\n * ---------------------------------\n * Copyright (c)2010 Daniel Fiser <danfis@danfis.cz>\n *\n *\n *  This file is part of libccd.\n *\n *  Distributed under the OSI-approved BSD License (the \"License\");\n *  see accompanying file BDS-LICENSE for details or see\n *  <http://www.opensource.org/licenses/bsd-license.php>.\n *\n *  This software is distributed WITHOUT ANY WARRANTY; without even the\n *  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *  See the License for more information.\n */\n\n#include <stdio.h>\n#ifdef BUILDING_LIBCCD_IN_TMW\n#include <ccd/ccd_vec3.h>\n#else\n#include <ccd_vec3.h>\n#endif\n#include \"ccd_dbg.h\"\n\nstatic CCD_VEC3(__ccd_vec3_origin, CCD_ZERO, CCD_ZERO, CCD_ZERO);\nccd_vec3_t *ccd_vec3_origin = &__ccd_vec3_origin;\n\nstatic ccd_vec3_t points_on_sphere[] = {\n\tCCD_VEC3_STATIC(CCD_REAL( 0.000000), CCD_REAL(-0.000000), CCD_REAL(-1.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.723608), CCD_REAL(-0.525725), CCD_REAL(-0.447219)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.276388), CCD_REAL(-0.850649), CCD_REAL(-0.447219)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.894426), CCD_REAL(-0.000000), CCD_REAL(-0.447216)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.276388), CCD_REAL( 0.850649), CCD_REAL(-0.447220)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.723608), CCD_REAL( 0.525725), CCD_REAL(-0.447219)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.276388), CCD_REAL(-0.850649), CCD_REAL( 0.447220)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.723608), CCD_REAL(-0.525725), CCD_REAL( 0.447219)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.723608), CCD_REAL( 0.525725), CCD_REAL( 0.447219)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.276388), CCD_REAL( 0.850649), CCD_REAL( 0.447219)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.894426), CCD_REAL( 0.000000), CCD_REAL( 0.447216)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.000000), CCD_REAL( 0.000000), CCD_REAL( 1.000000)), \n\tCCD_VEC3_STATIC(CCD_REAL( 0.425323), CCD_REAL(-0.309011), CCD_REAL(-0.850654)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.162456), CCD_REAL(-0.499995), CCD_REAL(-0.850654)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.262869), CCD_REAL(-0.809012), CCD_REAL(-0.525738)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.425323), CCD_REAL( 0.309011), CCD_REAL(-0.850654)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.850648), CCD_REAL(-0.000000), CCD_REAL(-0.525736)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.525730), CCD_REAL(-0.000000), CCD_REAL(-0.850652)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.688190), CCD_REAL(-0.499997), CCD_REAL(-0.525736)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.162456), CCD_REAL( 0.499995), CCD_REAL(-0.850654)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.688190), CCD_REAL( 0.499997), CCD_REAL(-0.525736)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.262869), CCD_REAL( 0.809012), CCD_REAL(-0.525738)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.951058), CCD_REAL( 0.309013), CCD_REAL( 0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.951058), CCD_REAL(-0.309013), CCD_REAL( 0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.587786), CCD_REAL(-0.809017), CCD_REAL( 0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.000000), CCD_REAL(-1.000000), CCD_REAL( 0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.587786), CCD_REAL(-0.809017), CCD_REAL( 0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.951058), CCD_REAL(-0.309013), CCD_REAL(-0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.951058), CCD_REAL( 0.309013), CCD_REAL(-0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.587786), CCD_REAL( 0.809017), CCD_REAL(-0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.000000), CCD_REAL( 1.000000), CCD_REAL(-0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.587786), CCD_REAL( 0.809017), CCD_REAL(-0.000000)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.688190), CCD_REAL(-0.499997), CCD_REAL( 0.525736)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.262869), CCD_REAL(-0.809012), CCD_REAL( 0.525738)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.850648), CCD_REAL( 0.000000), CCD_REAL( 0.525736)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.262869), CCD_REAL( 0.809012), CCD_REAL( 0.525738)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.688190), CCD_REAL( 0.499997), CCD_REAL( 0.525736)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.525730), CCD_REAL( 0.000000), CCD_REAL( 0.850652)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.162456), CCD_REAL(-0.499995), CCD_REAL( 0.850654)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.425323), CCD_REAL(-0.309011), CCD_REAL( 0.850654)),\n\tCCD_VEC3_STATIC(CCD_REAL(-0.425323), CCD_REAL( 0.309011), CCD_REAL( 0.850654)),\n\tCCD_VEC3_STATIC(CCD_REAL( 0.162456), CCD_REAL( 0.499995), CCD_REAL( 0.850654))\n};\nccd_vec3_t *ccd_points_on_sphere = points_on_sphere;\nsize_t ccd_points_on_sphere_len = sizeof(points_on_sphere) / sizeof(ccd_vec3_t);\n\n\n_ccd_inline ccd_real_t __ccdVec3PointSegmentDist2(const ccd_vec3_t *P,\n                                                  const ccd_vec3_t *x0,\n                                                  const ccd_vec3_t *b,\n                                                  ccd_vec3_t *witness)\n{\n    // The computation comes from solving equation of segment:\n    //      S(t) = x0 + t.d\n    //          where - x0 is initial point of segment\n    //                - d is direction of segment from x0 (|d| > 0)\n    //                - t belongs to <0, 1> interval\n    // \n    // Than, distance from a segment to some point P can be expressed:\n    //      D(t) = |x0 + t.d - P|^2\n    //          which is distance from any point on segment. Minimization\n    //          of this function brings distance from P to segment.\n    // Minimization of D(t) leads to simple quadratic equation that's\n    // solving is straightforward.\n    //\n    // Bonus of this method is witness point for free.\n\n    ccd_real_t dist, t;\n    ccd_vec3_t d, a;\n\n    // direction of segment\n    ccdVec3Sub2(&d, b, x0);\n\n    // precompute vector from P to x0\n    ccdVec3Sub2(&a, x0, P);\n\n    t  = -CCD_REAL(1.) * ccdVec3Dot(&a, &d);\n    t /= ccdVec3Len2(&d);\n\n    if (t < CCD_ZERO || ccdIsZero(t)){\n        dist = ccdVec3Dist2(x0, P);\n        if (witness)\n            ccdVec3Copy(witness, x0);\n    }else if (t > CCD_ONE || ccdEq(t, CCD_ONE)){\n        dist = ccdVec3Dist2(b, P);\n        if (witness)\n            ccdVec3Copy(witness, b);\n    }else{\n        if (witness){\n            ccdVec3Copy(witness, &d);\n            ccdVec3Scale(witness, t);\n            ccdVec3Add(witness, x0);\n            dist = ccdVec3Dist2(witness, P);\n        }else{\n            // recycling variables\n            ccdVec3Scale(&d, t);\n            ccdVec3Add(&d, &a);\n            dist = ccdVec3Len2(&d);\n        }\n    }\n\n    return dist;\n}\n\nccd_real_t ccdVec3PointSegmentDist2(const ccd_vec3_t *P,\n                                    const ccd_vec3_t *x0, const ccd_vec3_t *b,\n                                    ccd_vec3_t *witness)\n{\n    return __ccdVec3PointSegmentDist2(P, x0, b, witness);\n}\n\nccd_real_t ccdVec3PointTriDist2(const ccd_vec3_t *P,\n                                const ccd_vec3_t *x0, const ccd_vec3_t *B,\n                                const ccd_vec3_t *C,\n                                ccd_vec3_t *witness)\n{\n    // Computation comes from analytic expression for triangle (x0, B, C)\n    //      T(s, t) = x0 + s.d1 + t.d2, where d1 = B - x0 and d2 = C - x0 and\n    // Then equation for distance is:\n    //      D(s, t) = | T(s, t) - P |^2\n    // This leads to minimization of quadratic function of two variables.\n    // The solution from is taken only if s is between 0 and 1, t is\n    // between 0 and 1 and t + s < 1, otherwise distance from segment is\n    // computed.\n\n    ccd_vec3_t d1, d2, a;\n    ccd_real_t u, v, w, p, q, r, d;\n    ccd_real_t s, t, dist, dist2;\n    ccd_vec3_t witness2;\n\n    ccdVec3Sub2(&d1, B, x0);\n    ccdVec3Sub2(&d2, C, x0);\n    ccdVec3Sub2(&a, x0, P);\n\n    u = ccdVec3Dot(&a, &a);\n    v = ccdVec3Dot(&d1, &d1);\n    w = ccdVec3Dot(&d2, &d2);\n    p = ccdVec3Dot(&a, &d1);\n    q = ccdVec3Dot(&a, &d2);\n    r = ccdVec3Dot(&d1, &d2);\n\n    d = w * v - r * r;\n    if (ccdIsZero(d)){\n        // To avoid division by zero for zero (or near zero) area triangles\n        s = t = -1.;\n    }else{\n        s = (q * r - w * p) / d;\n        t = (-s * r - q) / w;\n    }\n\n    if ((ccdIsZero(s) || s > CCD_ZERO)\n            && (ccdEq(s, CCD_ONE) || s < CCD_ONE)\n            && (ccdIsZero(t) || t > CCD_ZERO)\n            && (ccdEq(t, CCD_ONE) || t < CCD_ONE)\n            && (ccdEq(t + s, CCD_ONE) || t + s < CCD_ONE)){\n\n        if (witness){\n            ccdVec3Scale(&d1, s);\n            ccdVec3Scale(&d2, t);\n            ccdVec3Copy(witness, x0);\n            ccdVec3Add(witness, &d1);\n            ccdVec3Add(witness, &d2);\n\n            dist = ccdVec3Dist2(witness, P);\n        }else{\n            dist  = s * s * v;\n            dist += t * t * w;\n            dist += CCD_REAL(2.) * s * t * r;\n            dist += CCD_REAL(2.) * s * p;\n            dist += CCD_REAL(2.) * t * q;\n            dist += u;\n        }\n    }else{\n        dist = __ccdVec3PointSegmentDist2(P, x0, B, witness);\n\n        dist2 = __ccdVec3PointSegmentDist2(P, x0, C, &witness2);\n        if (dist2 < dist){\n            dist = dist2;\n            if (witness)\n                ccdVec3Copy(witness, &witness2);\n        }\n\n        dist2 = __ccdVec3PointSegmentDist2(P, B, C, &witness2);\n        if (dist2 < dist){\n            dist = dist2;\n            if (witness)\n                ccdVec3Copy(witness, &witness2);\n        }\n    }\n\n    return dist;\n}\n"},{"name":"coder_posix_time.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/eml/externalDependency/timefun","tag":"","groupDisplay":"Other files","code":"/* MATLAB Coder time APIs */\n/* Copyright 2020-2021 The MathWorks, Inc. */\n\n/* Sort out the defines early before any headers are included\n * to avoid includes with inconsistent defines\n */\n#if (!defined(CODER_WINAPI)) && (defined(_WIN32))\n#define CODER_WINAPI\n#endif\n\n/* Ensure we get the right _POSIX_C_SOURCE and isolate our define to just this C file */\n#if !defined(CODER_WINAPI)\n#undef _POSIX_C_SOURCE\n#define _POSIX_C_SOURCE 199309L\n#endif\n\n#ifdef CODER_WINAPI\n#define NOMINMAX\n#include <windows.h>\n#endif /* CODER_WINAPI */\n\n#include \"coder_posix_time.h\"\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\n\n/* Prototypes */\n#ifndef CODER_WINAPI\n/**\n * @brief Convert coderTimeSpec to POSIX timespec\n *\n */\nstatic void coderToPOSIXTimespec(coderTimespec const * const aCoderTimespec,\n                                 struct timespec* const aTimespec);\n\n/**\n * @brief Convert POSIX timespec to coderTimeSpec\n *\n */\nstatic void posixToCoderTimespec(const struct timespec* const aTimespec,\n                                 coderTimespec* const aCoderTimespec);\n\nstatic void coderToPOSIXTimespec(coderTimespec const * const aCoderTimespec,\n                                 struct timespec* const aTimespec) {\n    aTimespec->tv_sec = (time_t)(aCoderTimespec->tv_sec);\n    aTimespec->tv_nsec = (long)(aCoderTimespec->tv_nsec);\n}\n\nstatic void posixToCoderTimespec(const struct timespec* const aTimespec,\n                                 coderTimespec* const aCoderTimespec) {\n    aCoderTimespec->tv_sec = (double)(aTimespec->tv_sec);\n    aCoderTimespec->tv_nsec = (double)(aTimespec->tv_nsec);\n}\n#endif /* CODER_WINAPI */\n\nint coderInitTimeFunctions(double* const aFrequency) {\n#ifdef CODER_WINAPI\n    LARGE_INTEGER freqL;\n    int status;\n    status = QueryPerformanceFrequency(&freqL);\n    *aFrequency = (double)freqL.QuadPart;\n    /* Invert status since in Windows, 0 means failure */    \n    return status == 0;\n#else\n    *aFrequency = 0.0;\n    return 0;\n#endif\n}\n\nint coderTimeClockGettimeMonotonic(coderTimespec* const aCoderTimespec, double aFrequency) {\n#ifdef CODER_WINAPI\n    static const double BILLION = 1e9;\n    LARGE_INTEGER timeL;\n    double timeDouble, timeRemainder, seconds, nanoseconds;\n    BOOL status = QueryPerformanceCounter(&timeL);\n    timeDouble = (double)timeL.QuadPart;\n    timeRemainder = fmod(timeDouble, aFrequency);\n    seconds = (timeDouble - timeRemainder) / aFrequency;\n    nanoseconds = (timeRemainder * BILLION) / aFrequency;\n    aCoderTimespec->tv_sec = seconds;\n    aCoderTimespec->tv_nsec = nanoseconds;\n\n    /* Invert status since in Windows, 0 means failure */\n    return status == 0;\n#else\n    struct timespec tspec;\n    int status;\n    (void) aFrequency;\n    status = clock_gettime(CLOCK_MONOTONIC, &tspec);\n    posixToCoderTimespec(&tspec, aCoderTimespec);\n    return status;\n#endif /* defined(_WIN32) || defined(WIN32) */\n}\n\nint coderTimeSleep(coderTimespec const * const aCoderTimespec) {\n#ifdef CODER_WINAPI\n    /* WIndows */\n    static const double MILLI = 1e3;\n    static const double BILLION = 1e9;\n    double delayMilli, delay;\n    DWORD delayUint32;\n    delayMilli = floor(aCoderTimespec->tv_nsec / (BILLION / MILLI));\n    delay = MILLI * aCoderTimespec->tv_sec + delayMilli;\n    delayUint32 = (DWORD)ceil(delay);\n    Sleep(delayUint32);\n    return 0;\n#else\n    /* POSIX */\n    struct timespec ts;\n    coderToPOSIXTimespec(aCoderTimespec, &ts);\n    return nanosleep(&ts, NULL);\n#endif\n}\n\nint coderLocalTime(coderTm* const aTm) {\n#ifdef CODER_WINAPI\n    /* WIndows */\n    SYSTEMTIME sysTime;\n    TIME_ZONE_INFORMATION tzInfo;\n    DWORD dstInfo;\n    GetLocalTime(&sysTime);\n    aTm->tm_nsec = ((long)sysTime.wMilliseconds) * 1000000;\n    aTm->tm_sec = sysTime.wSecond;\n    aTm->tm_min = sysTime.wMinute;\n    aTm->tm_hour = sysTime.wHour;\n    aTm->tm_mday = sysTime.wDay;\n    aTm->tm_mon = sysTime.wMonth;\n    aTm->tm_year = sysTime.wYear;\n    aTm->tm_wday = 0;\n    aTm->tm_yday = 0;\n\n    dstInfo = GetTimeZoneInformation(&tzInfo);\n    aTm->tm_isdst = dstInfo == TIME_ZONE_ID_DAYLIGHT;\n    return 0;\n#else\n    /* POSIX */\n    struct timespec ts;\n    struct tm* tmVal;\n    int status;\n    const int YEAR_OFFSET = 1900; /* +1900 for human year */\n    const int MONTH_OFFSET = 1; /* +1 for 1-based month */\n    status = clock_gettime(CLOCK_REALTIME, &ts);\n    tmVal = localtime(&ts.tv_sec);\n    aTm->tm_nsec = ts.tv_nsec;\n    aTm->tm_sec = tmVal->tm_sec;\n    aTm->tm_min = tmVal->tm_min;\n    aTm->tm_hour = tmVal->tm_hour;\n    aTm->tm_mday = tmVal->tm_mday;\n    aTm->tm_mon = tmVal->tm_mon + MONTH_OFFSET;\n    aTm->tm_year = tmVal->tm_year + YEAR_OFFSET;\n    aTm->tm_wday = tmVal->tm_wday;\n    aTm->tm_yday = tmVal->tm_yday;\n    aTm->tm_isdst = tmVal->tm_isdst;\n\n    return status;\n#endif\n}\n"},{"name":"collisioncodegen_CollisionGeometry.cpp","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/shared/robotics/robotcore/builtins/libsrc/collisioncodegen","tag":"","groupDisplay":"Other files","code":"// Copyright 2018-2019 The MathWorks, Inc.\n\n#ifdef BUILDING_LIBMWCOLLISIONCODEGEN\n    #include \"collisioncodegen/collisioncodegen_CollisionGeometry.hpp\"\n#else // during portable codegen, all files are placed in a flat directory\n    #include \"collisioncodegen_CollisionGeometry.hpp\"\n#endif\n\n#include <iostream>\n#include <algorithm>\n\nnamespace shared_robotics\n{\n\tvoid CollisionGeometryDeleter::operator()(CollisionGeometry* ptr)\n\t{\n\t\tdelete ptr;\n\t}\n}\n\nnamespace shared_robotics\n{\n    CollisionGeometry::~CollisionGeometry()\n    {\n        //std::cout << \"A collision geometry of type \" << getType() << \" is destroyed\" << std::endl; \n    }\n\n\n    /// compute the support point with interface to libccd\n    void CollisionGeometry::support(const ccd_vec3_t* ccdDir, ccd_vec3_t* ccdSupportVertex) const\n    {\n        // dir should always have non-zero length\n\n        ccd_quat_t quatInv = { {0, 0, 0, 1} };\n        ccdQuatInvert2(&quatInv, &m_quat);\n        ccd_vec3_t dirRot = { {0, 0, 0} };\n        ccd_vec3_t vert = { {0, 0, 0} };\n        \n        ccdVec3Copy(&dirRot, ccdDir);\n        ccdQuatRotVec(&dirRot, &quatInv); // rotate dir into geometry's coordinates\n\n        switch(m_type)\n        {\n        case Type::Box: // for box primitive\n        {\n            ccdVec3Set(&vert, CollisionGeometry::sign(dirRot.v[0])*m_x*CCD_REAL(0.5),\n                CollisionGeometry::sign(dirRot.v[1])*m_y*CCD_REAL(0.5),\n                CollisionGeometry::sign(dirRot.v[2])*m_z*CCD_REAL(0.5));\n            break;\n        }\n        case Type::Sphere:\n        {\n            ccd_real_t len = CCD_SQRT(ccdVec3Len2(&dirRot));\n            ccd_real_t scale = m_radius / len;\n\n            ccdVec3Copy(&vert, &dirRot);\n            ccdVec3Scale(&vert, scale);\n\n            break;\n        }\n        case Type::Cylinder:\n        {\n            ccd_real_t xyShadow = CCD_SQRT(dirRot.v[0] * dirRot.v[0] + dirRot.v[1] * dirRot.v[1]);\n            if (CCD_FABS(xyShadow) < 5 * CCD_EPS) // with double-precision built ccd, CCD_EPS is DBL_EPSILON in float.h, around 2.22045e-16\n            {\n                ccdVec3Set(&vert, CCD_ZERO, CCD_ZERO, sign(dirRot.v[2])*m_height*CCD_REAL(0.5));\n            }\n            else\n            {\n                ccd_real_t scale = m_radius / xyShadow;\n                ccdVec3Set(&vert, scale * dirRot.v[0], scale * dirRot.v[1], sign(dirRot.v[2])*m_height*CCD_REAL(0.5));\n            }\n            break;\n        }\n        case Type::ConvexMesh:\n        {\n            std::vector<ccd_real_t> dotProd;\n            for (auto&& v : m_vertices)\n            {\n                dotProd.push_back(v.v[0] * dirRot.v[0] + v.v[1] * dirRot.v[1] + v.v[2] * dirRot.v[2]);\n            }\n            auto largestItemIter = std::max_element(dotProd.begin(), dotProd.end());\n            std::size_t idx = largestItemIter - dotProd.begin();\n            ccdVec3Set(&vert, m_vertices[idx].v[0], m_vertices[idx].v[1], m_vertices[idx].v[2]);\n            break;\n        }\n        case Type::ConvexMeshFull:\n        default:\n        {\n            // In hill climbing traversal, we can keep track of the indices of visited nodes in a vector\n            // to avoid checking previously visited nodes, but it turns out there is not much performance\n            // gain by doing this, and it is in fact quite costly if we try to recreate this vector\n            // in every support call\n\n            // std::vector<int> visited(m_numVertices, 0)\n\n            ccd_real_t maxValue = m_vertices[0].v[0] * dirRot.v[0] + m_vertices[0].v[1] * dirRot.v[1] + m_vertices[0].v[2] * dirRot.v[2];\n            ccd_real_t val = maxValue;\n            std::size_t currVertIdx = 0;\n            std::size_t nextVertIdx = currVertIdx;\n\n            int numIter = 0;\n            do\n            {\n                currVertIdx = nextVertIdx;\n                for (std::size_t k = 0; k < m_connectionList[currVertIdx].size(); k++)\n                {\n                    std::size_t idx = static_cast<std::size_t>(m_connectionList[currVertIdx][k]);\n                    val = ccdVec3Dot( &m_vertices[idx], &dirRot );\n                    if (val > maxValue)\n                    {\n                        maxValue = val;\n                        nextVertIdx = m_connectionList[currVertIdx][k];\n                    }\n                    numIter++;\n\n                }\n\n            } while (currVertIdx != nextVertIdx);\n            //std::cout << \"numIter = \" << numIter << std::endl\n            ccdVec3Set(&vert, m_vertices[currVertIdx].v[0], m_vertices[currVertIdx].v[1], m_vertices[currVertIdx].v[2]);\n            \n        }\n\n        }\n\n        // transform support point to world coordinates (quat * vert + pos)\n        ccdQuatRotVec(&vert, &m_quat);\n        ccdVec3Add(&vert, &m_pos);\n        ccdVec3Copy(ccdSupportVertex, &vert);\n\n    }\n\n    /// \n    void CollisionGeometry::constructConnectionList()\n    {\n        std::cout << \"construct connection list\" << std::endl;\n        // initialize\n        m_connectionList.resize(m_numVertices);\n        for (std::size_t i = 0; i < m_numVertices; i++)\n        {\n            m_connectionList[i].resize(16);\n            m_connectionList[i].clear();\n        }\n\n        // populate\n        for (std::size_t j = 0; j < m_numFaces; j++)\n        {\n            m_connectionList[m_faces[j].v[0]].push_back(m_faces[j].v[1]);\n            m_connectionList[m_faces[j].v[0]].push_back(m_faces[j].v[2]);\n            m_connectionList[m_faces[j].v[1]].push_back(m_faces[j].v[0]);\n            m_connectionList[m_faces[j].v[1]].push_back(m_faces[j].v[2]);\n            m_connectionList[m_faces[j].v[2]].push_back(m_faces[j].v[0]);\n            m_connectionList[m_faces[j].v[2]].push_back(m_faces[j].v[1]);\n        }\n\n        // reduce\n        for (std::size_t i = 0; i < m_numVertices; i++)\n        {\n            std::sort(m_connectionList[i].begin(), m_connectionList[i].end());\n            auto last = std::unique(m_connectionList[i].begin(), m_connectionList[i].end());\n            m_connectionList[i].erase(last, m_connectionList[i].end());\n        }\n    }\n\n\n} // namespace shared_robotics\n"},{"name":"collisioncodegen_api.cpp","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/shared/robotics/robotcore/builtins/libsrc/collisioncodegen","tag":"","groupDisplay":"Other files","code":"/* Copyright 2019-2021 The MathWorks, Inc. */\n#ifdef BUILDING_LIBMWCOLLISIONCODEGEN\n#include \"collisioncodegen/collisioncodegen_api.hpp\"\n#include \"collisioncodegen/collisioncodegen_checkCollision_api.hpp\"\n#include \"collisioncodegen/collisioncodegen_CollisionGeometry.hpp\"\n#else\n#include \"collisioncodegen_api.hpp\"\n#include \"collisioncodegen_checkCollision_api.hpp\"\n#include \"collisioncodegen_CollisionGeometry.hpp\"\n#endif\n\nCollisionGeometryPtr collisioncodegen_makeBox(double x, double y, double z)\n{\n    return static_cast<void*>(new shared_robotics::CollisionGeometry(x, y, z));\n}\n\nCollisionGeometryPtr collisioncodegen_makeSphere(double r)\n{\n    return static_cast<void*>(new shared_robotics::CollisionGeometry(r));\n}\n\nCollisionGeometryPtr collisioncodegen_makeCylinder(double r, double h)\n{\n    return static_cast<void*>(new shared_robotics::CollisionGeometry(r, h));\n}\n\nCollisionGeometryPtr collisioncodegen_makeMesh(double *vertices, double numVertices) \n{\n    return static_cast<void*>(new shared_robotics::CollisionGeometry(vertices, static_cast<int>(numVertices), true));\n}\n\nvoid collisioncodegen_destructGeometry(const CollisionGeometryPtr* objPtr) {\n    // The destructor accepts a pointer to a pointer. This is required because\n    // of g2415822. We are destroying what objPtr holds, and not objPtr itself.\n    // Here objPtr is read-only.\n    if (*objPtr != nullptr) {\n        delete static_cast<shared_robotics::CollisionGeometry*>(*objPtr);\n    }\n}\n\nint collisioncodegen_intersect(CollisionGeometryPtr obj1,\n                              double* pos1, \n                              double* quat1,\n                              CollisionGeometryPtr obj2,\n                              double* pos2, \n                              double* quat2,\n                              double computeDistance,\n                              double* p1Vec,\n                              double* p2Vec,\n                              double* distance)\n{\n    shared_robotics::updatePose(obj1, pos1, quat1);\n    shared_robotics::updatePose(obj2, pos2, quat2);\n    return shared_robotics::intersect(obj1, obj2, static_cast<int>(computeDistance), p1Vec, p2Vec, *distance);\n}\n"},{"name":"collisioncodegen_ccdExtensions.cpp","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/shared/robotics/robotcore/builtins/libsrc/collisioncodegen","tag":"","groupDisplay":"Other files","code":"// Copyright 2018-2019 The MathWorks, Inc.\n\n#ifdef BUILDING_LIBMWCOLLISIONCODEGEN\n    #include \"collisioncodegen/collisioncodegen_ccdExtensions.hpp\"\n    #include <ccd/ccd_simplex.h>\n#else // during portable codegen, all files are placed in a flat directory\n    #include \"collisioncodegen_ccdExtensions.hpp\"\n    #include <ccd_simplex.h>\n#endif\n\n#include <vector>\n#include <limits>\n\nusing namespace shared_robotics;\n\nvoid barycentricCoordinates(const ccd_vec3_t * a, const ccd_vec3_t * b, const ccd_vec3_t * c, const ccd_vec3_t * p, ccd_vec3_t * lambda);\n\nccd_real_t shared_robotics::distanceToOrigin(ccd_simplex_t * simplex, ccd_vec3_t *& closestPoint)\n{\n    // find the distance from origin to the given simplex\n\n    ccd_real_t distSq;\n    ccd_real_t distance = 0;\n\n    switch (ccdSimplexSize(simplex)) \n    {\n    case 1: // point\n    {\n        closestPoint->v[0] = simplex->ps[0].v.v[0];\n        closestPoint->v[1] = simplex->ps[0].v.v[1];\n        closestPoint->v[2] = simplex->ps[0].v.v[2];\n        distSq = ccdVec3Len2(closestPoint);\n        distance = CCD_SQRT(distSq);\n        break;\n    }\n    case 2: // line segment\n    {\n        ccd_vec3_t p0 = simplex->ps[0].v;\n        ccd_vec3_t p1 = simplex->ps[1].v;\n        distSq = ccdVec3PointSegmentDist2(ccd_vec3_origin, &p0, &p1, closestPoint);\n        distance = CCD_SQRT(distSq);\n        break;\n    }\n    case 3: // triangle\n    {\n        ccd_vec3_t p0 = simplex->ps[0].v;\n        ccd_vec3_t p1 = simplex->ps[1].v;\n        ccd_vec3_t p2 = simplex->ps[2].v;\n        distSq = ccdVec3PointTriDist2(ccd_vec3_origin, &p0, &p1, &p2, closestPoint);\n        distance = CCD_SQRT(distSq);\n        break;\n    }\n    default: // simplex can be a tetrahedron. \n             // The simplex generated by GJK is not necessarily sufficiently refined/reduced to report the actual distance\n    {\n        // cycle through all faces in the tetrahedron and find the one with shortest distance to origin\n\n        const std::size_t indices[4][3] = { { 3,1,2 },{ 0,3,2 },{ 0,1,3 },{ 0,1,2 }}; // >> combnk([0 1 2 3], 3)\n        ccd_vec3_t closestPointCandidate;\n\n        ccd_real_t bestDistSq = -1;\n        std::size_t bestIdx = 0;\n        for (std::size_t i = 0; i <= 3; i++)\n        {\n            ccd_vec3_t p0 = simplex->ps[indices[i][0]].v;\n            ccd_vec3_t p1 = simplex->ps[indices[i][1]].v;\n            ccd_vec3_t p2 = simplex->ps[indices[i][2]].v;\n\n            distSq = ccdVec3PointTriDist2(ccd_vec3_origin, &p0, &p1, &p2, &closestPointCandidate);\n            if (i == 0)\n            {\n                bestDistSq = distSq;\n                bestIdx = 0;\n                closestPoint->v[0] = closestPointCandidate.v[0];\n                closestPoint->v[1] = closestPointCandidate.v[1];\n                closestPoint->v[2] = closestPointCandidate.v[2];\n            }\n            else if (distSq < bestDistSq)\n            {\n                bestDistSq = distSq;\n                bestIdx = i;\n                closestPoint->v[0] = closestPointCandidate.v[0];\n                closestPoint->v[1] = closestPointCandidate.v[1];\n                closestPoint->v[2] = closestPointCandidate.v[2];\n            }\n        }\n        distance = CCD_SQRT(bestDistSq);\n        // also reduce tetrahedron to triangle\n        if (bestIdx < 3)\n        {\n            simplex->ps[bestIdx] = simplex->ps[3];\n        }\n        simplex->last = 2;\n    }\n    }\n\n    return distance;\n}\n\n\nvoid shared_robotics::extractWitnessPoints(const ccd_simplex_t *simplex, const ccd_vec3_t *closestPoint, ccd_vec3_t *p1, ccd_vec3_t *p2)\n{\n    // witness points: a pair of points from the two objects that realize the minimum separation distance between them.\n    switch (ccdSimplexSize(simplex))\n    {\n    case 1:// point\n    {\n        *p1 = simplex->ps[0].v1;\n        *p2 = simplex->ps[0].v2;\n        break;\n    }\n    case 2: // line segment\n    {\n        interpolateBetweenTwoSupportPoints(simplex, closestPoint, p1, p2);\n        break;\n    }\n    case 3: // triangle\n    {\n        interpolateAmongThreeSupportPoints(simplex, closestPoint, p1, p2);\n        break;\n    }\n    }\n\n}\n\nvoid shared_robotics::interpolateBetweenTwoSupportPoints(const ccd_simplex_t *& simplex, const ccd_vec3_t *& closestPoint, ccd_vec3_t *& p1, ccd_vec3_t *& p2)\n{\n    // interpolate between two support points m, n\n    //\n    // o------------o-------------o\n    // m(m1,m2)     p(p1,p2)      n(n1,n2)\n    //\n    ccd_vec3_t m, n, p, dp, dn;\n    ccdVec3Copy(&m, &simplex->ps[0].v);\n    ccdVec3Copy(&n, &simplex->ps[1].v);\n    ccdVec3Copy(&p, closestPoint);\n\n    ccdVec3Sub2(&dp, &p, &m);\n    ccdVec3Sub2(&dn, &n, &m);\n    auto dpm = CCD_SQRT(ccdVec3Len2(&dp));\n    auto dnm = CCD_SQRT(ccdVec3Len2(&dn));\n\n    if (dnm < std::numeric_limits<ccd_real_t>::epsilon())\n    {\n        *p1 = simplex->ps[0].v1;\n        *p2 = simplex->ps[0].v2;\n    }\n    else\n    {\n        ccd_vec3_t m1, m2, n1, n2, tmp, tmp2;\n        ccdVec3Copy(&m1, &simplex->ps[0].v1);\n        ccdVec3Copy(&m2, &simplex->ps[0].v2);\n        ccdVec3Copy(&n1, &simplex->ps[1].v1);\n        ccdVec3Copy(&n2, &simplex->ps[1].v2);\n\n        auto s = dpm / dnm;\n        ccdVec3Sub2(&tmp, &n1, &m1);\n        ccdVec3Scale(&tmp, s);\n        ccdVec3Add(&tmp, &m1);\n        \n        ccdVec3Copy(p1, &tmp);\n\n        ccdVec3Sub2(&tmp2, &n2, &m2);\n        ccdVec3Scale(&tmp2, s);\n        ccdVec3Add(&tmp2, &m2);\n        \n        ccdVec3Copy(p2, &tmp2);\n    }\n}\n\n/// convert a point's position in global coordinates to the barycentric coordinates defined by three points in global coordinates (internal use only).\nvoid barycentricCoordinates(const ccd_vec3_t * a, const ccd_vec3_t * b, const ccd_vec3_t * c, const ccd_vec3_t * p, ccd_vec3_t * lambda)\n{\n    // a, b, c must not be co-linear\n    ccd_vec3_t ab, ac, bc, bp, cp, n, na, nb, neg_ac;\n    ccdVec3Sub2(&ab, b, a);\n    ccdVec3Sub2(&ac, c, a);\n    ccdVec3Sub2(&bc, c, b);\n\n    ccdVec3Sub2(&bp, p, b);\n    ccdVec3Sub2(&cp, p, c);\n\n    ccdVec3Cross(&n, &ab, &ac);\n    ccdVec3Cross(&na, &bc, &bp);\n    ccdVec3Copy(&neg_ac, &ac);\n    ccdVec3Scale(&neg_ac, -1);\n    ccdVec3Cross(&nb, &neg_ac, &cp);\n\n\n    ccd_real_t nn = ccdVec3Dot(&n, &n);\n    ccd_real_t alpha = ccdVec3Dot(&n, &na) / nn;\n    ccd_real_t beta = ccdVec3Dot(&n, &nb) / nn;\n\n    ccdVec3Set(lambda, alpha, beta, 1 - alpha - beta);\n}\n\nvoid shared_robotics::interpolateAmongThreeSupportPoints(const ccd_simplex_t *& simplex, const ccd_vec3_t *& closestPoint, ccd_vec3_t *& p1, ccd_vec3_t *& p2)\n{\n    /* interpolate between three support points a, b, c\n\n               o a(a1,a2)\n              / \\\n             /   \\\n            /     \\\n           /       \\\n          /  o      \\\n         /   p(p1,p2)\\\n        o-------------o\n        b(b1,b2)       c(c1,c2)\n    */\n\n    ccd_vec3_t a, b, c, p, baVec, caVec, cbVec, crprod;\n    ccdVec3Copy(&a, &simplex->ps[0].v);\n    ccdVec3Copy(&b, &simplex->ps[1].v);\n    ccdVec3Copy(&c, &simplex->ps[2].v);\n    ccdVec3Copy(&p, closestPoint);\n    \n    ccdVec3Sub2(&baVec, &b, &a);\n    ccdVec3Sub2(&caVec, &c, &a);\n    ccdVec3Cross(&crprod, &baVec, &caVec);\n\n    ccdVec3Sub2(&cbVec, &c, &b);\n\n    if ( CCD_SQRT(ccdVec3Len2(&crprod)) < std::numeric_limits<ccd_real_t>::epsilon()) // if triangle area is zero\n    {\n        ccd_simplex_t simplexTmp;\n        ccd_real_t ab = CCD_SQRT(ccdVec3Len2(&baVec));\n        ccd_real_t ac = CCD_SQRT(ccdVec3Len2(&caVec));\n        ccd_real_t bc = CCD_SQRT(ccdVec3Len2(&cbVec));\n\n        simplexTmp.last = 1;\n        if (ab >= ac && ab >= bc)\n        {\n            simplexTmp.ps[0] = simplex->ps[0];\n            simplexTmp.ps[1] = simplex->ps[1];\n        }\n        else if (ac > ab && ac > bc)\n        {\n            simplexTmp.ps[0] = simplex->ps[0];\n            simplexTmp.ps[1] = simplex->ps[2];\n        }\n        else\n        {\n            simplexTmp.ps[0] = simplex->ps[1];\n            simplexTmp.ps[1] = simplex->ps[2];\n        }\n\n        const ccd_simplex_t * simplexPtr = &simplexTmp;\n        interpolateBetweenTwoSupportPoints(simplexPtr, closestPoint, p1, p2);\n    }\n    else\n    {\n        ccd_vec3_t lambda = { {0, 0, 0} };\n        barycentricCoordinates(&a, &b, &c, &p, &lambda);\n\n        ccd_vec3_t a1, a2, b1, b2, c1, c2;\n        ccd_vec3_t tmp1 = { {0, 0, 0} };\n        ccd_vec3_t tmp2 = { {0, 0, 0} };\n        ccdVec3Copy(&a1, &simplex->ps[0].v1);\n        ccdVec3Copy(&a2, &simplex->ps[0].v2);\n\n        ccdVec3Copy(&b1, &simplex->ps[1].v1);\n        ccdVec3Copy(&b2, &simplex->ps[1].v2);\n\n        ccdVec3Copy(&c1, &simplex->ps[2].v1);\n        ccdVec3Copy(&c2, &simplex->ps[2].v2);\n\n        ccdVec3Scale(&a1, lambda.v[0]);\n        ccdVec3Scale(&b1, lambda.v[1]);\n        ccdVec3Scale(&c1, lambda.v[2]);\n\n        ccdVec3Add(&tmp1, &a1);\n        ccdVec3Add(&tmp1, &b1);\n        ccdVec3Add(&tmp1, &c1);\n\n        ccdVec3Copy(p1, &tmp1);\n\n        ccdVec3Scale(&a2, lambda.v[0]);\n        ccdVec3Scale(&b2, lambda.v[1]);\n        ccdVec3Scale(&c2, lambda.v[2]);\n\n        ccdVec3Add(&tmp2, &a2);\n        ccdVec3Add(&tmp2, &b2);\n        ccdVec3Add(&tmp2, &c2);\n\n        ccdVec3Copy(p2, &tmp2);\n    }\n\n}\n\n\n\nccd_real_t shared_robotics::ccdDistance(const void *obj1, const void *obj2, const ccd_t *ccd,\n                ccd_vec3_t* p1, ccd_vec3_t* p2)\n{\n    ccd_simplex_t simplex; // double check\n    ccd_vec3_t closestPoint; // placeholder\n    ccd_real_t distance = -1;\n    ccd_real_t lastDistance;\n\n    ccd_simplex_t * simplexPtr = &simplex;\n    ccd_vec3_t *closestPointPtr = &closestPoint; \n\n    if (__ccdGJK(obj1, obj2, ccd, &simplex) == 0) // __ccdGJK return -1 if intersection is not found or 0 if intersection is found\n    {\n        return -CCD_ONE;\n    }\n    \n    int maxIterations = static_cast<int>(ccd->max_iterations);\n    lastDistance = CCD_REAL_MAX;\n\n    // if the input simplex comes out from __ccdGJK,\n    // in many cases, the for-loop should exit after the first iteration\n    for (int i = 0; i < maxIterations; i++)  \n    {\n\n        distance = distanceToOrigin(simplexPtr, closestPointPtr);\n\n        if (CCD_FABS(lastDistance - distance) < ccd->dist_tolerance) // if no further improvement\n        {\n            // interpolate to populate p1, p2\n            extractWitnessPoints(simplexPtr, closestPointPtr, p1, p2);\n            return distance;\n        }\n        \n        lastDistance = distance;\n\n        // further examination\n        // validate the closest point through support direction\n        // compute the support direction based on the direction as determined by the current closestPoint \n        ccd_vec3_t dir = { -closestPointPtr->v[0], -closestPointPtr->v[1], -closestPointPtr->v[2] };\n        ccd_support_t closestPointNew;\n        __ccdSupport(obj1, obj2, &dir, ccd, &closestPointNew);\n        distance = CCD_SQRT(ccdVec3Len2(&closestPointNew.v));\n\n        // if the acquired support point deviates from the closestPoint candidate\n        // add the support point to the simplex and rerun distance function\n        // but we need to first check if the new support point coincides with any existing ones\n        \n        int samePoint = 0;\n        for (std::size_t q = 0; q <= static_cast<std::size_t>(simplex.last); q++)\n        {\n            samePoint = samePoint || ccdVec3Eq(&closestPointNew.v, &simplex.ps[q].v);\n        }\n        \n        if (!samePoint)\n        {\n            simplex.ps[simplex.last + 1] = closestPointNew;\n            simplex.last += 1;\n        }\n\n        // for debugging, uncomment the following lines to step through the simplex migration \n        //std::cout << \"----------Iter \" << i << \"-------------\" << std::endl;\n        //for (std::size_t q = 0; q <= simplex.last; q++)\n        //{\n        //    std::cout << \"simplex ps[\" << q << \"] = [ \" << simplex.ps[q].v.v[0] << \" \" << simplex.ps[q].v.v[1] << \" \" << simplex.ps[q].v.v[2] << \" ] \" << std::endl;\n        //}\n\n    }\n\n    // reach iteration limit\n    extractWitnessPoints(simplexPtr, closestPointPtr, p1, p2);\n    return distance;\n    \n}\n"},{"name":"collisioncodegen_checkCollision.cpp","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/shared/robotics/robotcore/builtins/libsrc/collisioncodegen","tag":"","groupDisplay":"Other files","code":"// Copyright 2018-2019 The MathWorks, Inc.\n\n#include <vector>\n#include <iostream>\n\n#ifdef BUILDING_LIBMWCOLLISIONCODEGEN\n#include \"collisioncodegen/collisioncodegen_checkCollision_api.hpp\"\n#include <ccd/ccd_ccd.h>\n#else // during portable codegen, all files are placed in a flat directory\n#include \"collisioncodegen_checkCollision_api.hpp\"\n#include <ccd_ccd.h>\n#endif\n\n\nusing namespace shared_robotics;\n\nstatic void fSupport(const void* obj, const ccd_vec3_t* dir, ccd_vec3_t* supportPoint);\n\nEXTERN_C COLLISIONCODEGEN_API int shared_robotics::intersect(const void* obj1, const void* obj2, int computeDistance, ccd_real_t* p1Vec, ccd_real_t* p2Vec, ccd_real_t& distance)\n{\n        ccd_t ccd;\n        CCD_INIT(&ccd); // initialize ccd_t struct\n        ccd_support_fn f = &fSupport;\n        ccd.support1 = f;\n        ccd.support2 = f;\n        ccd.max_iterations = 100; // maximal number of iterations\n\n        int result;\n        ccd_vec3_t p1 = {{0, 0, 0}};\n        ccd_vec3_t p2 = {{0, 0, 0}};\n        distance = -CCD_ONE;\n        p1Vec[0] = 0;\n        p1Vec[1] = 0;\n        p1Vec[2] = 0;\n\n        p2Vec[0] = 0;\n        p2Vec[1] = 0;\n        p2Vec[2] = 0;\n\n        // std::cout << \"computeDistance = \" <<computeDistance << std::endl;\n        if (computeDistance) \n        {\n            // returns -1 if two bodies intersect, otherwise returns the minimal distance\n            distance = ccdDistance(obj1, obj2, &ccd, &p1, &p2);\n\n            p1Vec[0] = p1.v[0];\n            p1Vec[1] = p1.v[1];\n            p1Vec[2] = p1.v[2];\n\n            p2Vec[0] = p2.v[0];\n            p2Vec[1] = p2.v[1];\n            p2Vec[2] = p2.v[2];\n\n            if (distance < 0) \n            {\n                result = 1;\n            } \n            else \n            {\n                result = 0;\n            }\n        } \n        else \n        {\n            // returns 1 if two objects intersect\n            result = ccdGJKIntersect(obj1, obj2, &ccd);\n        }\n\n        return result;\n}\n\nEXTERN_C COLLISIONCODEGEN_API void shared_robotics::updatePose(void* obj, const ccd_real_t* position, const ccd_real_t* orientation) \n{\n    auto geom = static_cast<CollisionGeometry*>(obj);\n    ccdVec3Set(&geom->m_pos, static_cast<ccd_real_t>(position[0]), static_cast<ccd_real_t>(position[1]), static_cast<ccd_real_t>(position[2]));\n    ccdQuatSet(&geom->m_quat, static_cast<ccd_real_t>(orientation[1]), static_cast<ccd_real_t>(orientation[2]), static_cast<ccd_real_t>(orientation[3]), static_cast<ccd_real_t>(orientation[0])); // x,y,z,w in ccd\n}\n\nstatic void fSupport(const void* obj, const ccd_vec3_t* dir, ccd_vec3_t* supportPoint)\n{\n    auto geomPtr = (static_cast<const CollisionGeometry*>(obj));\n    geomPtr->support(dir, supportPoint);\n}\n"},{"name":"main.cpp","type":"source","group":"legacy","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"//\n// File main.cpp\n//\n// Code generated for Simulink model 'inverse_kinematics'.\n//\n// Model version                  : 4.7\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n// C/C++ source code generated on : Sun Oct 02 23:17:41 2022\n//\n\n#include <stdio.h>\n#include \"rosnodeinterface.h\"\n#include \"slros_initialize.h\"\n\nextern void slros_node_init(int argc, char** argv);\nnamespace ros\n{\n  namespace matlab\n  {\n    std::shared_ptr<ros::matlab::NodeInterface> gMatlabNodeIntr;\n    std::shared_ptr<ros::matlab::NodeInterface> getNodeInterface()\n    {\n      return gMatlabNodeIntr;\n    }\n  }                                    //namespace matlab\n}                                      //namespace ros\n\nint main(int argc, char* argv[])\n{\n  // create the Node specified in Model\n  slros_node_init(argc, argv);\n  ros::matlab::gMatlabNodeIntr = std::make_shared<ros::matlab::NodeInterface>();\n  ros::matlab::gMatlabNodeIntr->initialize(argc, argv);\n  auto ret = ros::matlab::gMatlabNodeIntr->run();\n  ros::matlab::gMatlabNodeIntr->terminate();\n  ros::matlab::gMatlabNodeIntr.reset();\n  return ret;\n}\n"},{"name":"rosnodeinterface.cpp","type":"source","group":"legacy","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"//\n// File rosnodeinterface.cpp\n//\n// Code generated for Simulink model 'inverse_kinematics'.\n//\n// Model version                  : 4.7\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n// C/C++ source code generated on : Sun Oct 02 23:17:41 2022\n//\n\n#ifdef _MSC_VER\n\n#pragma warning(push)\n#pragma warning(disable : 4244)\n#pragma warning(disable : 4265)\n#pragma warning(disable : 4458)\n#pragma warning(disable : 4100)\n\n#else\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpedantic\"\n#pragma GCC diagnostic ignored \"-Wunused-local-typedefs\"\n#pragma GCC diagnostic ignored \"-Wredundant-decls\"\n#pragma GCC diagnostic ignored \"-Wnon-virtual-dtor\"\n#pragma GCC diagnostic ignored \"-Wdelete-non-virtual-dtor\"\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n#pragma GCC diagnostic ignored \"-Wshadow\"\n\n#endif                                 //_MSC_VER\n\n#include \"inverse_kinematics.h\"\n#include \"rosnodeinterface.h\"\n#include <thread>\n#include <chrono>\n#include <utility>\n\nnamespace ros\n{\n  namespace matlab\n  {\n    NodeInterface::NodeInterface()\n      : mNode()\n      , mBaseRateSem()\n      , mBaseRateThread()\n      , mSchedulerThread()\n      , mStopSem()\n      , mRunModel(true)\n    {\n    }\n\n    NodeInterface::~NodeInterface()\n    {\n      terminate();\n    }\n\n    void NodeInterface::initialize(int argc, char ** argv)\n    {\n      try {\n        mNode = std::make_shared<ros::NodeHandle>();\n        ROS_INFO(\"** Starting the model \\\"inverse_kinematics\\\" **\\n\");\n\n        // initialize the model which will initialize the publishers and subscribers\n        rtmSetErrorStatus(inverse_kinematics_M, (NULL));\n        inverse_kinematics_initialize();\n\n        // create the threads for the rates in the Model\n        mBaseRateThread = std::make_shared<std::thread>(&NodeInterface::\n          baseRateTask, this);\n\n        // create scheduler thread\n        mSchedulerThread = std::make_shared<std::thread>(&NodeInterface::\n          schedulerThread, this);\n      } catch (std::exception& ex) {\n        std::cout << ex.what() << std::endl;\n        throw ex;\n      }\n    }\n\n    int NodeInterface::run()\n    {\n      ros::spin();\n      mRunModel = false;\n      return 0;\n    }\n\n    boolean_T NodeInterface::getStopRequestedFlag(void)\n    {\n\n#ifndef rtmGetStopRequested\n\n      return (!(rtmGetErrorStatus(inverse_kinematics_M)\n                == (NULL)));\n\n#else\n\n      return (!(rtmGetErrorStatus(inverse_kinematics_M)\n                == (NULL)) || rtmGetStopRequested(inverse_kinematics_M));\n\n#endif\n\n    }\n\n    void NodeInterface::terminate(void)\n    {\n      if (mBaseRateThread.get()) {\n        mBaseRateSem.notify();\n        mBaseRateThread->join();\n        mRunModel = false;\n        mBaseRateThread.reset();\n        if (mSchedulerThread.get()) {\n          mSchedulerThread->join();\n          mSchedulerThread.reset();\n        }\n\n        inverse_kinematics_terminate();\n        mNode.reset();\n      }\n    }\n\n    //\n    // Scheduler Task using ROS Wall clock timer to run base-rate\n    //\n    void NodeInterface::schedulerThread(void)\n    {\n      while (mRunModel) {\n        std::this_thread::sleep_for(std::chrono::nanoseconds(10000000));\n        mBaseRateSem.notify();\n      }\n    }\n\n    // Base-rate task\n    void NodeInterface::baseRateTask(void)\n    {\n      mRunModel = (rtmGetErrorStatus(inverse_kinematics_M) ==\n                   (NULL));\n      while (mRunModel) {\n        mBaseRateSem.wait();\n\n#ifdef MW_DEBUG_LOG\n\n        ROS_INFO(\"** Base rate task semaphore received\\n\");\n\n#endif\n\n        if (!mRunModel)\n          break;\n        inverse_kinematics_step();\n        mRunModel = !NodeInterface::getStopRequestedFlag();\n      }\n\n      // Shutdown the ROS node\n      ros::shutdown();\n    }\n  }                                    //namespace matlab\n}                                      //namespace ros\n\n#ifdef _MSC_VER\n\n#pragma warning(pop)\n\n#else\n\n#pragma GCC diagnostic pop\n\n#endif                                 //_MSC_VER\n"},{"name":"rosnodeinterface.h","type":"header","group":"other","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"//\n// File rosnodeinterface.h\n//\n// Code generated for Simulink model 'inverse_kinematics'.\n//\n// Model version                  : 4.7\n// Simulink Coder version         : 9.7 (R2022a) 13-Nov-2021\n// C/C++ source code generated on : Sun Oct 02 23:17:41 2022\n//\n\n#ifndef _ROS_MATLAB_NODEINTERFACE_\n#define _ROS_MATLAB_NODEINTERFACE_\n#ifdef _MSC_VER\n\n#pragma warning(push)\n#pragma warning(disable : 4265)\n#pragma warning(disable : 4458)\n#pragma warning(disable : 4100)\n\n#else\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpedantic\"\n#pragma GCC diagnostic ignored \"-Wunused-local-typedefs\"\n#pragma GCC diagnostic ignored \"-Wredundant-decls\"\n#pragma GCC diagnostic ignored \"-Wnon-virtual-dtor\"\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#pragma GCC diagnostic ignored \"-Wunused-variable\"\n#pragma GCC diagnostic ignored \"-Wshadow\"\n\n#endif                                 //_MSC_VER\n\n#include \"inverse_kinematics.h\"\n#include \"inverse_kinematics_types.h\"\n#include <thread>\n#include <atomic>\n#include <chrono>\n#include <utility>\n#include <mutex>\n#include <condition_variable>\n#include <ros/ros.h>\n\nnamespace ros\n{\n  namespace matlab\n  {\n    //Semaphore using std::CV and std::mutex\n    class Semaphore {\n     public:\n      std::mutex mMutex;\n      std::condition_variable mCV;\n      std::atomic_uint mCount;\n\n      //\n      Semaphore(int count = 0)\n        : mCount(count)\n      {\n      }\n\n      //\n      inline void notify()\n      {\n        std::unique_lock<std::mutex> lock(mMutex);\n        mCount++;\n        mCV.notify_all();\n      }\n\n      //\n      inline void wait()\n      {\n        std::unique_lock<std::mutex> lock(mMutex);\n        while (mCount == 0) {\n          mCV.wait(lock);\n        }\n\n        if (mCount)\n          mCount--;\n      }\n    };\n\n    //NodeInterface\n    class NodeInterface {\n      NodeInterface(const NodeInterface& );\n      NodeInterface& operator= (const NodeInterface& );\n\n      //\n      std::shared_ptr<ros::NodeHandle> mNode;\n      Semaphore mBaseRateSem;\n      std::shared_ptr<std::thread> mBaseRateThread;\n      std::shared_ptr<std::thread> mSchedulerThread;\n\n      //\n      //\n      Semaphore mStopSem;\n      volatile boolean_T mRunModel;\n     public:\n      NodeInterface();\n      ~NodeInterface();\n\n      //\n      void initialize(int argc, char ** argv);\n      int run();\n      void stop(void);\n      void terminate(void);\n\n      //\n      boolean_T getStopRequestedFlag(void);\n      void schedulerThread(void);\n      void baseRateTask(void);\n      std::shared_ptr<ros::NodeHandle> getNode()\n      {\n        return mNode;\n      }\n    };                                 //class NodeInterface\n\n    std::shared_ptr<ros::matlab::NodeInterface> getNodeInterface();\n  }                                    //namespace matlab\n}                                      //namespace ros\n\n#ifdef _MSC_VER\n\n#pragma warning(pop)\n\n#else\n\n#pragma GCC diagnostic pop\n\n#endif                                 //_MSC_VER\n#endif                                 //_ROS_MATLAB_ROS2CGEN_MULTIRATE_\n"},{"name":"slros_busmsg_conversion.cpp","type":"source","group":"legacy","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"slros_busmsg_conversion.h\"\n\n\n// Conversions between SL_Bus_inverse_kinematics_geometry_msgs_Point and geometry_msgs::Point\n\nvoid convertFromBus(geometry_msgs::Point* msgPtr, SL_Bus_inverse_kinematics_geometry_msgs_Point const* busPtr)\n{\n  const std::string rosMessageType(\"geometry_msgs/Point\");\n\n  msgPtr->x =  busPtr->X;\n  msgPtr->y =  busPtr->Y;\n  msgPtr->z =  busPtr->Z;\n}\n\nvoid convertToBus(SL_Bus_inverse_kinematics_geometry_msgs_Point* busPtr, geometry_msgs::Point const* msgPtr)\n{\n  const std::string rosMessageType(\"geometry_msgs/Point\");\n\n  busPtr->X =  msgPtr->x;\n  busPtr->Y =  msgPtr->y;\n  busPtr->Z =  msgPtr->z;\n}\n\n\n// Conversions between SL_Bus_inverse_kinematics_geometry_msgs_Quaternion and geometry_msgs::Quaternion\n\nvoid convertFromBus(geometry_msgs::Quaternion* msgPtr, SL_Bus_inverse_kinematics_geometry_msgs_Quaternion const* busPtr)\n{\n  const std::string rosMessageType(\"geometry_msgs/Quaternion\");\n\n  msgPtr->w =  busPtr->W;\n  msgPtr->x =  busPtr->X;\n  msgPtr->y =  busPtr->Y;\n  msgPtr->z =  busPtr->Z;\n}\n\nvoid convertToBus(SL_Bus_inverse_kinematics_geometry_msgs_Quaternion* busPtr, geometry_msgs::Quaternion const* msgPtr)\n{\n  const std::string rosMessageType(\"geometry_msgs/Quaternion\");\n\n  busPtr->W =  msgPtr->w;\n  busPtr->X =  msgPtr->x;\n  busPtr->Y =  msgPtr->y;\n  busPtr->Z =  msgPtr->z;\n}\n\n"},{"name":"slros_busmsg_conversion.h","type":"header","group":"other","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _SLROS_BUSMSG_CONVERSION_H_\n#define _SLROS_BUSMSG_CONVERSION_H_\n\n#include <ros/ros.h>\n#include <geometry_msgs/Point.h>\n#include <geometry_msgs/Quaternion.h>\n#include \"inverse_kinematics_types.h\"\n#include \"slros_msgconvert_utils.h\"\n\n\nvoid convertFromBus(geometry_msgs::Point* msgPtr, SL_Bus_inverse_kinematics_geometry_msgs_Point const* busPtr);\nvoid convertToBus(SL_Bus_inverse_kinematics_geometry_msgs_Point* busPtr, geometry_msgs::Point const* msgPtr);\n\nvoid convertFromBus(geometry_msgs::Quaternion* msgPtr, SL_Bus_inverse_kinematics_geometry_msgs_Quaternion const* busPtr);\nvoid convertToBus(SL_Bus_inverse_kinematics_geometry_msgs_Quaternion* busPtr, geometry_msgs::Quaternion const* msgPtr);\n\n\n#endif\n"},{"name":"slros_generic_param.cpp","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2022a/toolbox/ros/codertarget/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2015-2018 The MathWorks, Inc. */\n\n#include \"slros_generic_param.h\"\n\n/**\n * Initialize the parameter getter class.\n * @param pName The name of the ROS parameter\n */\nvoid SimulinkParameterGetterBase::initialize(const std::string& pName) {\n    nodePtr = SLROSNodePtr;\n    paramName = pName;\n    hasValidValue = false;\n}\n\n/**\n * Initialize the constants for the error codes.\n * @param codeSuccess Error code that should be emitted if parameter is retrieved successfully\n * @param codeNoParam Error code if parameter with given name does not exist on server\n * @param codeTypeMismatch Error code if parameter exists on server, but has a different data type\n * @param codeArrayTruncate Error code if received array was truncated\n */\nvoid SimulinkParameterGetterBase::initialize_error_codes(uint8_t codeSuccess,\n                                                         uint8_t codeNoParam,\n                                                         uint8_t codeTypeMismatch,\n                                                         uint8_t codeArrayTruncate) {\n    // Initialize the error codes\n    errorCodeSuccess = codeSuccess;\n    errorCodeNoParam = codeNoParam;\n    errorCodeTypeMismatch = codeTypeMismatch;\n    errorCodeArrayTruncate = codeArrayTruncate;\n}\n"},{"name":"slros_initialize.cpp","type":"source","group":"legacy","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"#include \"slros_initialize.h\"\n\nros::NodeHandle * SLROSNodePtr;\nconst std::string SLROSNodeName = \"inverse_kinematics\";\n\n// For Block inverse_kinematics/Subscriber/Subscribe\nSimulinkSubscriber<geometry_msgs::Point, SL_Bus_inverse_kinematics_geometry_msgs_Point> Sub_inverse_kinematics_482;\n\n// For Block inverse_kinematics/Publisher/Publish\nSimulinkPublisher<geometry_msgs::Quaternion, SL_Bus_inverse_kinematics_geometry_msgs_Quaternion> Pub_inverse_kinematics_487;\n\nvoid slros_node_init(int argc, char** argv)\n{\n  ros::init(argc, argv, SLROSNodeName);\n  SLROSNodePtr = new ros::NodeHandle();\n}\n\n"},{"name":"slros_initialize.h","type":"header","group":"other","path":"/home/alessandrini/Documents/Robot/Eden_Robotics/Matlab/ros/inverse_kinematics_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _SLROS_INITIALIZE_H_\n#define _SLROS_INITIALIZE_H_\n\n#include \"slros_busmsg_conversion.h\"\n#include \"slros_generic.h\"\n#include \"inverse_kinematics_types.h\"\n\nextern ros::NodeHandle * SLROSNodePtr;\nextern const std::string SLROSNodeName;\n\n// For Block inverse_kinematics/Subscriber/Subscribe\nextern SimulinkSubscriber<geometry_msgs::Point, SL_Bus_inverse_kinematics_geometry_msgs_Point> Sub_inverse_kinematics_482;\n\n// For Block inverse_kinematics/Publisher/Publish\nextern SimulinkPublisher<geometry_msgs::Quaternion, SL_Bus_inverse_kinematics_geometry_msgs_Quaternion> Pub_inverse_kinematics_487;\n\nvoid slros_node_init(int argc, char** argv);\n\n#endif\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}]};